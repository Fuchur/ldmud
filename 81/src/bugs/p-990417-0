Short: Pragma 'no_inherit' and 'no_clone'
From: Daniel Sloan
Date: 990410
Type: Patch
State Unclassified

diff-pragmas : A diff for the pragmas '#pragma no_clone' and
               '#pragma no_inherit'.  I emailed you a while ago with the
               concept.  This patch needs some testing done on it, since I'm
               not completely certain about the 'no_inherit' bit in prolang.y.
               However, they are very useful, and so far I've had no problems
               with it.

diff -r -c ldmud-3.2.6/src/lex.c ldmud-dev/src/lex.c
*** ldmud-3.2.6/src/lex.c	Wed Mar 31 12:28:11 1999
--- ldmud-dev/src/lex.c	Sat Apr 10 12:39:02 1999
***************
*** 149,154 ****
--- 149,162 ----
    /* True: give info on the context of an error.
     */
  
+ /* TODO: BOOL */ int pragma_no_clone;
+   /* True: prevent the program from being cloned.
+    */
+ 
+ /* TODO: BOOL */ int pragma_no_inherit;
+   /* True: prevent the program from being inherited.
+    */
+ 
  char *last_lex_string;
    /* When lexing string literals, this is the (shared) string lexed
     * so far. It is used to pass string values to lang.c .
***************
*** 1874,1879 ****
--- 1882,1895 ----
      else if (strcmp(str, "verbose_errors") == 0)
      {
          pragma_verbose_errors = MY_TRUE;
+     }
+     else if (strcmp(str, "no_clone") == 0)
+     {
+         pragma_no_clone = MY_TRUE;
+     }
+     else if (strcmp(str, "no_inherit") == 0)
+     {
+         pragma_no_inherit = MY_TRUE;
  #if defined( DEBUG ) && defined ( TRACE_CODE )
      }
      else if (strcmp(str, "set_code_window") == 0)
***************
*** 3209,3214 ****
--- 3225,3232 ----
  
      pragma_strict_types = PRAGMA_WEAK_TYPES; /* I would prefer !o_flag /Lars */
      instrs[F_CALL_OTHER-F_OFFSET].ret_type = TYPE_ANY;
+     pragma_no_clone = MY_FALSE;
+     pragma_no_inherit = MY_FALSE;
      pragma_save_types = MY_FALSE;
      pragma_verbose_errors = MY_FALSE;
  
diff -r -c ldmud-3.2.6/src/lex.h ldmud-dev/src/lex.h
*** ldmud-3.2.6/src/lex.h	Thu Dec 10 13:37:36 1998
--- ldmud-dev/src/lex.h	Sat Apr 10 12:39:43 1999
***************
*** 141,146 ****
--- 141,148 ----
  extern /* TODO: BOOL */ int pragma_save_types;
  extern /* TODO: BOOL */ int pragma_combine_strings;
  extern /* TODO: BOOL */ int pragma_verbose_errors;
+ extern /* TODO: BOOL */ int pragma_no_clone;
+ extern /* TODO: BOOL */ int pragma_no_inherit;
  extern char *last_lex_string;
  extern struct ident *all_efuns;
  
diff -r -c ldmud-3.2.6/src/prolang.y ldmud-dev/src/prolang.y
*** ldmud-3.2.6/src/prolang.y	Wed Mar 31 12:28:11 1999
--- ldmud-dev/src/prolang.y	Sat Apr 10 12:51:42 1999
***************
*** 1452,1457 ****
--- 1452,1469 ----
                          yyerror("Out of memory");
                          YYACCEPT;
                      }
+ 		    if (ob->prog->flags & P_NO_INHERIT)
+ 		    {
+ 		        /* Hrm, do we need to check anything here?
+ 			 * Should we be doing YYACCEPT?
+ 			 * If any problems appear with
+ 			 * this patch, check here first :-)
+ 			 * However, it seems to work good, even when I watched
+ 			 * it with the debugger.
+ 			 */
+ 		        yyerror("Illegal to inherit an object which sets '#pragma no_inherit'.\n");
+ 			YYACCEPT;
+ 		    }
                      free_string(last_string_constant);
                      last_string_constant = 0;
                      if (ob->flags & O_APPROVED)
***************
*** 5734,5739 ****
--- 5746,5753 ----
          prog->heart_beat = heart_beat;
          prog->id_number =
            ++current_id_number ? current_id_number : renumber_programs();
+         prog->flags = (pragma_no_clone ? P_NO_CLONE : 0) |
+ 	              (pragma_no_inherit ? P_NO_INHERIT : 0);
          prog->load_time = current_time;
          total_prog_block_size += prog->total_size;
          total_num_prog_blocks += 1;
diff -r -c ldmud-3.2.6/src/simulate.c ldmud-dev/src/simulate.c
*** ldmud-3.2.6/src/simulate.c	Wed Mar 31 12:28:11 1999
--- ldmud-dev/src/simulate.c	Sat Apr 10 12:38:57 1999
***************
*** 699,704 ****
--- 699,710 ----
          return 0;
      if (ob->super)
          error("Cloning a bad object !\n");
+ 
+     if (ob->prog->flags & P_NO_CLONE)
+     {
+         error("Illegal to clone an object which sets '#pragma no_clone'.\n");
+     }
+ 
      if (ob->flags & O_CLONE) {
          char c;
          char *p;
