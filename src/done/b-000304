Date:    28.09.99 07:07
From:    sark@oberon.krans.com
To:      lars@bearnip.com
Short: Various bugs
Type: Rejected.
State: New

These are bugs/features which exists in the LPmud Amylaar driver 03.02@316
and 03.02.1@130 running in COMPAT MODE.

--------------------------------<10>---------------------------------------
This is not a bug, but it is probably worth noting that if you try and
overload an efun, in module which inherits another module, then inherited
module will not use the overloaded function unless you declare a prototype
for the function in it.

For example, if you have 2 modules A and B:

    // Module A
    // File: /obj/modules/a

    wake_cmd(str) {
    object ob;

        if (!str || !(ob=find_living(str)))
            return notify_fail("Usage: wake <player>\n");

        tell_object(ob, "BEEP! BEEP!\n");
        write("Ok.\n");
        return 1;
    }

    // Module B
    // File: /obj/modules/b

    inherit "obj/modules/a";

    notify_fail(string msg) {
        write(msg);
    }

    echo_cmd(str) {
        if (!str)
            return notify_fail("Usage: echo <message>\n");

        say(str);
        write("Ok.\n");
        return 1;
    }

    init() {
        add_action("wake_cmd", "wake");
        add_action("echo_cmd", "echo");
    }

Now if you clone module B, and you use the WAKE command, without any
arguments, you will get the error message:

     Usage: wake <player>

However when you use the ECHO command, without any arguments, you will
get the error message:

     Usage: echo <message>

follow by a 'What?'

In order to use the overloaded efun consistently in both modules, you
should declare at the top of module A

     void notify_fail();

If notify_fail() was not an efun, however, you would not need to do this,
and the commands, in both modules, would behave in the same way
