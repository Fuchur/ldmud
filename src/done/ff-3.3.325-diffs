diff -crN 3-3/doc/concepts/mccp 3-3.dafire/doc/concepts/mccp
*** 3-3/doc/concepts/mccp	1970-01-01 01:00:00.000000000 +0100
--- 3-3.dafire/doc/concepts/mccp	2002-12-05 12:53:24.000000000 +0100
***************
*** 0 ****
--- 1,93 ----
+ CONCEPT
+            mccp - The Mud Client Compression Protocol
+ 
+ DESCRIPTION
+ 
+         Informations and code taken from the MCCP Homepage
+         http://www.randomly.org/projects/MCCP/
+ 
+ 	MCCP is implemented as a Telnet option [RFC854, RFC855]. The server
+         and client negotiate the use of MCCP as they would any other telnet
+         option. Once agreement has been reached on the use of the option,
+         option subnegotiation is used to determine acceptable compression
+         methods to use, and to indicate the start of a compressed data stream. 
+ 
+         If the driver is compiled with MCCP Support there is a
+         define __MCCP__.
+ 
+ 	The driver currently supports both versions of mccp. If your mud
+         has a H_NOECHO hook you have to find out if the client supports
+         mccp. Without this hook you still have to start neogotiation.
+ 
+         All sub-negotiation is done by the efuns start_mccp_compress() and
+         end_mccp_compress() whether you have this hook or not.
+ 
+ 	Notice: when the client uses compressions all binary_message calls
+                 are executed with flag=3. This is because writing to the
+                 socket would disturb zlib stream.
+ 	
+         mccp-efuns:
+         start_mysql_compress(int telopt) (only needed with H_NOECHO)
+         end_mysql_compress(int telopt)   (only needed with H_NOECHO)
+         query_mccp(object player)
+ 	query_mccp_stats(object player)
+ 
+      Initiating MCCP without H_NOECHO-Hook:
+         just do:
+         if(!query_mccp()){
+           binary_message(({ IAC, WILL, TELOPT_COMPRESS2 }),1)
+           binary_message(({ IAC, WILL, TELOPT_COMPRESS }),1)
+         }
+ 	the driver will parse the clients answers and start compression.
+ 	(The connection might already be compressed, because although the
+          documentation says clients should not negotiate from themselfes,
+          zmud e.g. does.)
+ 
+ 	You can start and stop compression manually by efuns
+         when you are sure client supports compression :)
+ 
+ 
+      Initiating mccp compression ( the H_NOECHO way )
+ 
+         If your mudlib uses the H_NOECHO driver-hook you decided to do
+         all the negotiation by yourself:
+ 
+         Server Commands
+         IAC WILL COMPRESS indicates the sender supports version 1 of the
+                           protocol, and is willing to compress data it sends. 
+ 
+         IAC WILL COMPRESS2 indicates the sender supports version 2, and is
+                            willing to compress data it sends. 
+ 
+         IAC WONT COMPRESS indicates the sender refuses to compress data using
+                           version 1. 
+ 
+         IAC WONT COMPRESS2 indicates the sender refuses to compress data
+                            using version 2. 
+ 
+         Client Commands
+         IAC DO COMPRESS indicates the sender supports version 1 of the
+                         protocol, and is willing to decompress data received. 
+ 
+         IAC DO COMPRESS2 indicates the sender supports version 2 or above,
+                          and is willing to decompress data received. 
+ 
+         IAC DONT COMPRESS indicates the sender refuses to support version 1.
+                           If compression was previously negotiated and is
+                           currently being used, the server should terminate
+                           compression. 
+ 
+         IAC DONT COMPRESS2 indicates the sender refuses to support version 2.
+                            If compression was previously negotiated and is
+                            currently being used, the server should terminate
+                            compression
+ 
+         After you found out whether the client supports mccp or not you can
+         start compression with start_mccp_compress(TELOPT_COMPRESS2) or
+         start_mccp_compress(TELOPT_COMPRESS). ( you could start it without
+         checking but some players would protest :) )
+ 
+ AUTHOR
+         Bastian Hoyer (dafire@ff.mud.de) (some text taken from project page)
+ 
+ HISTORY
diff -crN 3-3/doc/driver/predefined 3-3.dafire/doc/driver/predefined
*** 3-3/doc/driver/predefined	2002-11-18 06:23:13.000000000 +0100
--- 3-3.dafire/doc/driver/predefined	2002-12-05 12:42:15.000000000 +0100
***************
*** 68,73 ****
--- 68,74 ----
  
        __IPV6__ :      support for IP v 6
        __MYSQL__ :     support for mySQL
+       __MCCP__:       support for MCCP http://www.randomly.org/projects/MCCP
        __ALISTS__:     support for alists
        __PCRE__:       support for PCRE instead of traditional regexps.
        __DEPRECATED__: support for obsolete and deprecated efuns.
***************
*** 89,93 ****
--- 90,97 ----
      3.3 made __LPC_NOSAVE__ always defined and added __ALISTS__,
          __LPC_STRUCTS__, __LPC_INLINE_CLOSURES__, and __PCRE__.
  
+     mccp patch added __PCRE__.
+ 
  SEE ALSO
      pragma(LPC), preprocessor(LPC)
+ 
diff -crN 3-3/doc/efun/end_mccp_compress 3-3.dafire/doc/efun/end_mccp_compress
*** 3-3/doc/efun/end_mccp_compress	1970-01-01 01:00:00.000000000 +0100
--- 3-3.dafire/doc/efun/end_mccp_compress	2002-12-06 13:46:35.000000000 +0100
***************
*** 0 ****
--- 1,9 ----
+ SYNOPSIS
+         int end_mccp_compress()
+ 
+ DESCRIPTION
+         This efun must be called inside an interactive player and stops
+         compression of the driver -> client traffic immediatly.
+ 
+ SEE ALSO
+         start_mccp_compress(E), query_mccp(E), query_mccp_stats(E), mccp(C)
\ Kein Zeilenumbruch am Dateiende.
diff -crN 3-3/doc/efun/query_mccp 3-3.dafire/doc/efun/query_mccp
*** 3-3/doc/efun/query_mccp	1970-01-01 01:00:00.000000000 +0100
--- 3-3.dafire/doc/efun/query_mccp	2002-12-05 12:53:45.000000000 +0100
***************
*** 0 ****
--- 1,13 ----
+ SYNOPSIS
+         int query_mccp()
+         int query_mccp(object player)
+ 
+ DESCRIPTION
+         This efun returns current wheter the client uses compression
+         or not. ( default this_player() )
+ 	You will get either TELOPT_COMPRESS, TELOPT_COMPRESS2 or 0 if the
+ 	connection is uncompressed.
+ 
+ SEE ALSO
+         end_mccp_compress(E), start_mccp_compress(E), query_mccp_stats(E),
+         mccp(C)
\ Kein Zeilenumbruch am Dateiende.
diff -crN 3-3/doc/efun/query_mccp_stats 3-3.dafire/doc/efun/query_mccp_stats
*** 3-3/doc/efun/query_mccp_stats	1970-01-01 01:00:00.000000000 +0100
--- 3-3.dafire/doc/efun/query_mccp_stats	2002-12-05 12:53:45.000000000 +0100
***************
*** 0 ****
--- 1,13 ----
+ SYNOPSIS
+         int *query_mccp_stats()
+         int *query_mccp_stats(object player)
+ 
+ DESCRIPTION
+         This efun gives you statistics about current compression
+         of the player. ( default this_player() )
+         You get an array with ({ uncompressed bytes , compressed bytes }).
+         If the connection is not compressed it returns 0.
+         It raises an error on not-interactive objects.
+ 
+ SEE ALSO
+         end_mccp_compress(E), start_mccp_compress(E), query_mccp(E), mccp(C)
\ Kein Zeilenumbruch am Dateiende.
diff -crN 3-3/doc/efun/start_mccp_compress 3-3.dafire/doc/efun/start_mccp_compress
*** 3-3/doc/efun/start_mccp_compress	1970-01-01 01:00:00.000000000 +0100
--- 3-3.dafire/doc/efun/start_mccp_compress	2002-12-06 13:45:57.000000000 +0100
***************
*** 0 ****
--- 1,11 ----
+ SYNOPSIS
+         int start_mccp_compress(int telopt)
+ 
+ DESCRIPTION
+         This efun must be called inside an interactive player and starts
+         compression of the driver -> client traffic immediatly.
+ 	telopt must be either TELOPT_COMPRESS2 or TELOPT_COMRESS from
+ 	sys/telnet.h.
+ 
+ SEE ALSO
+         end_mccp_compress(E), query_mccp(E), query_mccp_stats(E), mccp(C)
\ Kein Zeilenumbruch am Dateiende.
diff -crN 3-3/src/autoconf/configure.in 3-3.dafire/src/autoconf/configure.in
*** 3-3/src/autoconf/configure.in	2002-12-03 08:26:07.000000000 +0100
--- 3-3.dafire/src/autoconf/configure.in	2002-12-05 12:46:48.000000000 +0100
***************
*** 107,112 ****
--- 107,113 ----
  AC_MY_ARG_ENABLE(use-alists,no,,[Enables alist support])
  AC_MY_ARG_ENABLE(use-mysql,no,,[Enables mySQL support])
  AC_MY_ARG_ENABLE(use-pthreads,no,,[enable using of threads for socket writes])
+ AC_MY_ARG_ENABLE(use-mccp,no,,[Enables MCCP support])
  AC_MY_ARG_ENABLE(use-pcre,yes,,[Enables PCRE instead of traditional regexps])
  AC_MY_ARG_ENABLE(use-deprecated,yes,,[Enables obsolete and deprecated efuns])
  AC_MY_ARG_ENABLE(use-structs,yes,,[Enables structs])
***************
*** 252,257 ****
--- 253,259 ----
  AC_CDEF_FROM_ENABLE(initialization_by___init)
  AC_CDEF_FROM_ENABLE(use_system_crypt)
  AC_CDEF_FROM_ENABLE(use_alists)
+ AC_CDEF_FROM_ENABLE(use_mccp)
  AC_CDEF_FROM_ENABLE(use_pcre)
  AC_CDEF_FROM_ENABLE(use_pthreads)
  AC_CDEF_FROM_ENABLE(use_ipv6)
***************
*** 545,550 ****
--- 547,558 ----
      AC_CHECK_LIB(resolv,main, LIBS="$LIBS -lresolv")
  fi
  
+ # --- Check if we need zlib libraries for mccp ---
+ 
+ if test "x$enable_use_mccp" = "x" || test "x$enable_use_mccp" = "xyes"; then
+    AC_CHECK_LIB(z,main, LIBS="$LIBS -lz")
+ fi
+ 
  # --- Check if we need the crypto libraries ---
  
  if test "x$enable_use_system_crypt" = "x" || test "x$enable_use_system_crypt" = "xyes"; then
***************
*** 1837,1842 ****
--- 1845,1851 ----
  AC_SUBST(cdef_use_mysql)
  AC_SUBST(cdef_use_pthreads)
  AC_SUBST(cdef_use_alists)
+ AC_SUBST(cdef_use_mccp)
  AC_SUBST(cdef_use_pcre)
  AC_SUBST(cdef_use_deprecated)
  AC_SUBST(cdef_use_structs)
diff -crN 3-3/src/comm.c 3-3.dafire/src/comm.c
*** 3-3/src/comm.c	2002-12-05 12:25:54.000000000 +0100
--- 3-3.dafire/src/comm.c	2002-12-05 12:40:05.000000000 +0100
***************
*** 446,451 ****
--- 446,457 ----
  
  /* Forward declarations */
  
+ #ifdef USE_MCCP
+ static int start_compress(interactive_t *,unsigned char telopt);
+ static int end_compress(interactive_t *);
+ #endif
+ static void mccp_telnet_neg(int);
+ 
  static void free_input_to(input_to_t *);
  static void telnet_neg(interactive_t *);
  static void send_will(int);
***************
*** 1384,1391 ****
  #ifdef USE_PTHREADS
  
  static int
! thread_socket_write(SOCKET_T s UNUSED, char *msg, size_t size, interactive_t *ip)
! 
  /* Stand in for socket_write(): take the data to be written and append
   * it to the buffer list of <ip>.
   */
--- 1390,1396 ----
  #ifdef USE_PTHREADS
  
  static int
! thread_socket_write(SOCKET_T s UNUSED, char *msg, size_t size, interactive_t *ip, int docompress)
  /* Stand in for socket_write(): take the data to be written and append
   * it to the buffer list of <ip>.
   */
***************
*** 1405,1410 ****
--- 1410,1422 ----
      b->length = size;
      b->next = NULL;
  
+ #ifdef USE_MCCP
+     if (ip->out_compress)   
+       b->compress = docompress;
+     else
+ #endif
+       b->compress = 0;
+ 
      memcpy(b->buffer, msg, size);
  
      /* Chain in the new buffer */
***************
*** 1500,1506 ****
  
  {
      interactive_t *ip = (interactive_t *) arg;
!     int oldvalue;
  
      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldvalue); /* make us cancelable */
      pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldvalue);
--- 1512,1518 ----
  
  {
      interactive_t *ip = (interactive_t *) arg;
!     int oldvalue,length;
  
      pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldvalue); /* make us cancelable */
      pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldvalue);
***************
*** 1553,1563 ****
          {
              /* write the stuff to socket */
              buf->errorno = 0;
              if ((socket_write(ip->socket, buf->buffer, buf->length)) == -1)
              {
                  buf->errorno = errno;
              } /* if socket_write() == -1 */
! 
              /* Don't xfree(buf) here as smalloc is not threadsafe! */
              pthread_mutex_lock(&ip->write_mutex);
  
--- 1565,1610 ----
          {
              /* write the stuff to socket */
              buf->errorno = 0;
+ #ifdef USE_MCCP
+ 	    if (buf->compress)
+ 	      {
+ 		int status;
+ 		ip->out_compress->next_in = (unsigned char *) buf->buffer;
+ 		ip->out_compress->avail_in = buf->length;
+ 		ip->out_compress->avail_out = COMPRESS_BUF_SIZE -
+ 		  (ip->out_compress->next_out -
+ 		   ip->out_compress_buf);
+ 		
+ 		status = deflate(ip->out_compress, Z_SYNC_FLUSH);
+ 		
+ 		if (status != Z_OK)
+ 		  printf("compression error!!!!!!!\n");
+ 		length = ip->out_compress->next_out - ip->out_compress_buf;
+ 	      }
+ 	    
+  	    if (buf->compress)
+  	      {
+  		if ((socket_write(ip->socket, ip->out_compress_buf, length)) == -1)
+  		  { 
+  		    buf->errorno = errno;
+  		  } /* if socket_write() == -1 */
+ 		
+  		/* we update the compressed buffer here */
+  		ip->out_compress->next_out = ip->out_compress_buf;
+  	      }
+ 	    else
+ 	      {
+ 		if ((socket_write(ip->socket, buf->buffer, buf->length)) == -1)
+ 		  {
+ 		    buf->errorno = errno;
+ 		  } /* if socket_write() == -1 */
+ 	      }
+ #else
              if ((socket_write(ip->socket, buf->buffer, buf->length)) == -1)
              {
                  buf->errorno = errno;
              } /* if socket_write() == -1 */
! #endif
              /* Don't xfree(buf) here as smalloc is not threadsafe! */
              pthread_mutex_lock(&ip->write_mutex);
  
***************
*** 1963,1987 ****
           * If it is enough, send it, else terminate the outer loop
           * (because *source must be exhausted for this to happen).
           */
          chunk = dest - ip->message_buf;
          if (chunk < min_length)
          {
              break;
          }
  
!         /* Write .message_buf[] to the network. */
! 
          for (retries = 6;;) {
! 
  #ifdef USE_PTHREADS
!             if ((n = (int)thread_socket_write(ip->socket, ip->message_buf, (size_t)chunk, ip)) != -1)
  #else
              if ((n = (int)socket_write(ip->socket, ip->message_buf, (size_t)chunk)) != -1)
  #endif
!             {
!                 break;
!             }
!             switch (errno) {
                case EINTR:
                  if (--retries)
                      continue;
--- 2010,2077 ----
           * If it is enough, send it, else terminate the outer loop
           * (because *source must be exhausted for this to happen).
           */
+ 
          chunk = dest - ip->message_buf;
          if (chunk < min_length)
          {
              break;
          }
  
! #if !defined(USE_PTHREADS) && defined(USE_MCCP)
!         if (ip->out_compress)
! 	  {
! 	    
! 	    ip->out_compress->next_in = (unsigned char *) ip->message_buf;
! 	    ip->out_compress->avail_in = chunk;
! 	    
! 	    ip->out_compress->avail_out = COMPRESS_BUF_SIZE -
! 	      (ip->out_compress->next_out -
! 	       ip->out_compress_buf);
! 	    
! 	    {
!               int status = deflate(ip->out_compress, Z_SYNC_FLUSH);
!               
!               if (status != Z_OK)
! 		return;
! 	    }
! 	    
! 	    /* ok.. perhaps i should take care that all data in message_buf
! 	       is compressed, but i guess there is no chance that 1024 byte compressed
! 	       won't fit into the 8192 byte buffer */
! 	    
! 	    length = ip->out_compress->next_out - ip->out_compress_buf;
! 	  }
! #endif  
!         /* now sending the buffer... */
!         
          for (retries = 6;;) {
!            
  #ifdef USE_PTHREADS
! 	  if ((n = (int)thread_socket_write(ip->socket, ip->message_buf, (size_t)chunk, ip, 1)) != -1)
! 	    {
! 	      break;
! 	    }
  #else
+ # ifdef USE_MCCP
+ 	  if (ip->out_compress) /* here we choose the correct buffer */	     
+ 	    {
+ 	      if ((n = (int)socket_write(ip->socket, ip->out_compress_buf, (size_t)length)) != -1)
+ 		{
+ 		  break;
+ 		}
+ 	    }
+ 	  else 
+ 	    {
+ # endif
              if ((n = (int)socket_write(ip->socket, ip->message_buf, (size_t)chunk)) != -1)
+ 	      {
+ 		break;
+ 	      }
+ # ifdef USE_MCCP
+ 	    }
+ # endif
  #endif
! 	  switch (errno) {
                case EINTR:
                  if (--retries)
                      continue;
***************
*** 2040,2048 ****
          inet_packets++;
          inet_volume += n;
  #endif
!         if (n != chunk)
!             fprintf(stderr, "%s write socket: wrote %ld, should be %ld.\n"
!                           , time_stamp(), (long)n, (long)chunk);
  
          /* Continue with the processing of source */
          dest = &ip->message_buf[0];
--- 2130,2150 ----
          inet_packets++;
          inet_volume += n;
  #endif
! 
! #if defined(USE_MCCP) && !defined(USE_PTHREADS)
! 	if (ip->out_compress)
! 	  {
!             /* we update the compressed buffer here */
!             ip->out_compress->next_out = ip->out_compress_buf + length - n;
! 	    if (n != length)
! 	      fprintf(stderr, "%s write socket (compressed): wrote %ld, should be %ld.\n"
! 		      , time_stamp(), (long)n, (long)chunk);
! 	  }
! 	else
! #endif
! 	if (n != chunk)
! 	  fprintf(stderr, "%s write socket: wrote %ld, should be %ld.\n"
! 		  , time_stamp(), (long)n, (long)chunk);
  
          /* Continue with the processing of source */
          dest = &ip->message_buf[0];
***************
*** 3047,3053 ****
                      {
  #ifdef USE_PTHREADS
                          thread_socket_write(ip->socket, ip->text + ip->chars_ready
!                                     , (size_t)(length - ip->chars_ready), ip);
  #else
                          socket_write(ip->socket, ip->text + ip->chars_ready
                                      , (size_t)(length - ip->chars_ready));
--- 3149,3155 ----
                      {
  #ifdef USE_PTHREADS
                          thread_socket_write(ip->socket, ip->text + ip->chars_ready
!                                     , (size_t)(length - ip->chars_ready), ip, 0);
  #else
                          socket_write(ip->socket, ip->text + ip->chars_ready
                                      , (size_t)(length - ip->chars_ready));
***************
*** 3243,3248 ****
--- 3345,3354 ----
            /* buffer list is returned by thread */
          interactive_cleanup(interactive);
  #endif
+ #ifdef USE_MCCP
+ 	if (interactive->out_compress)
+ 	  end_compress(interactive);
+ #endif
          shutdown(interactive->socket, 2);
          socket_close(interactive->socket);
      } /* if (erq or user) */
***************
*** 3269,3278 ****
          free_object(interactive->modify_command, "remove_interactive");
      }
  
  #ifdef USE_PTHREADS
!     pthread_mutex_destroy(&interactive->write_mutex);
!     pthread_cond_destroy(&interactive->write_cond);
  #endif
      free_svalue(&interactive->prompt);
  
      if (interactive->trace_prefix)
--- 3375,3392 ----
          free_object(interactive->modify_command, "remove_interactive");
      }
  
+ #ifdef USE_MCCP
+     if (interactive->out_compress_buf)
+        free(interactive->out_compress_buf);
+     if (interactive->out_compress)
+        free(interactive->out_compress);
+ #endif
  #ifdef USE_PTHREADS
!      pthread_mutex_destroy(&interactive->write_mutex);
!      pthread_cond_destroy(&interactive->write_cond);
  #endif
+ 
+     
      free_svalue(&interactive->prompt);
  
      if (interactive->trace_prefix)
***************
*** 3476,3481 ****
--- 3590,3601 ----
  
      /* Initialize the rest of the interactive structure */
  
+ #ifdef USE_MCCP
+     new_interactive->compressing = 0;
+     new_interactive->out_compress = NULL;
+     new_interactive->out_compress_buf=NULL;
+ #endif
+     
      new_interactive->input_to = NULL;
      put_number(&new_interactive->prompt, 0);
      new_interactive->modify_command = NULL;
***************
*** 4575,4581 ****
      }
  } /* reply_h_telnet_neg() */
  
! /*-------------------------------------------------------------------------*/
  void
  init_telopts (void)
  
--- 4695,4703 ----
      }
  } /* reply_h_telnet_neg() */
  
! /*-
! 
!   -----------------------------------------------------------------------*/
  void
  init_telopts (void)
  
***************
*** 4681,4695 ****
  
      /* Mud specific protocols */
  
!     telopts_do[TELOPT_COMPRESS] = reply_h_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS] = reply_h_telnet_neg;
!     telopts_will[TELOPT_COMPRESS] = reply_h_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS] = reply_h_telnet_neg;
! 
!     telopts_do[TELOPT_COMPRESS2] = reply_h_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS2] = reply_h_telnet_neg;
!     telopts_will[TELOPT_COMPRESS2] = reply_h_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS2] = reply_h_telnet_neg;
  
      telopts_do[TELOPT_MSP] = reply_h_telnet_neg;
      telopts_dont[TELOPT_MSP] = reply_h_telnet_neg;
--- 4803,4817 ----
  
      /* Mud specific protocols */
  
!     telopts_do[TELOPT_COMPRESS] = mccp_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS] = mccp_telnet_neg;
!     telopts_will[TELOPT_COMPRESS] = mccp_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS] = mccp_telnet_neg;
! 
!     telopts_do[TELOPT_COMPRESS2] = mccp_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS2] = mccp_telnet_neg;
!     telopts_will[TELOPT_COMPRESS2] = mccp_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS2] = mccp_telnet_neg;
  
      telopts_do[TELOPT_MSP] = reply_h_telnet_neg;
      telopts_dont[TELOPT_MSP] = reply_h_telnet_neg;
***************
*** 4897,4907 ****
                      if (to > &ip->text[ip->chars_ready])
                      {
                          thread_socket_write(ip->socket, &ip->text[ip->chars_ready],
!                           (size_t)(to - &ip->text[ip->chars_ready]), ip);
                          ip->chars_ready = to - ip->text;
                      }
                      if (to > first) {
!                         thread_socket_write(ip->socket, "\b \b", 3, ip);
                          to--;
                          ip->chars_ready--;
                      }
--- 5019,5029 ----
                      if (to > &ip->text[ip->chars_ready])
                      {
                          thread_socket_write(ip->socket, &ip->text[ip->chars_ready],
!                           (size_t)(to - &ip->text[ip->chars_ready]), ip, 0);
                          ip->chars_ready = to - ip->text;
                      }
                      if (to > first) {
!                         thread_socket_write(ip->socket, "\b \b", 3, ip, 0);
                          to--;
                          ip->chars_ready--;
                      }
***************
*** 6465,6470 ****
--- 6587,6596 ----
   * codes for colours and other things needs to bypass the allowed
   * charset filters, but isn't important enough to waste bandwith
   * on a synchronous transmission.
+  *
+  * If the client uses MCCP compression add_message ist always used
+  * with flushing buffer _after_ the Message.
+  *
   */
  
  {
***************
*** 6512,6518 ****
--- 6638,6648 ----
          save_command_giver = command_giver;
          command_giver = current_object;
  
+ #ifdef USE_MCCP
+ 	if ((sp->u.number & 1)||ip->out_compress)
+ #else
          if (sp->u.number & 1)
+ #endif
          {
              /* Write before flush... */
  
***************
*** 6522,6529 ****
  
              sending_telnet_command = MY_FALSE;
  
              if (sp->u.number & 2)
!                 add_message(message_flush);
              wrote = mstrsize(msg);
          }
          else
--- 6652,6664 ----
  
              sending_telnet_command = MY_FALSE;
  
+ #ifdef USE_MCCP
+             if ((sp->u.number & 2)||ip->out_compress)
+ 	      add_message(message_flush);
+ #else
              if (sp->u.number & 2)
! 	      add_message(message_flush);
! #endif
              wrote = mstrsize(msg);
          }
          else
***************
*** 6538,6544 ****
              for (i = 6; i > 0; i--) {
  #ifdef USE_PTHREADS
                  wrote = (mp_int)thread_socket_write(ip->socket, get_txt(msg)
!                                                    , mstrsize(msg), ip);
  #else
                  wrote = (mp_int)socket_write(ip->socket, get_txt(msg), mstrsize(msg));
  #endif
--- 6673,6679 ----
              for (i = 6; i > 0; i--) {
  #ifdef USE_PTHREADS
                  wrote = (mp_int)thread_socket_write(ip->socket, get_txt(msg)
!                                                    , mstrsize(msg), ip, 1);
  #else
                  wrote = (mp_int)socket_write(ip->socket, get_txt(msg), mstrsize(msg));
  #endif
***************
*** 7757,7759 ****
--- 7892,8208 ----
  } /* f_query_udp_port() */
  
  /***************************************************************************/
+ 
+ static void
+ mccp_telnet_neg (int option)
+ {
+   interactive_t *ip = O_GET_INTERACTIVE (command_giver);
+   
+    switch (ip->tn_state)
+      {
+      case TS_WILL:
+        DTF(("MCCP NEG (%d) STATE (WILL)\n", option));
+        break;
+      case TS_WONT:
+        DTF(("MCCP NEG (%d) STATE (WONT)\n", option));
+        break;
+      case TS_DO:
+        DTF(("MCCP NEG (%d) STATE (DO)\n", option));
+ #ifdef USE_MCCP
+        if (!ip->compressing)
+ 	 start_compress(ip, option);
+ #endif
+        break;
+      case TS_DONT:
+        DTF(("MCCP NEG (%d) STATE (DONT)\n", option));
+ #ifdef USE_MCCP
+        if(ip->compressing==option)
+ 	 end_compress(ip);
+ #endif
+        break;
+      default:
+        DTF(("MCCP NEG (%d) STATE (%d)\n", option, ip->tn_state));
+      }
+ }
+ 
+ #ifdef USE_MCCP
+ 
+ svalue_t *
+ f_start_mccp_compress (svalue_t * sp)
+ {
+   interactive_t *ip;
+   int mccpver;
+   int retval;
+   
+   mccpver=sp->u.number;
+   
+   if ((mccpver!=TELOPT_COMPRESS)&&
+       (mccpver!=TELOPT_COMPRESS2))
+     {
+       error("arg 1 should be TELOPT_COMPRESS or TELOPT_COMPRESS2.\n");
+       return sp;
+     }
+   
+   if (!O_SET_INTERACTIVE(ip, current_object))
+     {
+       error("start_mccp_compress() must be called inside the interactive\n");
+       return sp;
+     }
+   
+   free_svalue(sp);
+   retval=start_compress(ip,mccpver);
+   put_number(sp,retval);
+   
+   return sp;
+ }
+ 
+ svalue_t *
+ f_end_mccp_compress (svalue_t * sp)
+ {
+   interactive_t *ip;
+   int retval;
+   
+   if (!O_SET_INTERACTIVE(ip, current_object))
+     {
+       error("end_mccp_compress() must be called inside the interactive\n");
+       return sp;
+     }
+   
+   retval=end_compress(ip);
+   sp++;
+   put_number(sp,retval);
+   
+   return sp;
+ }
+ 
+ 
+ svalue_t *
+ f_query_mccp (svalue_t * sp)
+      /* EFUN query_mccp()
+       *
+       * int query_mccp(object ob)
+       *
+       * this efun returns 0 if no mccp is used for interactive ob.
+       * if ob|this_player uses mccp it returns TELOPT_COMPRESS or
+       * TELOPT_COMPRESS2
+       */
+ {
+   interactive_t *ip;
+   
+   /* Make sure the object is interactive */
+   if (!(O_SET_INTERACTIVE (ip, sp->u.ob)) || ip->closing)
+     {
+       error ("Bad arg 1 to query_mccp(): object not interactive.\n");
+       return sp;
+     }
+   
+   free_svalue (sp);
+   put_number (sp, ip->compressing);
+   
+   return sp;
+ }				/* query_mccp() */
+ 
+ svalue_t *
+ f_query_mccp_stats (svalue_t * sp)
+      /* EFUN query_mccp_stats()
+       *
+       * int *query_mccp_stats(object ob)
+       *
+       * if the connection of interactive ob ( or this_object() if ob==0 )
+       * is compressed it returns an array with zlib statistics
+       * ({ total_in, total_out }) ( uncompressed/compressed)
+       *
+       */
+ {
+   interactive_t *ip;
+   vector_t *mccp_stats;
+   
+   /* Make sure the object is interactive */
+   if (!(O_SET_INTERACTIVE (ip, sp->u.ob)) || ip->closing)
+     {
+       error ("Bad arg 1 to query_mccp_stats(): object not interactive.\n");
+       return sp;
+     }
+   
+   free_svalue (sp);
+   
+   if (ip->compressing > 0)
+     {
+       mccp_stats = allocate_uninit_array (2);
+       put_number (mccp_stats->item, ip->out_compress->total_in);
+       put_number (mccp_stats->item + 1, ip->out_compress->total_out);
+       put_array (sp, mccp_stats);
+     }
+   else
+     {
+       put_number (sp, 0);
+     }
+   return sp;
+ }				/* query_mccp_stats() */
+ 
+ 
+ /*
+  * the rest of the file is sligthly modified taken from the mccp-site so
+  * the header of the original file remains here:
+  */
+ 
+ /*
+  * mccp.c - support functions for the Mud Client Compression Protocol
+  *
+  * see http://www.randomly.org/projects/MCCP/
+  *
+  * Copyright (c) 1999, Oliver Jowett <oliver@randomly.org>
+  *
+  * This code may be freely distributed and used if this copyright
+  * notice is retained intact.
+  */
+ 
+ void *
+ zlib_alloc (void *opaque, unsigned int items, unsigned int size)
+ {
+   return calloc (items, size);
+ }
+ 
+ void
+ zlib_free (void *opaque, void *address)
+ {
+   free (address);
+ }
+ 
+ 
+ static int
+ start_compress (interactive_t * ip, unsigned char telopt)
+ {
+   z_stream *s;
+   
+   /* already compressing */
+   if (ip->out_compress)
+     return 1;
+   
+   /* allocate and init stream, buffer */
+   s = (z_stream *) malloc (sizeof (*s));
+   ip->out_compress_buf = (unsigned char *) malloc (COMPRESS_BUF_SIZE);
+   
+   s->next_in = NULL;
+   s->avail_in = 0;
+   s->next_out = ip->out_compress_buf;
+   s->avail_out = COMPRESS_BUF_SIZE;
+   s->zalloc = zlib_alloc;
+   s->zfree = zlib_free;
+   s->opaque = NULL;
+   
+   if (deflateInit (s, 9) != Z_OK)
+     {
+       free (ip->out_compress_buf);
+       free (s);
+       return 0;
+     }
+   
+   /* version 1 or 2 support */
+   if (telopt == TELOPT_COMPRESS)
+     {
+       DTF (("%s TDEBUG: send IAC SB %02x WILL SE\n", time_stamp (), telopt));
+       SEND_TELNET_COMMAND (add_message ("%c", IAC);
+  			   add_message ("%c%c%c%c", SB, telopt, WILL, SE);
+  			   add_message (message_flush););
+     }
+   else if (telopt == TELOPT_COMPRESS2)
+     {
+       DTF (("%s TDEBUG: send IAC SB %02x WILL SE\n", time_stamp (), telopt));
+       SEND_TELNET_COMMAND (add_message ("%c", IAC);
+  			   add_message ("%c%c%c%c", SB, telopt, IAC, SE);
+  			   add_message (message_flush););
+     }
+   else
+     {
+       printf ("Bad teleoption %d passed", telopt);
+       free (ip->out_compress_buf);
+       free (s);
+       return 0;
+     }
+   
+   ip->compressing = telopt;
+   ip->out_compress = s;
+   
+   printf("%s MCCP-DEBUG: '%s' mccp started (%d)\n", time_stamp(), get_txt(ip->ob->name),telopt);
+   
+   /* success */
+   return 1;
+ }
+ 
+ /* Try to send any pending compressed-but-not-sent data in `desc' */
+ int
+ process_compressed (interactive_t * ip)
+ {
+   int iStart, nBlock, nWrite, len;
+   
+   if (!ip->out_compress)
+     return 1;
+   
+   len = ip->out_compress->next_out - ip->out_compress_buf;
+   if (len > 0)
+     {
+       for (iStart = 0; iStart < len; iStart += nWrite)
+  	{
+  	  nBlock = UMIN (len - iStart, 4096);
+  	  if ((nWrite =
+  	       write (ip->socket, ip->out_compress_buf + iStart, nBlock)) < 0)
+  	    {
+  	      if (errno == EAGAIN || errno == ENOSR)
+  		break;
+ 	      
+  	      /* write error */
+ 	      return 0;
+  	    }
+  	  if (nWrite <= 0)
+  	    break;
+  	}
+       
+       if (iStart)
+  	{
+ 	  if (iStart < len)
+  	    memmove (ip->out_compress_buf, ip->out_compress_buf + iStart,
+  		     len - iStart);
+ 	  
+  	  ip->out_compress->next_out = ip->out_compress_buf + len - iStart;
+  	}
+     }
+   
+   /* success */
+   return 1;
+ }
+ 
+ /* Cleanly shut down compression on `desc' */
+ static int
+ end_compress (interactive_t * ip)
+ {
+   unsigned char dummy[1];
+   
+   if (!ip->out_compress)
+     return 1;
+  
+   ip->out_compress->avail_in = 0;
+   ip->out_compress->next_in = dummy;
+   
+   /* No terminating signature is needed - receiver will get Z_STREAM_END */
+    if (deflate (ip->out_compress, Z_FINISH) != Z_STREAM_END)
+      return 0;
+  
+    /* try to send any residual data */
+    if (!process_compressed (ip))
+      return 0;
+    
+    /* reset compression values */
+    deflateEnd (ip->out_compress);
+    free (ip->out_compress_buf);
+    free (ip->out_compress);
+    ip->compressing = 0;
+    ip->out_compress = NULL;
+    ip->out_compress_buf = NULL;
+  
+    printf("%s MCCP-DEBUG: '%s' mccp ended\n", time_stamp(), get_txt(ip->ob->name));
+    
+    /* success */
+    return 1;
+ }
+ #endif
diff -crN 3-3/src/comm.h 3-3.dafire/src/comm.h
*** 3-3/src/comm.h	2002-11-01 02:55:56.000000000 +0100
--- 3-3.dafire/src/comm.h	2002-12-05 12:27:09.000000000 +0100
***************
*** 8,13 ****
--- 8,17 ----
  #include <pthread.h>
  #endif
  
+ #ifdef USE_MCCP
+ # include <zlib.h>
+ #endif
+ 
  #include "simulate.h"   /* callback_t for input_to_t */
  #include "svalue.h"
  
***************
*** 105,110 ****
--- 109,115 ----
  struct write_buffer_s
  {
      struct write_buffer_s *next;
+     int compress; /* should the buffer get compressed by mccp? */
      size_t length;
      int    errorno; /* After writing, the errno */
      char buffer[1 /* .length */ ];
***************
*** 207,230 ****
      char message_buf[MAX_SOCKET_PACKET_SIZE];
        /* The send buffer. */
  
  #ifdef USE_PTHREADS
!     /* The data exchange with the writer thread happens through two
!      * lists: write_first/write_last hands of data to write to
!      * the thread, written_first receives the written buffers.
!      * Reason for this 2-way exchange is that the writer thread
!      * must not call xfree().
!      * TODO: These two lists + one extra can be combined into
!      * TODO:: one list, plus two roving pointers into it.
!      */
!     pthread_mutex_t        write_mutex;
!     pthread_cond_t         write_cond;
!     pthread_t              write_thread;
!     struct write_buffer_s *write_first;  /* List of buffers to write */
!     struct write_buffer_s *write_last;
!     unsigned long          write_size;
!     struct write_buffer_s *write_current; /* Buffer currently written */
!     struct write_buffer_s *written_first; /* List of written buffers */
! #endif
  };
  
  /* --- Bitflags and masks for interactive.noecho ---
--- 212,242 ----
      char message_buf[MAX_SOCKET_PACKET_SIZE];
        /* The send buffer. */
  
+ #ifdef USE_MCCP
+    unsigned char   compressing;                 /* MCCP support */
+    z_stream      * out_compress;                /* MCCP support */
+    unsigned char * out_compress_buf;            /* MCCP support */
+ #endif   
+ 
  #ifdef USE_PTHREADS
!      /* The data exchange with the writer thread happens through two
!       * lists: write_first/write_last hands of data to write to
!       * the thread, written_first receives the written buffers.
!       * Reason for this 2-way exchange is that the writer thread
!       * must not call xfree().
!       * TODO: These two lists + one extra can be combined into
!       * TODO:: one list, plus two roving pointers into it.
!       */
!      pthread_mutex_t        write_mutex;
!      pthread_cond_t         write_cond;
!      pthread_t              write_thread;
!      struct write_buffer_s *write_first;  /* List of buffers to write */
!      struct write_buffer_s *write_last;
!      unsigned long          write_size;
!      struct write_buffer_s *write_current; /* Buffer currently written */
!      struct write_buffer_s *written_first; /* List of written buffers */
!   #endif
!    
  };
  
  /* --- Bitflags and masks for interactive.noecho ---
***************
*** 386,389 ****
--- 398,404 ----
  extern void refresh_access_data(void (*add_entry)(struct sockaddr_in *, int, long*) );
  #endif /* ACCESS_CONTROL */
  
+ #define COMPRESS_BUF_SIZE 8192
+ #define UMIN(a,b) ((a) < (b) ? (a) : (b))
+ 
  #endif /* COMM_H__ */
diff -crN 3-3/src/config.h.in 3-3.dafire/src/config.h.in
*** 3-3/src/config.h.in	2002-11-14 02:24:32.000000000 +0100
--- 3-3.dafire/src/config.h.in	2002-12-05 12:27:09.000000000 +0100
***************
*** 290,295 ****
--- 290,299 ----
   */
  @cdef_use_alists@ USE_ALISTS
  
+ /* Define this if you want MCCP (Mud Control Compression Protocol).
+  */
+ @cdef_use_mccp@ USE_MCCP
+ 
  /* Define this if you want PCRE instead of traditional regexps.
   */
  @cdef_use_pcre@ USE_PCRE
diff -crN 3-3/src/func_spec 3-3.dafire/src/func_spec
*** 3-3/src/func_spec	2002-12-03 08:26:07.000000000 +0100
--- 3-3.dafire/src/func_spec	2002-12-05 12:27:09.000000000 +0100
***************
*** 508,513 ****
--- 508,519 ----
  void    set_combine_charset(int *|string);
  void    set_connection_charset(int *|string, int default: F_CONST1);
  mixed   set_prompt(string|closure|int, object default: F_THIS_PLAYER);
+ #ifdef USE_MCCP
+ mixed   query_mccp(object default: F_THIS_PLAYER);
+ int    *query_mccp_stats(object default: F_THIS_PLAYER);
+ int     start_mccp_compress(int);
+ int     end_mccp_compress();
+ #endif
  
  void    write(mixed);
  object *users();
diff -crN 3-3/src/lex.c 3-3.dafire/src/lex.c
*** 3-3/src/lex.c	2002-11-30 08:29:53.000000000 +0100
--- 3-3.dafire/src/lex.c	2002-12-05 12:27:09.000000000 +0100
***************
*** 792,797 ****
--- 792,800 ----
  #ifdef USE_MYSQL
      add_permanent_define("__MYSQL__", -1, string_copy("1"), MY_FALSE);
  #endif
+ #ifdef USE_MCCP
+     add_permanent_define("__MCCP__", -1, string_copy("1"), MY_FALSE);
+ #endif
  #ifdef USE_ALISTS
      add_permanent_define("__ALISTS__", -1, string_copy("1"), MY_FALSE);
  #endif
diff -crN 3-3/src/main.c 3-3.dafire/src/main.c
*** 3-3/src/main.c	2002-12-05 12:25:54.000000000 +0100
--- 3-3.dafire/src/main.c	2002-12-05 12:27:09.000000000 +0100
***************
*** 1493,1498 ****
--- 1493,1504 ----
    fputs("           IPv6: supported.\n", stdout);
  #endif
  
+ #ifndef USE_MCCP
+   fputs("           MCCP: not supported.\n", stdout);
+ #else
+   fputs("           MCCP: supported.\n", stdout);
+ #endif
+   
  #ifndef USE_MYSQL
    fputs("          mySQL: not supported.\n", stdout);
  #else
