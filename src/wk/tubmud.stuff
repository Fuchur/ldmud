Im Gegensatz zu meiner ersten Aussage ergab naemlich ein Check, dass gewisse
grundlegende Mudlibfiles von Tub noch parse_command() benutzen, und die wollen
erstmal umgeschrieben werden ... ansonsten buggt jeder look-Befehl.


Dann noch ein paar Anmerkungen zum letzten Treiberpaket
- Bei der clonep()-manpage ist noch ein Fehler drin. Durch die
  unterschiedlichen Treiber-Modi bedingt, muesste das Beispiel genaugenommen
  so heissen:

  #if __COMPAT_MODE__

    o = clone_object("std/thing");
    write(clonep(o));                   --> writes "std/thing"

  #else  // __NATIVE_MODE__

    o = clone_object("/std/thing");
    write(clonep(o));                   --> writes "/std/thing"

  #endif

  Man beachte den Unterschied mit '/' am Anfang bzw. eben nicht. Aehnliches
  ist in noch mehr manpages zu finden.




SYNOPSIS
        varargs mixed apply_function(mixed func, mixed arg, ...);

DESCRIPTION
        apply_function() is a version of apply() which additionally to
        closures can call lfuns in objects.

        func can take the following forms:
        - closure (then the behaviour is the same as of apply())
        - a string (then this is interpreted as a function name in the
          calling object and the function is called via call_other())
        - array where the first element is an object or a file name of
          an object, the second element is a function name and the
          remaining elements (if any) are passed to the lfun as
          arguments via call_other().

        Any other form of func results in no call to any function and
        func is returned as result.

        If a function is called then all additional arguments given to
        apply_function() are passed to this function. If the last argument
        to apply_function() was an array then all its elements are passed
        as arguments to the function.

SEE ALSO
        apply(E), call_other(E)

==> Better implement the 'args...' expansion?


#if 0 ==> Some look quite special to me

SYNOPSIS
        varargs int find_element(mixed m,closure c,int i,mixed extra);
        varargs int find_last_element(mixed m,closure c,int i,mixed extra);
        varargs mixed find_extreme(mixed *m,closure c,mixed extra);
        varargs mixed find_map_extreme(mixed *m,closure_map,closure c,
                                       mixed extra);
        varargs mixed *sort_map_array(mixed *arr,
                                      (closure map |
                                       string map_lfun,object map_ob),
                                      (closure sort |
                                       string sort_lfun,object sort_ob)
                                      [,extra_args]);


DESCRIPTION
        A collection of useful simul_efuns concerning arrays are described
        here.

        object *object_array(string *arr);
          loads all object that are given as filenames in arr and returns
          the array of objects.

        varargs int find_element(mixed m,closure c,int i,mixed extra);
          returns the index of the first element which's index is greater
          than or equal to i, for which the closure, applied to it with the
          given extra-arguments, returns true.
          If it returns false for all elements with an index greater than
          or equal to i, -1 is returned.

        varargs int find_last_element(mixed m,closure c,int i,mixed extra);
          returns the index of the last element which's index is less than
          i, for which the closure, applied to it with the given extra-
          arguments, returns true. If i is not given or 0, it defaults to the
          size of the array (and all elements from the last on are checked).
          If it returns false for all elements with an index less than i,
          -1 is returned.

        varargs mixed find_extreme(mixed *m,closure c,mixed extra);
          applies the closure to pairs of the array (the extra arguments are
          passed as third to last argument) and keeps the first if the closure
          returns true, otherwise the second. If the array contains exactly
          one element, this element is returned and the closure is never
          applied. If the array contains no argument, an error is raised.
          After applying the closure to all elements one time, the result
          is returned.
          With this function the extreme can be found. Usually #'> or #'<
          are given as closure to find the maximum or the minimum.
          Example:
            find_extreme(({ 5,2,6,3,10 }),#'>) will return 10 because 10
            is the greatest number in the given array.

        varargs mixed find_map_extreme(mixed m,closure map,closure c,
                                       mixed extra);
          does the same as find_extreme(), but before it compares two
          elements using the compare-closure c, it applies the map-closure
          map to both elements. The original value (before applying the
          map-closure) is returned.
          Example:
            find_map_extreme(({ "bla","bloh","blu","b" }),#'strlen,#'>)
            will return "bloh" because "bloh" is the longest string in
            the given array.

        varargs mixed *sort_map_array(mixed *arr,
                                      (closure map |
                                       string map_lfun,object map_ob),
                                      (closure sort |
                                       string sort_lfun,object sort_ob)
                                      [,mixed *extra_args]);
          returns the given array in a sorted way. The array will
          first be mapped over the given map function (here the extra
          arguments will be applied, if given; if not given they will
          default to the empty array; give ({ 0 }) if you want to give
          a 0 explicitly). Then the original array (not the map
          result!) will be sorted after the given sort function which
          will be applied to the map result to find out which of two
          elements of the original array is the greater one. The
          result of this sorting will be returned. The result of the
          map will be ignored:
          return sort_map_array(({ ({ 5,3,2 }),({}),({ 1 }) }),
                                (#'sizeof),(#'>));
          /* this will return ({ ({}),({ 1 }),({ 5,3,2 }) }), namely the
           * elements of the given array sorted after their result of
           * the function sizeof().
           */

SEE ALSO
        arrays(LPC), map_array(EFUN), filter_array(EFUN)

#endif
