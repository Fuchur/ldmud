Short: MCCP patch :)
From:   "Bastian Hoyer" <dafire@dafire.de>
Date:   Thu Oct 11 21:02:00 2001
Type: Patch
State: New
----------


Also .. ich hab den patch gleich fuer die 3-3-111 gemacht :)

Hier eine Beschreibung was ich geaendert hab:

1. Das schreiben des zlib-stream geht ueber ein extra write in
add_message:) das koennte man vielleicht umschreiben das das ueber die
normale ausgabe geht :)

2. 3 neue variablen in der interactive_t struct ( der zlib_stream, ein
puffer und welche mccp version verwendet wird)

3. in new_player wird dem client gesagt das wir compress 2 oder 1 wollen
(send_will)

4. die telopts werden statt in den hook in eine neue funktion umgeleitet
und da bearbeitet

5. bei mccp verbindungen geht binary_message immer ueber add_message

6. neue efun query_mccp(object) (default this_player) gibt 0 wenn kein
mccp laeuft, ansonsten TELOPT_COMPRESS oder TELOPT_COMPRESS2

--- And on 13.10.2001 Bastian wrote about the new patch:

ich hab jetzt in der add_message funktion den patch so umgebaut das er mit 
compression praktisch genauso schreibt wie ohne.. also ich verwende auch die 
6 retry schleife :)

Ausserdem hab ich ein paar Sicherungen ausgebaut, weil ich davon ausgehen 
kann, das der message puffer von 1024 bytes immer in den zlib buffer von 8192 
bytes passt :)

Was noch fehlt ist ein erkennen der zlib im configure.. mal sehen ob ich das 
hinbekomme :)

------------------------------------------------------------------
diff -r -c3 3-3/src/comm.c 3-3.daf/src/comm.c
*** 3-3/src/comm.c	Sat Oct 13 20:57:28 2001
--- 3-3.daf/src/comm.c	Sat Oct 13 21:29:39 2001
***************
*** 408,413 ****
--- 408,416 ----
  
  /* Forward declarations */
  
+ static int start_compress(interactive_t *,unsigned char telopt);
+ static void mccp_telnet_neg(int);
+ 
  static void free_input_to(input_to_t *);
  static void telnet_neg(interactive_t *);
  static void send_will(int);
***************
*** 1466,1485 ****
           * If it is enough, send it, else terminate the outer loop
           * (because *source must be exhausted for this to happen).
           */
          chunk = dest - ip->message_buf;
          if (chunk < min_length)
          {
              break;
          }
  
!         /* Write .message_buf[] to the network. */
! 
          for (retries = 6;;) {
! 
!             if ((n = (int)socket_write(ip->socket, ip->message_buf, (size_t)chunk)) != -1)
!             {
                  break;
!             }
              switch (errno) {
                case EINTR:
                  if (--retries)
--- 1469,1525 ----
           * If it is enough, send it, else terminate the outer loop
           * (because *source must be exhausted for this to happen).
           */
+ 
          chunk = dest - ip->message_buf;
          if (chunk < min_length)
          {
              break;
          }
+         
+         
+         if (ip->out_compress)
+         {
+            
+            ip->out_compress->next_in = (unsigned char *) ip->message_buf;
+            ip->out_compress->avail_in = chunk;
+            
+            ip->out_compress->avail_out = COMPRESS_BUF_SIZE -
+                                          (ip->out_compress->next_out -
+                                           ip->out_compress_buf);
+            
+            {
+               int status = deflate(ip->out_compress, Z_SYNC_FLUSH);
+               
+               if (status != Z_OK)
+                  return;
+            }
+ 
+            /* ok.. perhaps i should take care that all data in message_buf
+               is compressed, but i guess there is no chance that 1024 byte compressed
+               won't fit into the 8192 byte buffer */
+            
+            length = ip->out_compress->next_out - ip->out_compress_buf;
+         }
  
!         /* now sending the buffer... */
!         
          for (retries = 6;;) {
!            
!            if (!ip->out_compress) /* here we choose the correct buffer */
!            {
!               if ((n = (int)socket_write(ip->socket, ip->message_buf, (size_t)chunk)) != -1)
!               {
                  break;
!               }
!            }
!            else
!            {
!               if ((n = (int)socket_write(ip->socket, ip->out_compress_buf, (size_t)length)) != -1)
!               {
!                  break;
!               }
!            }
!            
              switch (errno) {
                case EINTR:
                  if (--retries)
***************
*** 1539,1548 ****
          inet_packets++;
          inet_volume += n;
  #endif
-         if (n != chunk)
-             fprintf(stderr, "%s write socket: wrote %ld, should be %ld.\n"
-                           , time_stamp(), (long)n, (long)chunk);
  
          /* Continue with the processing of source */
          dest = &ip->message_buf[0];
      } while (srclen != 0);
--- 1579,1600 ----
          inet_packets++;
          inet_volume += n;
  #endif
  
+         if (ip->out_compress)
+         {
+            /* we update the compressed buffer here */
+            ip->out_compress->next_out = ip->out_compress_buf + length - n;
+            if (n != length)
+               fprintf(stderr, "%s write socket (compressed): wrote %ld, should be %ld.\n"
+                       , time_stamp(), (long)n, (long)chunk);
+         }
+         else
+         {  
+            if (n != chunk)
+               fprintf(stderr, "%s write socket: wrote %ld, should be %ld.\n"
+                       , time_stamp(), (long)n, (long)chunk);
+         }
+         
          /* Continue with the processing of source */
          dest = &ip->message_buf[0];
      } while (srclen != 0);
***************
*** 2875,2880 ****
--- 2927,2934 ----
  
      /* Initialize the rest of the interactive structure */
  
+     new_interactive->compressing = 0;
+     new_interactive->out_compress = NULL;
      new_interactive->input_to = NULL;
      put_ref_string(&new_interactive->prompt, STR_DEFAULT_PROMPT);
      new_interactive->modify_command = NULL;
***************
*** 2963,2970 ****
--- 3017,3029 ----
      (void) lookup_ip_entry(new_interactive->addr.sin_addr, MY_TRUE);
      /* TODO: We could pass the retrieved hostname right to login */
  #endif
+ 
+     send_will(TELOPT_COMPRESS2);
+     send_will(TELOPT_COMPRESS);
+     
      logon(ob);
      flush_all_player_mess();
+ 
  } /* new_player() */
  
  /*-------------------------------------------------------------------------*/
***************
*** 3904,3910 ****
      }
  } /* reply_h_telnet_neg() */
  
! /*-------------------------------------------------------------------------*/
  void
  init_telopts (void)
  
--- 3963,3971 ----
      }
  } /* reply_h_telnet_neg() */
  
! /*-
! 
!   -----------------------------------------------------------------------*/
  void
  init_telopts (void)
  
***************
*** 3989,4003 ****
  
      /* Mud specific protocols */
  
!     telopts_do[TELOPT_COMPRESS] = reply_h_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS] = reply_h_telnet_neg;
!     telopts_will[TELOPT_COMPRESS] = reply_h_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS] = reply_h_telnet_neg;
! 
!     telopts_do[TELOPT_COMPRESS2] = reply_h_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS2] = reply_h_telnet_neg;
!     telopts_will[TELOPT_COMPRESS2] = reply_h_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS2] = reply_h_telnet_neg;
  
      telopts_do[TELOPT_MSP] = reply_h_telnet_neg;
      telopts_dont[TELOPT_MSP] = reply_h_telnet_neg;
--- 4050,4064 ----
  
      /* Mud specific protocols */
  
!     telopts_do[TELOPT_COMPRESS] = mccp_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS] = mccp_telnet_neg;
!     telopts_will[TELOPT_COMPRESS] = mccp_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS] = mccp_telnet_neg;
! 
!     telopts_do[TELOPT_COMPRESS2] = mccp_telnet_neg;
!     telopts_dont[TELOPT_COMPRESS2] = mccp_telnet_neg;
!     telopts_will[TELOPT_COMPRESS2] = mccp_telnet_neg;
!     telopts_wont[TELOPT_COMPRESS2] = mccp_telnet_neg;
  
      telopts_do[TELOPT_MSP] = reply_h_telnet_neg;
      telopts_dont[TELOPT_MSP] = reply_h_telnet_neg;
***************
*** 5661,5666 ****
--- 5722,5731 ----
   * codes for colours and other things needs to bypass the allowed
   * charset filters, but isn't important enough to waste bandwith
   * on a synchronous transmission.
+  *
+  * If the client uses MCCP compression add_message ist always used
+  * with flushing buffer _after_ the Message.
+  *
   */
  
  {
***************
*** 5708,5714 ****
          save_command_giver = command_giver;
          command_giver = current_object;
  
!         if (sp->u.number & 1)
          {
              /* Write before flush... */
  
--- 5773,5779 ----
          save_command_giver = command_giver;
          command_giver = current_object;
  
!         if ((sp->u.number & 1)||ip->out_compress)
          {
              /* Write before flush... */
  
***************
*** 5718,5724 ****
  
              sending_telnet_command = MY_FALSE;
  
!             if (sp->u.number & 2)
                  add_message(message_flush);
              wrote = 0;
          }
--- 5783,5789 ----
  
              sending_telnet_command = MY_FALSE;
  
!             if ((sp->u.number & 2)||ip->out_compress)
                  add_message(message_flush);
              wrote = 0;
          }
***************
*** 6515,6518 ****
--- 6580,6790 ----
  } /* f_query_udp_port() */
  
  /***************************************************************************/
+ 
+ static void
+ mccp_telnet_neg (int option)
+ 
+ {
+     interactive_t *ip = O_GET_INTERACTIVE(command_giver);
+ 
+     switch(ip->tn_state) {
+      case TS_DO:
+        start_compress(ip,option);
+        break;
+      default:
+        printf("MCCP NEG (%d) STATE (%d)\n",option,ip->tn_state);
+     }
+ }
+ 
+ 
+ svalue_t *
+ f_query_mccp (svalue_t *sp)
+ 
+ /* EFUN query_mccp()
+  *
+  *       mixed query_mccp(object ob)
+  *
+  * this efun returns 0 if no mccp is used for interactive ob.
+  * if ob|this_player uses mccp it returns TELOPT_COMPRESS or
+  * TELOPT_COMPRESS2
+  */
+ 
+ {
+     interactive_t *ip;
+ 
+     /* Make sure the object is interactive */
+     if (!(O_SET_INTERACTIVE(ip, sp->u.ob))
+      || ip->closing)
+     {
+         error("Bad arg 1 to query_mccp(): object not interactive.\n");
+         return sp;
+     }
+ 
+     free_svalue(sp);
+     put_number(sp,ip->compressing);
+ 
+     return sp;
+ } /* query_mccp() */
+ 
+ 
+ 
+ /*
+  * mccp.c - support functions for the Mud Client Compression Protocol
+  *
+  * see http://www.randomly.org/projects/MCCP/
+  *
+  * Copyright (c) 1999, Oliver Jowett <oliver@randomly.org>
+  *
+  * This code may be freely distributed and used if this copyright
+  * notice is retained intact.
+  */
+ 
+ 
+ 
+ void *zlib_alloc(void *opaque, unsigned int items, unsigned int size)
+ {
+   return calloc(items, size);
+ }
+ 
+ void zlib_free(void *opaque, void *address)
+ {
+   free(address);
+ }
+ 
+ 
+ static int start_compress(interactive_t *ip, unsigned char telopt )
+ {
+   z_stream *s;
+ 
+   /* already compressing */
+   if (ip->out_compress)
+     return 1;
+ 
+   /* allocate and init stream, buffer */
+   s = (z_stream *) malloc(sizeof(*s));
+   ip->out_compress_buf = (unsigned char *) malloc(COMPRESS_BUF_SIZE);
+ 
+   s->next_in    =  NULL;
+   s->avail_in   =  0;
+   s->next_out   =  ip->out_compress_buf;
+   s->avail_out  =  COMPRESS_BUF_SIZE;
+   s->zalloc     =  zlib_alloc;
+   s->zfree      =  zlib_free;
+   s->opaque     =  NULL;
+ 
+   if (deflateInit(s, 9) != Z_OK)
+   {
+     free(ip->out_compress_buf);
+     free(s);
+     return 0;
+   }
+ 
+   /* version 1 or 2 support */
+   if (telopt == TELOPT_COMPRESS)
+   {
+      DTF(("%s TDEBUG: send IAC SB %02x WILL SE\n", time_stamp(), telopt));
+      SEND_TELNET_COMMAND(
+             add_message("%c", IAC);
+             add_message("%c%c%c%c", SB, telopt, WILL, SE);
+             add_message(message_flush);
+             );
+   }
+   else if (telopt == TELOPT_COMPRESS2)
+   {
+      DTF(("%s TDEBUG: send IAC SB %02x WILL SE\n", time_stamp(), telopt));
+      SEND_TELNET_COMMAND(
+             add_message("%c", IAC);
+             add_message("%c%c%c%c", SB, telopt, IAC, SE);
+             add_message(message_flush);
+             );
+   }
+   else
+   {
+     printf("Bad teleoption %d passed", telopt);
+     free(ip->out_compress_buf);
+     free(s);
+     return 0;
+   }
+   
+   ip->compressing = telopt; 
+   ip->out_compress = s;
+ 
+   /* success */
+   return 1;
+ }
+ 
+ /*
+   beenden des compressed zeugs wird noch nicht unterstuetzt :)
+   also ist der rest des files erst mal ueberfluessig :)
+ */
+ 
+ /* Try to send any pending compressed-but-not-sent data in `desc' */
+ int process_compressed(interactive_t *ip)
+ {
+   int iStart, nBlock, nWrite, len;
+ 
+   if (!ip->out_compress)
+     return 1;
+     
+   len = ip->out_compress->next_out - ip->out_compress_buf;
+   if (len > 0)
+   {
+     for (iStart = 0; iStart < len; iStart += nWrite)
+     {
+       nBlock = UMIN (len - iStart, 4096);
+       if ((nWrite = write(ip->socket, ip->out_compress_buf + iStart, nBlock)) < 0)
+       {
+         if (errno == EAGAIN || errno == ENOSR)
+           break;
+ 
+           /* write error */
+         return 0;
+       }
+       if (nWrite <= 0)
+         break;
+     }
+ 
+     if (iStart)
+     {
+       if (iStart < len)
+         memmove(ip->out_compress_buf, ip->out_compress_buf+iStart, len - iStart);
+ 
+       ip->out_compress->next_out = ip->out_compress_buf + len - iStart;
+     }
+   }
+ 
+   /* success */
+   return 1;
+ }
+ 
+ /* Cleanly shut down compression on `desc' */
+ int end_compress(interactive_t *ip)
+ {
+   unsigned char dummy[1];
+ 
+   if (!ip->out_compress)
+     return 1;
+ 
+   ip->out_compress->avail_in = 0;
+   ip->out_compress->next_in  = dummy;
+ 
+   /* No terminating signature is needed - receiver will get Z_STREAM_END */
+   if (deflate(ip->out_compress, Z_FINISH) != Z_STREAM_END)
+     return 0;
+ 
+     /* try to send any residual data */
+   if (!process_compressed(ip))
+     return 0;
+ 
+     /* reset compression values */
+   deflateEnd(ip->out_compress);
+   free(ip->out_compress_buf);
+   free(ip->out_compress);
+   ip->compressing      = 0;
+   ip->out_compress     = NULL;
+   ip->out_compress_buf = NULL;
+ 
+   /* success */
+   return 1;
+ }
  
diff -r -c3 3-3/src/comm.h 3-3.daf/src/comm.h
*** 3-3/src/comm.h	Sat Oct 13 20:57:14 2001
--- 3-3.daf/src/comm.h	Thu Oct 11 15:46:22 2001
***************
*** 4,9 ****
--- 4,10 ----
  #include "driver.h"
  #include "typedefs.h"
  #include <sys/types.h>
+ #include <zlib.h>
  
  #include "simulate.h"   /* callback_t for input_to_t */
  #include "svalue.h"
***************
*** 167,172 ****
--- 168,178 ----
  
      char message_buf[MAX_SOCKET_PACKET_SIZE];
        /* The send buffer. */
+ 
+    unsigned char   compressing;                 /* MCCP support */
+    z_stream      * out_compress;                /* MCCP support */
+    unsigned char * out_compress_buf;            /* MCCP support */
+    
  };
  
  /* --- Bitflags and masks for interactive.noecho ---
***************
*** 315,319 ****
--- 321,328 ----
  #if defined(ACCESS_CONTROL)
  extern void refresh_access_data(void (*add_entry)(struct sockaddr_in *, int, long*) );
  #endif /* ACCESS_CONTROL */
+ 
+ #define COMPRESS_BUF_SIZE 8192
+ #define UMIN(a,b) ((a) < (b) ? (a) : (b))
  
  #endif /* COMM_H__ */
diff -r -c3 3-3/src/func_spec 3-3.daf/src/func_spec
*** 3-3/src/func_spec	Sat Oct 13 20:57:28 2001
--- 3-3.daf/src/func_spec	Sat Oct 13 18:05:43 2001
***************
*** 471,476 ****
--- 471,477 ----
  void    set_combine_charset(int *|string);
  void    set_connection_charset(int *|string, int default: F_CONST1);
  mixed   set_prompt(string|closure|int, object default: F_THIS_PLAYER);
+ mixed   query_mccp(null|object default: F_THIS_PLAYER);
  
  void    write(mixed);
  object *users();
------------------------------------------------------------------
