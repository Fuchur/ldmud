Short: Patches from Finalfrontier
From: Stefan Riemer <Barbara.Riemer@t-online.de>
Date: 990204
Type: Patch
State: Unclassified

Deleted is all text pertaining to already implemented features.
-------------------------------------------------------------------------

ich hab mal in einem Anflug von Wahnsinn versucht, die Aenderungen, die
DanS@FF an den Sourcen bis zur 3.2.1@141 gemacht hat, auf die 3.2.5 zu
uebertragen. Ich hatte das Changelog vom FF-Driver bei Dir im wk-Verzeichnis
gefunden und das hat mich auf die Idee gebracht. Da ich das ganze auf ner
NT-Machine unter der Cygwin-Umgebung mache, sind gleich noch ein paar
Patches dafuer rausgekommen.

Ok, falls es interessant ist und Du was einbauen willst, muesstest du
allerdings DanS fragen, da der Code nicht von mir ist.
Soweit es die Cygwin-Sachen betrifft: viel Spass damit.
Das Define dafuer heisst uebrigens __CYGWIN__, nicht mehr __CYGWIN32__.

Tschau sagt Stefan (Peng@FinalFrontier)


Subject: Changelog LPmud driver FF
From: Daniel Schild <schild@tsa.de>
Date: Wed, 11 Nov 1998 13:56:53 +0100
Organization: Teleport Sachsen-Anhalt GmbH / RegioCom GmbH
X-Mailer: Mozilla 4.06 [en] (X11; I; Linux 2.0.35 i686)

This is a multi-part message in MIME format.
--------------0D6CD2B6E5EB4A8EE4326A26
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

viel spass beim lesen. weiss selber kaum noch, was da drin steht. wenn
irgendwer den mist gebrauchen kann sach bescheid

--
Daniel Schild
Dienst- und Applikationsentwicklung
Teleport Sachsen-Anhalt GmbH | RegioCom GmbH
Tel:    ++49 39203 8 2030    | ++49 39203 8 3300
Fax:    ++49 39203 8 2031    | ++49 39203 8 3399
E-Mail: schild@tsa.de        | schild@regiocom.net
S-Mail: Steinfeldstr. 3, 39179 Barleben, Germany
--------------0D6CD2B6E5EB4A8EE4326A26
Content-Type: text/plain; charset=us-ascii; name="Changelog%"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline; filename="Changelog%"

Sat Jul  6 16:35:44 MET DST 1996 (schild@hppool.cs.uni-magdeburg.de (DanS))
	* version 3.2.1@129%1
	* introduced:
	  . ANSI and K&R prototypes
	  . ANSI and K&R function definitions
	  . added defines - undefining EFuns or other functionality
	    now causes not only the removal of the functionality itself,
	    it will remove some unused lines of code too
	  . HP-UX special fixes and optimizations
	* features:
	  . the driver now handles the most recent signals and fatals
	    by calling a function in the master object (default "crash")
	    default signal for offline-reload of the master object: SIGUSR1
	    definitions in: signal_handler.h; signal_handler.h and config.h
	  . introduced EFun 'reload_object'. This function resets the specified
	    object without reloading it from the source.
	    definitions in: object.c config.h
	    The idea and some lines of source are taken from the MudOS
	    development project
	  . introduced EFun int set_eval_cost(int a).
	    return types and actions:
	       a == 0 - reset the maximum number of evaluation nodes per loop
	       a < 0  - return the maximum number of evaluation nodes per loop
	       a > 0  - set the maximum number of evaluation nodes per loop to a
	    The idea and most lines of source are taken from the MudOS
	    development project.
	  . introduced EFun int get_eval_time(). This EFun returns the number of
	    miliseconds since the start of the current evaluation loop.
	  . The driver process now dumps its process ID into a file called
	    'driver_pid' inside the directory where the driver is installed
	  . extended EFun mixed debug_info (int flag, object obj):
	       flag == 5 - returns the size of obj in memory
	       flag == 6 - returns the time obj was last referenced
	       flag == 7 - returns obj's reference count
	       flag == 8 - returns true if obj is swapped
	* changed init_telopts() in comm1.c to execute only one loop and
	  to include telnet_neg.h for default negotiation settings
	* disabled EFun slice_array() and combine_free_list() in func_spez
	* disabled buildin-command 'malloc' for interactives without
	  O_IS_WIZARD set

Mon Jul  8 12:24:01 MET DST 1996 (schild@hppool.cs.uni-magdeburg.de (DanS))
	* version 3.2.1@130%2
	* fixed bug in new varargs handling so that calls to local funtions
	  work as expected.
	* strict type checking for arguments to funtions is now disabled if you
	  use either the varargs '...' operator or the array expand operator.
	  The user has to check the type himself. (This is, because we don't
	  know the array contents during compile time a.s.o.)

Sat Jul 13 13:42:10 MET DST 1996 (schild@hppool.cs.uni-magdeburg.de (DanS))
	* version 3.2.1@130%3
	* added instrs.h to 'clean' rule in Makefile.in
	  (thanks to Freaky@UNItopia aka freaky@rus.uni-stuttgart.de)
	* fixed some minor things
	  (thanks to Freaky@UNItopia aka freaky@rus.uni-stuttgart.de)
	* checked the differnces between version 3.2.1@130 and this version
	* removed some useless changes
	* enhanced the signal handling package to use the closure hook H_CRASH
	  which maybe either a string with the name of the function to call
	  in the master object or a closure with up to 3 arguments:
	    H_CRASH == T_STRING:
	      call the function named by H_CRASH with 3 arguments:
	        1. argument: a string containing the reason why the driver
		   goes down
		2. argument: type object; will contain the command giver
		   for the current execution or 0 if none
		3. argument: type object; will contain the current object
		   or 0 if none
	    H_CRASH == T_CLOSURE:
	      call the closure with up to 3 arguments. Arguments and types are
	      as specified above. If the number of arguments is less than 3
	      the list will be truncated.
	  default type for the hook is T_STRING; default value is "crash"
	* introduced a new behaviour to call "reset" in objects
	  (reset as in native mode):
	  This is activated by the #define RESET_IF_SWAPPED inside config.h
	  default value for RESET_IF_SWAPPED is 0
	  If RESET_IF_SWAPPED equals:
	    0 : this is the old behaviour;
	        the driver will not reset objects swapped out
	    1 : the driver will reset objects even if they are swapped out
	    -1: the driver will only reset swapped objects if they have
	        the O_RESET_IF_SWAPPED bit set. This bit will be set during
		the creation phase of the object using the driver hook
		H_RESET_IF_SWAPPED which maybe either a closure or a string.
		if the type of H_RESET_IF_SWAPPED equals:
		  T_STRING
		    the driver will call the function namend by the hook inside
		    the object. Remember - this is done once during creation time
		  T_CLOSURE
		    the driver will call the closure
		If the hook returns 0 no reset will be called if the object is
		swapped. A value other than 0 will result in calling reset
		for this object even if it is swapped out.
	  default type for the hook is T_STRING; default value is
	  "reset_if_swapped"
	  (thanks to Freaky@UNItopia aka freaky@rus.uni-stuttgart.de for a
	  little :) discussion about that)
	* added code for for EFun get_num_args() wich returns the number of
	  arguments which the current function got. This only works if you
	  assign the return value of get_num_args() to a local variable.
	  (thanks to Freaky@UNItopia aka freaky@rus.uni-stuttgart.de for
	  the idea)
	* removed some useless changes
	* changed 'configure' to look for full availibility of 'struct rusage'
	  and if the system/user members of 'struct rusage' have a tv_usec member
	  even if getrusage is simulated via syscall

Sat Jul 13 15:45:48 MET DST 1996 (schild@hppool.cs.uni-magdeburg.de (DanS))
	* version 3.2.1@130%4
	* introduced flag O_WILL_RESET. This flag will be set during the
	  creation phase of the object to determine, if there is a function
	  defined by H_RESET. If H_RESET is a closure every object will get
	  O_WILL_RESET. H_RESET will be called only in objects with O_WILL_RESET
	  set.
	* enhanced the swapping mechanism to do lazy swapping. This is activated
	  by defining LAZY_SWAP in config.h.
	  If lazy swapping is enabled, the look_for_objects_to_swap function
	  in backend.c just fills a FIFO. That FIFO is then emptied during
	  the next loops, prozessing LAZY_SWAP objects each loop.
	* merged in the Multiport package GDMulti-130 with minor changes.
	  See README.Multiport for details.
	* added permanent defines TRUE_VARARGS, EXPAND_ARRAY, XTENDED_DEBUG_INFO
	  and RESET_IF_SWAPPED (has the same value as defined in config.h; if
	  RESET_IF_SWAPPED in config.h equals 0 RESET_IF_SWAPPED is not defined)
	
Sat Nov 16 17:17:33 MET 1996 (schild@hppool.cs.uni-magdeburg.de (DanS))
	* version 3.2.1@134%4
	* merged in the changes in the official driver distribution
	  (
	  diff3.2.1@130-131; release date: Sat Aug 10 19:16:25 MET DST 1996
	    New email addresses.
	    Fixed code that wouldn't compile with old K&R compiler.
	    Removed remains of combine_free_list().
	    store_case_labels(): avoid overflow when calculating gain from a
	    table with large span.
	  diff3.2.1@131-132; release date: Sat Sep 21 21:48:41 MET DST 1996
	    Variadic function suport.
	    Fixed bug in find_living_object() .
	  diff3.2.1@132-133; release date: Sat Sep 28 00:12:52 MET DST 1996
	    get_message(), erq.c:main(), start_subserver(): check for interrupted
	    select.
	    prolang.y, function_call: set return type to TYPE_ANY for
	    unknown efun.
	  diff3.2.1@133-134; release date: Sat Oct 19 23:25:05 MET 1996
	    regreplace fixes from Marcus.
	    sprintf.c: check for out of memory conditions.
	    Fixes for sizeof(char *) != sizeof(int)
	    Latest amiga diffs.
	  )
	* removed the selfmade varargs handling (still alpha code) due to
	  the variadic function support introduced in 3.2.1@132

Sat Nov 30 21:31:28 MET 1996 (schild@hppool.cs.uni-magdeburg.de (DanS))
	* version 3.2.1@135%5
	* merged in the changes in the official driver distribution
	  (
	  diff3.2.1@134-135; release date: Sat Nov 30 04:24:48 MET 1996
	    Fixes to compile on BSDI 2.0.1 / 2.1 .
	    Another regreplace bugfix.
	    regcomp(): fixed memory leak (patch by Marcus)
            port.h: use __STDC__, not __STDC .
            svalue_size(), case T_CLOSURE, ! MALLOC_smalloc: fixed infinite loop.
            64 bit fixes.
            setup_new_frame2(): when there it an error, pass funstart as pc.
          )
	* added startup functionality for super user privileges:
		- the driver may set the systems hard limit for the maximum
		  number of open files.
		- the driver may lock its text segment and its data segment into
		  memory to avoid being paged or swapped out.
	     	- after completion the driver process irreversibly falls back
		  to a non privileged user and group ID

Wed Apr  9 19:57:30 MET DST 1997 (schild@tsa.de (DanS))
	* version 3.2.1@136%5
	* merged in the changes in the official driver distribution
	  (
	  diff3.2.1@135-136; release date: Sat Nov 30 04:24:48 MET 1996
	    store_include_end(): when returning to the auto include string,
	    adjust stored_lines.
	    patches for GnuWin32 host.
	    64 bit fixes.
	  )

Thu Apr 10 03:30:10 MET DST 1997 (schild@tsa.de (DanS))
	* version 3.2.1@137%5
	* merged in the changes in the official driver distribution
	  (
	  AIX fixes.
	  README.3.2: amylaar-users list and driver archive have moved.
	  show_otable_status(): don't add objs_in_table * sizeof(struct object)
	  to result.
	  simulate.c: gcc >= 2.7 defines lstat prototype even on SunOS 4
	  status_parse(): add sentences to total;
	  define evaluation order of function calls.
	  Reduced MAX_LAMBDA_LEVELS to 32k.
	  !-escapes in charmode: Allow the same CR/LF combinations like for
	  ordinary
	  input. Echo immediately.
	  )
	
Wed Apr 23 19:44:28 MET DST 1997 (schild@tsa.de (DanS))
	* version 3.2.1@137%6a
	* enhanced the swapping mechanism to always swap the line number
	  information of all programm blocks directly after compilation

--------------0D6CD2B6E5EB4A8EE4326A26--

Index: Makefile.in
===================================================================
RCS file: /usr/src/cvs/ldmud/Makefile.in,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** Makefile.in	1998/12/30 20:17:25	3.2.5.1
--- Makefile.in	1998/12/31 11:39:42	3.2.5.2
***************
*** 86,90 ****

  install: driver
! 	$(INSTALL) -c $? $(BINDIR)/parse

  install-utils:
--- 86,90 ----

  install: driver
! 	$(INSTALL) -c $?@EXEEXT@ $(BINDIR)/parse@EXEEXT@

  install-utils:
***************
*** 95,100 ****

  parse: driver
! 	-$(MV) parse parse.old
! 	$(CP) driver parse

  lint: *.c
--- 95,100 ----

  parse: driver
! 	-$(MV) parse@EXEEXT@ parse.old
! 	$(CP) driver@EXEEXT@ parse@EXEEXT@

  lint: *.c
***************
*** 104,112 ****
  	$(RM) $(YACCTAB)h $(YACCTAB)c make_func.c *.o make_func@EXEEXT@
  	$(RM) efun_defs.c instrs.h lang.y lang.h lang.c y.output tags TAGS
! 	$(RM) parse core mudlib/core mudlib/debug.log lpmud.log driver
  	(cd util ; echo "Cleaning in util." ; $(MAKE) clean)

  distclean: clean
! 	$(RM) driver config.status machine.h Makefile

  tags: $(SRC)
--- 104,112 ----
  	$(RM) $(YACCTAB)h $(YACCTAB)c make_func.c *.o make_func@EXEEXT@
  	$(RM) efun_defs.c instrs.h lang.y lang.h lang.c y.output tags TAGS
! 	$(RM) parse@EXEEXT@ core mudlib/core mudlib/debug.log lpmud.log driver@EXEEXT@
  	(cd util ; echo "Cleaning in util." ; $(MAKE) clean)

  distclean: clean
! 	$(RM) driver@EXEEXT@ config.status machine.h Makefile

  tags: $(SRC)
Index: backend.c
===================================================================
RCS file: /usr/src/cvs/ldmud/backend.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** backend.c	1998/12/30 20:17:24	3.2.5.1
--- backend.c	1998/12/31 11:39:42	3.2.5.2
***************
*** 63,66 ****
--- 63,67 ----
  #include "mapping.h"
  #include "my-alloca.h"
+ #include "my-rusage.h"
  #include "object.h"
  #include "regexp.h"
***************
*** 127,130 ****
--- 128,134 ----
  int32 assigned_eval_cost; /* TODO: What is this? */

+ int32 eval_start_time;
+   /* The start time for running eval, used by get_eval_time */
+
  /* TODO: BOOL */ int extra_jobs_to_do = MY_FALSE;
    /* True: the backend has other things to do in this cycle than just
***************
*** 185,188 ****
--- 189,197 ----


+ #ifdef LAZY_SWAP
+ struct _swap_cache * swap_cache;
+ static struct _swap_cache * swap_cache_top;
+ #endif /* LAZY_SWAP */
+
  /* --- Forward declarations --- */

***************
*** 277,281 ****
--- 286,363 ----

  #endif
+ #ifdef LAZY_SWAP
+ static void
+ try_to_swap ()
+ {
+     int i;

+     for (i = LAZY_SWAP; i--; )
+     {
+       int time_since_ref;
+
+       if (!swap_cache->next && !swap_cache->ob)
+ 	    {
+ 	      if (swap_cache != swap_cache_top)
+ 	        fatal ("swap_cache_top does not point correctly to the top of the FIFO\n");
+ 	        return;
+ 	    }
+
+       time_since_ref = current_time - swap_cache->ob->time_of_ref;
+       if ((swap_cache->ob->flags & O_DESTRUCTED) ||
+ 	        (swap_cache->ob->flags & O_HEART_BEAT) ||
+ 	        (time_since_ref < time_to_swap) )
+ 	    {
+ 	      if (swap_cache->next)
+ 	      {
+ 	        struct _swap_cache * dummy = swap_cache->next;
+
+ 	        swap_cache->ob = NULL;
+ 	        swap_cache->next = NULL;
+ 	        xfree (swap_cache);
+ 	        swap_cache = dummy;
+ 	      }
+ 	      else
+ 	      {
+ 	        /* this is never touched; but we should have this */
+ 	        swap_cache->ob = NULL;
+ 	        return;
+ 	      }
+ 	
+ 	    continue;
+ 	    }
+
+       /* lets swap ... first try to swap variables */
+       if (time_since_ref >= time_to_swap_variables)
+ 	      if (!O_VAR_SWAPPED(swap_cache->ob))
+ 	      {
+ 	        if (d_flag)
+ 	          fprintf(stderr, "swap vars of %s\n", swap_cache->ob->name);
+ 	        swap_variables (swap_cache->ob);
+ 	      }
+         if (!O_PROG_SWAPPED(swap_cache->ob))
+ 	      {
+ 	        if (d_flag)
+ 	          fprintf(stderr, "swap %s\n", swap_cache->ob->name);
+ 	        swap_program (swap_cache->ob);
+ 	      }
+         if (swap_cache->next)
+ 	      {
+       	  struct _swap_cache * dummy = swap_cache->next;
+ 	
+ 	        swap_cache->ob = NULL;
+ 	        swap_cache->next = NULL;
+ 	        xfree (swap_cache);
+ 	        swap_cache = dummy;
+ 	      }
+         else
+ 	      {
+ 	        /* this is never touched; but we should have this */
+       	  swap_cache->ob = NULL;
+ 	        return;
+ 	      }
+     } /* for */
+ }
+ #endif /* LAZY_SWAP */
+
  /*-------------------------------------------------------------------------*/
  void
***************
*** 298,308 ****

      prepare_ipc();
!
      (void)signal(SIGHUP,  (RETSIGTYPE(*)PROT((int)))f_shutdown);
      (void)signal(SIGUSR1, (RETSIGTYPE(*)PROT((int)))startmasterupdate);
      if (!t_flag) {
          ALARM_HANDLER_FIRST_CALL(catch_alarm);
          call_heart_beat();
      }
  #ifdef AMIGA
      atexit(exit_alarm_timer);
--- 380,399 ----

      prepare_ipc();
! #ifndef NEW_SIGNAL_HANDLING
      (void)signal(SIGHUP,  (RETSIGTYPE(*)PROT((int)))f_shutdown);
      (void)signal(SIGUSR1, (RETSIGTYPE(*)PROT((int)))startmasterupdate);
+ #else
+     init_signal_handler();
+ #endif /* NEW_SIGNAL_HANDLING */
      if (!t_flag) {
          ALARM_HANDLER_FIRST_CALL(catch_alarm);
          call_heart_beat();
      }
+ #ifdef LAZY_SWAP
+     swap_cache = xalloc (sizeof (struct _swap_cache));
+     swap_cache->ob = NULL;
+     swap_cache->next = NULL;
+     swap_cache_top = swap_cache;
+ #endif /* LAZY_SWAP */
  #ifdef AMIGA
      atexit(exit_alarm_timer);
***************
*** 339,343 ****
--- 430,442 ----

          CLEAR_EVAL_COST;
+ 	{
+ 	  struct rusage rus;

+ 	  if (getrusage(RUSAGE_SELF, &rus) < 0)
+ 	    eval_start_time = 0;
+ 	  else
+ 	    eval_start_time = RUSAGE_TIME(rus.ru_utime) +
+ 	                      RUSAGE_TIME(rus.ru_stime);
+ 	}
          /* Execute pending deallocations */
  #ifdef C_ALLOCA
***************
*** 416,419 ****
--- 515,522 ----
           */

+ #ifdef LAZY_SWAP
+       	try_to_swap ();  /* lets try to swap something */
+ #endif /* LAZY_SWAP */
+
          if (get_message(buff))
          {
***************
*** 582,586 ****

          /* Check if a reset() is due. */
!         if (ob->next_reset < current_time && !(ob->flags & O_RESET_STATE)) {
              if (d_flag)
                  fprintf(stderr, "RESET %s\n", ob->name);
--- 685,698 ----

          /* Check if a reset() is due. */
!   	if ((ob->flags & O_WILL_RESET) && ob->next_reset < current_time
! #if RESET_IF_SWAPPED == 0
! 	      && !(ob->flags & O_RESET_STATE)
! #else
! #if RESET_IF_SWAPPED == -1
! 	      && (!(ob->flags & O_RESET_STATE) || (ob->flags & O_RESET_IF_SWAPPED))
! #endif /* RESET_IF_SWAPPED == -1 */
! #endif /* RESET_IF_SWAPPED == 0 */
! 	      )
! 	      {
              if (d_flag)
                  fprintf(stderr, "RESET %s\n", ob->name);
***************
*** 656,677 ****
           * out.
           */
!         if ((time_to_swap <= 0 && time_to_swap_variables <= 0)
!         ||  (ob->flags & O_HEART_BEAT))
!             continue;
!         if (time_since_ref >= time_to_swap_variables && time_to_swap_variables > 0) {
!             if (!O_VAR_SWAPPED(ob)) {
!                 if (d_flag)
!                     fprintf(stderr, "swap vars of %s\n", ob->name);
!                 swap_variables(ob);
!             }
!         }
!         if (time_since_ref >= time_to_swap && time_to_swap_variables > 0) {
!             if (!O_PROG_SWAPPED(ob)) {
!                 if (d_flag)
!                     fprintf(stderr, "swap %s\n", ob->name);
!                 swap_program(ob);
!             }
!         }
! #endif
      }
      error_recovery_pointer = error_recovery_info.last;
--- 768,798 ----
           * out.
           */
! 	if ((time_since_ref < time_to_swap) || (ob->flags & O_HEART_BEAT))
! 	    continue;
! #ifndef LAZY_SWAP
! 	if (time_since_ref >= time_to_swap_variables) {
! 	    if (!O_VAR_SWAPPED(ob)) {
! 		if (d_flag)
! 		    fprintf(stderr, "swap vars of %s\n", ob->name);
! 		swap_variables(ob);
! 	    }
! 	}
! 	if (!O_PROG_SWAPPED(ob)) {
! 	    if (d_flag)
! 		fprintf(stderr, "swap %s\n", ob->name);
! 	    swap_program(ob);	/* See if it is possible to swap out to disk */
! 	}
! #else
! 	if (((time_since_ref >= time_to_swap_variables) && !O_VAR_SWAPPED(ob)) ||
! 	    !O_PROG_SWAPPED(ob) )
! 	  {
! 	    swap_cache_top->ob = ob;
! 	    swap_cache_top->next = xalloc (sizeof (struct _swap_cache));
! 	    swap_cache_top->next->ob = NULL;
! 	    swap_cache_top->next->next = NULL;
! 	    swap_cache_top = swap_cache_top->next;
! 	  }
! #endif /* LAZY_SWAP */
! #endif /* TIME_TO_SWAP > 0 || TIME_TO_SWAP_VARIABLES > 0 */
      }
      error_recovery_pointer = error_recovery_info.last;
Index: config.h
===================================================================
RCS file: /usr/src/cvs/ldmud/config.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** config.h	1998/12/30 20:17:24	3.2.5.1
--- config.h	1998/12/31 11:39:42	3.2.5.2
***************
*** 2,5 ****
--- 2,110 ----
  #define __CONFIG_H__ 1

+ /* the driver now handles the most recent signals and fatals
+    by calling the driver hook H_CRASH, wich maybe either a string with the
+    name of the function to call in the master object or a closure with
+    up to 3 arguments:
+ 	    H_CRASH == T_STRING:
+ 	      call the function named by H_CRASH with 3 arguments:
+ 	        1. argument: a string containing the reason why the driver
+ 		   goes down
+ 		2. argument: type object; will contain the command giver
+ 		   for the current execution or 0 if none
+ 		3. argument: type object; will contain the current object
+ 		   or 0 if none
+ 	    H_CRASH == T_CLOSURE:
+ 	      call the closure with up to 3 arguments. Arguments and types are
+ 	      as specified above. If the number of arguments is less than 3
+ 	      the list will be truncated.
+    default type for the hook is T_STRING; default value is "crash"
+    default signal for offline-reload of the master object: SIGUSR1
+    define this if you want to include th new signal handling package */
+ #define NEW_SIGNAL_HANDLING
+
+ /* Include code for EFun 'reload_object'. This function resets the specified
+    object without reloading it from the source.
+    The idea and some lines of source are taken from the MudOS
+    development project*/
+ #define RELOAD_OBJECT
+
+ /* Include code for EFun int set_eval_cost(int a).
+    return types and actions:
+    a == 0 - reset the maximum number of evaluation nodes per loop
+    a < 0  - return the maximum number of evaluation nodes per loop
+    a > 0  - set the maximum number of evaluation nodes per loop to a
+    The idea and some lines of source are taken from the MudOS
+    development project. */
+ #define SET_EVAL_COST
+
+ /* Include code for EFun int get_eval_time(). This EFun returns the number of
+    miliseconds since the start of the current evaluation loop. */
+ #define GET_EVAL_TIME
+
+ /* Include code for the get_num_args EFun.
+    this efun returns the number of arguments for the current function.
+    This only works if you assign the return value of get_num_args()
+    to a local variable.*/
+ #define GET_NUM_ARGS
+
+ /* write the drivers process ID into a file called
+    'driver_pid' inside the directory where the driver is installed
+    (BIN_DIR in Makefile) */
+ #define WRITE_PID
+
+ /* If you define this the EFun mixed debug_info (int flag, object obj)
+    gets some additional features
+    flag == 5 - returns the size of obj in memory
+    flag == 6 - returns the time obj was last referenced
+    flag == 7 - returns obj's reference count
+    flag == 8 - returns true if obj is swapped */
+ #define XTENDED_DEBUG_INFO
+
+ /* default value for RESET_IF_SWAPPED is 0
+    If RESET_IF_SWAPPED equals:
+      0 :  this is the old behaviour;
+           the driver will not reset objects swapped out
+      1 :  the driver will reset objects even if they are swapped out
+      -1:  the driver will only reset swapped objects if they have
+           the O_RESET_IF_SWAPPED bit set. This bit will be set during
+ 	  the creation phase of the object using the driver hook
+ 	  H_RESET_IF_SWAPPED which maybe either a closure or a string.
+ 	  if the type of H_RESET_IF_SWAPPED equals:
+ 	    T_STRING
+ 	      the driver will call the function namend by the hook inside
+ 	      the object. Remember - this is done once during creation time
+ 	    T_CLOSURE
+ 	      the driver will call the closure
+ 	  If the hook returns 0 no reset will be called if the object is
+ 	  swapped. A value other than 0 will result in calling reset
+ 	  for this object even if it is swapped out. */
+ #define RESET_IF_SWAPPED -1
+
+ /* If lazy swapping is enabled, the look_for_objects_to_swap function
+    in backend.c just fills a FIFO. That FIFO is then emptied during
+    the next loops, prozessing LAZY_SWAP objects each loop. */
+ /* #define LAZY_SWAP 10 */
+ #undef LAZY_SWAP
+
  /* Should code for the external request demon be included?
   */
Index: configure
===================================================================
RCS file: /usr/src/cvs/ldmud/configure,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** configure	1998/12/30 20:17:24	3.2.5.1
--- configure	1998/12/31 11:39:43	3.2.5.2
***************
*** 2535,2552 ****
    CONFIG_SHELL='/bin/sh'
  fi
! if test "${OSTYPE}" = 'win32'; then
    EXEEXT='.exe'
-
- {
- test -n "$verbose" && \
- echo "	defining" HOST_INCLUDE to be \"hosts/GnuWin32/GnuWin32.h\"
- echo "#define" HOST_INCLUDE \"hosts/GnuWin32/GnuWin32.h\" >> confdefs.h
- DEFS="$DEFS -DHOST_INCLUDE=\"hosts/GnuWin32/GnuWin32.h\""
- SEDDEFS="${SEDDEFS}\${SEDdA}HOST_INCLUDE\${SEDdB}HOST_INCLUDE\${SEDdC}\"hosts/GnuWin32/GnuWin32.h\"\${SEDdD}
- \${SEDuA}HOST_INCLUDE\${SEDuB}HOST_INCLUDE\${SEDuC}\"hosts/GnuWin32/GnuWin32.h\"\${SEDuD}
- \${SEDeA}HOST_INCLUDE\${SEDeB}HOST_INCLUDE\${SEDeC}\"hosts/GnuWin32/GnuWin32.h\"\${SEDeD}
- "
- }
-
  fi

--- 2535,2540 ----
    CONFIG_SHELL='/bin/sh'
  fi
! if test "${OSTYPE}" = 'cygwin32'; then
    EXEEXT='.exe'
  fi

Index: datatypes.h
===================================================================
RCS file: /usr/src/cvs/ldmud/datatypes.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** datatypes.h	1998/12/30 20:17:25	3.2.5.1
--- datatypes.h	1998/12/31 11:39:43	3.2.5.2
***************
*** 241,243 ****
--- 241,250 ----
  #endif

+ #ifdef LAZY_SWAP
+ struct _swap_cache {
+   struct object * ob;
+   struct _swap_cache * next;
+ };
+ #endif /* LAZY_SWAP */
+
  #endif /* __DATATYPES_H__ */
Index: exec.h
===================================================================
RCS file: /usr/src/cvs/ldmud/exec.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** exec.h	1998/12/30 20:17:25	3.2.5.1
--- exec.h	1998/12/31 11:39:43	3.2.5.2
***************
*** 212,216 ****
--- 212,232 ----
  #define H_ERQ_STOP          15
  #define H_MODIFY_COMMAND_FNAME 16
+ #if defined(NEW_SIGNAL_HANDLING) && RESET_IF_SWAPPED == -1
+ #define H_CRASH           17
+ #define H_RESET_IF_SWAPPED 18
+ #define NUM_CLOSURE_HOOKS 19
+ #else
+ #if !defined(NEW_SIGNAL_HANDLING) && RESET_IF_SWAPPED == -1
+ #define H_RESET_IF_SWAPPED 17
+ #define NUM_CLOSURE_HOOKS 18
+ #else
+ #if defined(NEW_SIGNAL_HANDLING) && RESET_IF_SWAPPED != -1
+ #define H_CRASH           17
+ #define NUM_CLOSURE_HOOKS 18
+ #else
  #define NUM_CLOSURE_HOOKS 17
+ #endif /* NEW_SIGNAL_HANDLING && RESET_IF_SWAPPED != -1 */
+ #endif /* !NEW_SIGNAL_HANDLING && RESET_IF_SWAPPED == -1 */
+ #endif /* NEW_SIGNAL_HANDLING && RESET_IF_SWAPPED == -1 */

  extern struct svalue closure_hook[NUM_CLOSURE_HOOKS];
Index: func_spec
===================================================================
RCS file: /usr/src/cvs/ldmud/func_spec,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** func_spec	1998/12/30 20:17:25	3.2.5.1
--- func_spec	1998/12/31 11:39:43	3.2.5.2
***************
*** 181,184 ****
--- 184,190 ----
  string clear_bit(string, int);
  object clone_object(string);
+ #ifdef RELOAD_OBJECT
+ void reload_object(object);
+ #endif
  int command(string, void|object);
  string crypt(string, string|int default: F_CONST0);
***************
*** 389,392 ****
--- 395,403 ----
  float exp(float);
  float sqrt(float);
  #endif /* TRANSCENDENT_FUNCTIONS */

***************
*** 404,407 ****
--- 415,430 ----
  int typeof(mixed);
  mixed get_type_info(mixed, int default: F_THIS_OBJECT);
+
+ #ifdef SET_EVAL_COST
+ int set_eval_cost(int default: F_CONST0);
+ #endif /* SET_EVAL_COST */
+
+ #ifdef GET_EVAL_TIME
+ int get_eval_time();
+ #endif /* GET_EVAL_TIME */
+
+ #ifdef GET_NUM_ARGS
+ int get_num_args();
+ #endif /* GET_NUM_ARGS */

  /*---------------------------------------------------------------------------
Index: interpret.c
===================================================================
RCS file: /usr/src/cvs/ldmud/interpret.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** interpret.c	1998/12/30 20:17:25	3.2.5.1
--- interpret.c	1998/12/31 11:39:43	3.2.5.2
***************
*** 159,162 ****
--- 159,170 ----
  #define STACK_OVERFLOW(sp, fp, pc) stack_overflow(sp, fp, pc)

+ #ifdef F_GET_NUM_ARGS
+ static unsigned short num_args_for_function;
+ #endif /* F_GET_NUM_ARGS */
+
  /* defines and a helpfun for F_TERMINAL_COLOUR */

***************
*** 3741,3744 ****
--- 3753,3768 ----
      }
  #endif /* F_CLONE_OBJECT */
+ #ifdef F_RELOAD_OBJECT
+     CASE(F_RELOAD_OBJECT);
+     {
+         assign_eval_cost();
+         TYPE_TEST1(sp, T_OBJECT)
+         inter_sp = sp;
+         inter_pc = pc;
+         reload_object(sp->u.ob);
+         pop_stack();
+         break;
+     }
+ #endif /* F_RELOAD_OBJECT */
      CASE(F_AGGREGATE);
      {
***************
*** 9864,9867 ****
--- 9939,9958 ----
              ERRORF(("%s", sp->u.string));
            }
+ 	  XCASE(F_GET_EVAL_TIME);
+ 	  {
+ 	    struct rusage rus;
+ 	    extern int32 eval_start_time;
+
+ 	    if (getrusage(RUSAGE_SELF, &rus) < 0)
+ 	      {
+ 		push_number(0);
+ 		break;
+ 	      }
+ 	
+ 	    push_number ((RUSAGE_TIME(rus.ru_utime) +
+ 			  RUSAGE_TIME(rus.ru_stime)) -
+ 			 eval_start_time);
+ 	    break;
+ 	  }
            XCASE(F_GET_EVAL_COST);
            {
***************
*** 9869,9872 ****
--- 9960,9995 ----
              break;
            }
+ 	  XCASE(F_SET_EVAL_COST);
+ 	  {
+ 	    if ((sp->type != T_NUMBER) || (sp->u.number < -1))
+ 	      goto xbad_arg_1;
+ 	    if (privilege_violation("set_eval_cost", sp) > 0)
+ 	      {
+ 		switch (sp->u.number)
+ 		  {
+ 		  case 0 :
+ 		    sp->u.number = -CLEAR_EVAL_COST;
+ 		    break;
+ 		  case -1 :
+ 		    sp->u.number = -initial_eval_cost;
+ 		    break;
+ 		  default :
+ 		    {
+ 		      p_int dummy;
+ 		
+ 		      dummy = -initial_eval_cost;
+ 		      initial_eval_cost = -sp->u.number;
+ 		      sp->u.number = dummy;
+ 		      break;
+ 		    }
+ 		  }
+ 	      }
+ 	    break;
+ 	  }
+ 	  XCASE(F_GET_NUM_ARGS);
+ 	  {
+ 	    push_number (num_args_for_function);
+ 	    break;
+ 	  }
            XCASE(F_GARBAGE_COLLECTION);
            {
***************
*** 12534,12538 ****
            flags&O_DESTRUCTED      ?"TRUE":"FALSE");
          add_message("O_SWAPPED         : %s\n",
!           flags&O_SWAPPED          ?"TRUE":"FALSE");
          add_message("O_ONCE_INTERACTIVE: %s\n",
            flags&O_ONCE_INTERACTIVE?"TRUE":"FALSE");
--- 12663,12667 ----
            flags&O_DESTRUCTED      ?"TRUE":"FALSE");
          add_message("O_SWAPPED         : %s\n",
!           flags&O_SWAPPED         ?"TRUE":"FALSE");
          add_message("O_ONCE_INTERACTIVE: %s\n",
            flags&O_ONCE_INTERACTIVE?"TRUE":"FALSE");
***************
*** 12543,12546 ****
--- 12672,12677 ----
          add_message("O_WILL_CLEAN_UP   : %s\n",
            flags&O_WILL_CLEAN_UP   ?"TRUE":"FALSE");
+       	add_message("O_WILL_RESET      : %s\n",
+ 		      flags&O_WILL_RESET      ?"TRUE":"FALSE");
          add_message("total light : %d\n", ob->total_light);
          add_message("next_reset  : %d\n", ob->next_reset);
***************
*** 12647,12650 ****
--- 12778,12833 ----
          break;
        }
+ #ifdef XTENDED_DEBUG_INFO
+       /* return object-size */
+       case 5:
+       {
+ 	struct program *pg;
+ 	mp_int tmp;
+ 	
+ 	if (num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+ 	TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	if(!O_PROG_SWAPPED(sp->u.ob) &&
+ 	   (sp->u.ob->ref == 1 || !(sp->u.ob->flags & O_CLONE)))
+ 	  tmp = sp->u.ob->prog->total_size;
+ 	else
+ 	  tmp = 0;
+ 	res.type = T_NUMBER;
+ 	pg = sp->u.ob->prog;
+ 	res.u.number = tmp + (long)data_size(sp->u.ob) + sizeof(struct object) +
+ 	  sizeof(p_int);
+ 	break;
+       }
+       /* return time_of_last_ref */
+       case 6:
+       {
+ 	if (num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+ 	TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	res.type = T_NUMBER;
+ 	res.u.number = (p_int)sp->u.ob->time_of_ref;
+ 	break;
+       }
+       /* return ref_count */
+       case 7:
+       {
+ 	if(num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+         TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	res.type = T_NUMBER;
+ 	res.u.number = (p_int)sp->u.ob->ref;
+ 	break;
+       }
+       /* return if object is swapped */
+       case 8:
+       {
+ 	if (num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+ 	TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	res.type = T_NUMBER;
+ 	res.u.number = O_PROG_SWAPPED(sp->u.ob);
+ 	break;
+       }
+ #endif /* XTENDED_DEBUG_INFO */
        default: bad_xefun_vararg(1, sp);
      }
Index: lex.c
===================================================================
RCS file: /usr/src/cvs/ldmud/lex.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** lex.c	1998/12/30 20:17:25	3.2.5.1
--- lex.c	1998/12/31 11:39:43	3.2.5.2
***************
*** 643,646 ****
--- 643,656 ----
          add_permanent_define("__EUIDS__", -1, string_copy(""), MY_FALSE);
  #endif
+ #if defined(RESET_IF_SWAPPED) && RESET_IF_SWAPPED
+ 	      sprintf(mtext, "%d", RESET_IF_SWAPPED);
+ 	      add_permanent_define("RESET_IF_SWAPPED", -1, string_copy(mtext), 0);
+ #endif
+ #ifdef XTENDED_DEBUG_INFO
+ 	      add_permanent_define("XTENDED_DEBUG_INFO", -1, string_copy(""), 0);
+ #endif
      mtext[0] = '"';
      mtext[1] = '/';
Index: main.c
===================================================================
RCS file: /usr/src/cvs/ldmud/main.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** main.c	1998/12/30 20:17:25	3.2.5.1
--- main.c	1998/12/31 11:39:44	3.2.5.2
***************
*** 172,175 ****
--- 172,185 ----
      char *p;

+ #ifdef WRITE_PID
+   /* Just to write out the PID for further use in scripts */
+     FILE * driver_pid;
+     if ((driver_pid = fopen (BINDIR"/driver_pid", "w")) != NULL)
+       {
+ 	    fprintf (driver_pid, "%d\n", (int)getpid ());
+ 	    fclose (driver_pid);
+       }
+ #endif
+
      /* Initialisations */

Index: object.c
===================================================================
RCS file: /usr/src/cvs/ldmud/object.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** object.c	1998/12/30 20:17:25	3.2.5.1
--- object.c	1998/12/31 11:39:44	3.2.5.2
***************
*** 1789,1790 ****
--- 1789,1851 ----
  }
  #endif /* 0 */
+
+ #ifdef F_RELOAD_OBJECT
+ void
+ reload_object(struct object *ob)
+ {
+     int i;
+
+     if (!ob->prog || (ob->flags & O_DESTRUCTED))
+       return;
+     for (i = 0; i < (int) ob->prog->num_variables; i++)
+     {
+       free_svalue(&ob->variables[i]);
+       ob->variables[i] = const0;
+     }
+     if (ob->flags & O_SWAPPED)
+       if (load_ob_from_swap(ob) < 0)
+         error("Out of memory\n");
+
+     if (O_GET_SHADOW(ob)->shadowed_by && !O_GET_SHADOW(ob)->shadowing)
+     {
+       struct svalue svp;
+       struct object * ob2;
+
+       svp.type = T_OBJECT;
+       for (ob2 = O_GET_SHADOW(ob)->shadowed_by; ob2;)
+ 	    {
+ 	      svp.u.ob = ob2;
+ 	      ob2 = O_GET_SHADOW(ob2)->shadowed_by;
+ 	      O_GET_SHADOW(svp.u.ob)->shadowed_by = 0;
+ 	      O_GET_SHADOW(svp.u.ob)->shadowing = 0;
+ 	      destruct_object(&svp);
+ 	    }
+     }
+     if (O_GET_SHADOW(ob)->shadowing)
+     {
+       O_GET_SHADOW(O_GET_SHADOW(ob)->shadowing)->shadowed_by =
+ 	              O_GET_SHADOW(ob)->shadowed_by;
+       O_GET_SHADOW(ob)->shadowing = 0;
+ 	    ob->flags &= ~O_SHADOW;
+     }
+     if (O_GET_SHADOW(ob)->shadowed_by)
+     {
+       O_GET_SHADOW(O_GET_SHADOW(ob)->shadowed_by)->shadowing =
+ 	              O_GET_SHADOW(ob)->shadowing;
+       O_GET_SHADOW(ob)->shadowed_by = 0;
+     }
+     ob->flags &= ~O_ENABLE_COMMANDS;
+     set_heart_beat(ob, 0);
+     ob->flags |= O_DESTRUCTED;
+     remove_stale_call_outs();
+     ob->flags &= ~O_DESTRUCTED;
+     add_light (ob, -(ob->total_light));
+ #ifdef EUIDS
+     ob->eff_user = NULL;
+ #endif
+     if (ob->flags & O_CLONE)
+       reset_object (ob, H_CREATE_CLONE);
+     else
+       reset_object (ob, H_CREATE_OB);
+ }
+ #endif /* F_RELOAD_OBJECT */
Index: object.h
===================================================================
RCS file: /usr/src/cvs/ldmud/object.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** object.h	1998/12/30 20:17:25	3.2.5.1
--- object.h	1998/12/31 11:39:44	3.2.5.2
***************
*** 37,40 ****
--- 37,44 ----
  #define O_LAMBDA_REFERENCED        0x400 /* be careful with replace_program() */
  #define O_SHADOW                0x800
+ #define O_WILL_RESET            0x2000
+ #if RESET_IF_SWAPPED == -1
+ #define O_RESET_IF_SWAPPED      0x4000    /* Object will reset during swap out */
+ #endif /* RESET_IF_SWAPPED == -1 */

  #define O_PROG_SWAPPED(ob) ((p_int)(ob)->prog & 1)
***************
*** 129,132 ****
--- 133,140 ----

  #define check_object(o) ((o)&&(o)->flags&O_DESTRUCTED?0:(o))
+
+ #ifdef F_RELOAD_OBJECT
+ extern void reload_object PROT((struct object *));
+ #endif /* F_RELOAD_OBJECT */

  #endif /* __OBJECT_H__ */
Index: simulate.c
===================================================================
RCS file: /usr/src/cvs/ldmud/simulate.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** simulate.c	1998/12/30 20:17:25	3.2.5.1
--- simulate.c	1998/12/31 11:39:44	3.2.5.2
***************
*** 33,39 ****
  #endif /* NDIR */
  #endif /* not (DIRENT or _POSIX_VERSION) */
- #if defined(__CYGWIN32__)
- extern int lstat PROT((char *, struct stat *));
- #endif

  #include "simulate.h"
--- 33,36 ----
***************
*** 94,98 ****
  static void remove_environment_sent PROT((struct object *));
  static int special_parse PROT((char *buff));
!

  char *last_verb = 0;
--- 91,95 ----
  static void remove_environment_sent PROT((struct object *));
  static int special_parse PROT((char *buff));
! static void signal_handler PROT((int sig));

  char *last_verb = 0;
***************
*** 315,318 ****
--- 312,355 ----
  } /* make_name_sane() */

+ #if RESET_IF_SWAPPED == -1
+ static INLINE void
+ reset_if_swapped(struct object *ob) {
+     if (closure_hook[H_RESET_IF_SWAPPED].type == T_CLOSURE)
+     {
+         extern struct svalue *inter_sp;
+         struct lambda * l;
+
+         l = closure_hook[H_RESET_IF_SWAPPED].u.lambda;
+       /* we do not expect any arguments */
+       /* bind to target */
+         l->ob = ob;
+         call_lambda (&closure_hook[H_RESET_IF_SWAPPED], 0);
+         if (inter_sp->type == T_NUMBER && !inter_sp->u.number)
+ 	      ; /* do nothing ... */
+         else
+ 	          ob->flags |= O_RESET_IF_SWAPPED;
+             pop_stack ();
+     }
+     else if (closure_hook[H_RESET_IF_SWAPPED].type == T_STRING ||
+              closure_hook[H_RESET_IF_SWAPPED].type == T_NUMBER)
+     {
+         struct svalue * res;
+
+         if (closure_hook[H_RESET_IF_SWAPPED].type == T_NUMBER)
+ 	          res = sapply ("reset_if_swapped", ob, 0);
+         else
+ 	          res = sapply (closure_hook[H_RESET_IF_SWAPPED].u.string, ob, 0);
+
+         if (res)
+ 	      {
+ 	          if (res->type == T_NUMBER && !res->u.number)
+ 	          ; /* do nothing ... */
+ 	      else
+ 	          ob->flags |= O_RESET_IF_SWAPPED;
+ 	      }
+     }
+ }
+ #endif /* RESET_IF_SWAPPED == -1 */
+
  /*
   * Load an object definition from file. If the object wants to inherit
***************
*** 569,580 ****
--- 606,629 ----
              /* If the master inherits anything -Ugh- we have to have
                 some object to attribute initialized variables to again */
+ #if RESET_IF_SWAPPED == -1
+       	    reset_if_swapped (ob);
+ #endif /* RESET_IF_SWAPPED == -1 */
              current_object = save_current;
          } else {
              current_object = save_current;
              reset_object(ob, H_CREATE_OB - dont_reset);
+ #if RESET_IF_SWAPPED == -1
+       	    reset_if_swapped (ob);
+ #endif /* RESET_IF_SWAPPED == -1 */
          }
      }
      if ( !(ob->flags & O_DESTRUCTED) && function_exists("clean_up",ob) )
+         {
          ob->flags |= O_WILL_CLEAN_UP;
+        	if ( (closure_hook[H_RESET].type == T_STRING &&
+ 	          function_exists(closure_hook[H_RESET].u.string, ob)) ||
+ 	          (closure_hook[H_RESET].type == T_CLOSURE) )
+     	          ob->flags |= O_WILL_RESET;
+         }
      command_giver = check_object(save_command_giver);
      if (d_flag > 1 && ob)
***************
*** 686,690 ****
          error("Out of memory\n");
      new_ob->name = make_new_name(ob->name);
!     new_ob->flags |= O_CLONE | (ob->flags & ( O_APPROVED | O_WILL_CLEAN_UP )) ;
      new_ob->prog = ob->prog;
      reference_prog (ob->prog, "clone_object");
--- 735,739 ----
          error("Out of memory\n");
      new_ob->name = make_new_name(ob->name);
!     new_ob->flags |= O_CLONE | (ob->flags & ( O_APPROVED | O_WILL_CLEAN_UP | O_WILL_RESET )) ;
      new_ob->prog = ob->prog;
      reference_prog (ob->prog, "clone_object");
***************
*** 1140,1144 ****
--- 1189,1230 ----
          ob->sent = 0;
      }
+ #ifdef LAZY_SWAP
+ /* to clear the swap-buffer, if the object to be removed is in
+  * that buffer, so we can avoid errors about non-existent objects
+  */
+     {
+       extern struct _swap_cache * swap_cache;

+       if (!swap_cache->next)
+ 	    {
+ 	      if (swap_cache->ob && (swap_cache->ob == ob))
+ 	        swap_cache->ob = NULL;
+ 	    }
+       else
+ 	    {
+ 	      struct _swap_cache * x = swap_cache;
+ 	      struct _swap_cache * y = NULL;
+
+ 	      for (; x->next; y = x, x = x->next)
+ 	      {
+ 	        if (x->ob == ob)
+ 		      {
+ 		        if (y)
+ 		        {
+ 		          y->next = x->next;
+ 		          x->ob = NULL;
+ 		          xfree (x);
+ 		        }
+ 		        else
+ 		        {
+ 		          swap_cache = x->next;
+ 		          x->ob = NULL;
+ 		          xfree (x);
+ 		        }
+ 		      }
+ 	      } /* for */
+ 	    }
+     }
+ #endif LAZY_SWAP
      free_object(ob, "destruct_object");
  }
***************
*** 2829,2833 ****
      debug_parse_buff[sizeof debug_parse_buff - 1] = '\0';
  #endif
!     if (strcmp(buff, "malloc") == 0) {
  #if defined(MALLOC_malloc) || defined(MALLOC_smalloc)
          dump_malloc_data();
--- 2915,2920 ----
      debug_parse_buff[sizeof debug_parse_buff - 1] = '\0';
  #endif
!     if (!is_wizard_used || command_giver->flags & O_IS_WIZARD) {
!        if (strcmp(buff, "malloc") == 0) {
  #if defined(MALLOC_malloc) || defined(MALLOC_smalloc)
          dump_malloc_data();
***************
*** 2841,2845 ****
          return 1;
      }
-     if (!is_wizard_used || command_giver->flags & O_IS_WIZARD) {
          if (strcmp(buff, "dumpallobj") == 0) {
              dumpstat();
--- 2928,2931 ----
***************
*** 3076,3079 ****
--- 3162,3166 ----
  }

+
  #ifdef __STDC__
  void fatal(char *fmt, ...)
***************
*** 3084,3087 ****
--- 3171,3175 ----
      int a, b, c, d, e, f, g, h;
  #endif
+ #ifndef NEW_SIGNAL_HANDLING   // old code
  {
  #ifdef __STDC__
***************
*** 3129,3135 ****
      *((char*)0) = 0/0;
  #endif
!     abort();
  }

  int num_error = 0;
  char *current_error, *current_error_file, *current_error_object_name;
--- 3217,3334 ----
      *((char*)0) = 0/0;
  #endif
! #else /* NEW_SIGNAL_HANDLING */
! {
!   extern char *current_file;
!   extern int current_line;
!   extern struct object *current_object;
!   extern struct object *command_giver;
!
!   static int in_fatal = 0;
!   char msg_buf[2049];
!   char succ;
! #ifdef __STDC__
!   va_list args;
! #endif
!   /*  char *fmt;*/
!
!   if (in_fatal)
!     {
!       debug_message ("Fatal error while shutting down.  Aborting.\n");
!     }
!   else
!     {
!       in_fatal = 1;
! #ifdef __STDC__
!       va_start(args, fmt);
!       (void)vsprintf (msg_buf, fmt, args);
!       va_end(args);
! #else
!       (void)sprintf (msg_buf, fmt, a, b, c, d, e, f, g, h);
! #endif
!       debug_message ("!!!!!!!!!! Fatal ERROR: %s\nDriver attempting to "
! 		     "exit gracefully.\n", msg_buf);
!       if (current_file)
! 	debug_message ("(occured during compilation if %s at line %d)\n",
! 		       current_file, current_line);
!       if (current_object)
! 	debug_message ("(current object was /%s)\n",
! 		       (current_object->name));
!
!       debug_message("Dump of variables:\n");
!       (void)dump_trace (1);
!
!       succ = 0;
!       if (closure_hook[H_CRASH].type == T_CLOSURE)
! 	{
! 	  struct lambda * l;
! 	 unsigned short args;
!
! 	  l = closure_hook[H_CRASH].u.lambda;
! 	  l->ob = current_object;
! 	  if (args = l->function.code[1])
! 	    {
! 	      push_string_malloced (string_copy (msg_buf));
! 	      if (args > 1)
! 		if (command_giver)
! 		  push_object (command_giver);
! 		else
! 		  push_number (0);
! 	      if (args > 2)
! 		if (current_object)
! 		  push_object (current_object);
! 		else
! 		  push_number (0);
! 	      if (args > 3)
! 		args = 3;
! 	      call_lambda (&closure_hook[H_CRASH], args);
! 	    }
! 	  else
! 	    call_lambda (&closure_hook[H_CRASH], 0);
! 	  pop_stack ();
! 	  succ = 1;
! 	}
!       else if (closure_hook[H_CRASH].type == T_STRING ||
! 	       closure_hook[H_CRASH].type == T_NUMBER)
! 	{
! 	  struct svalue * res;
!
! 	  push_string_malloced (string_copy (msg_buf));
! 	  if (command_giver)
! 	    push_object (command_giver);
! 	  else
! 	    push_number (0);
! 	  if (current_object)
! 	    push_object (current_object);
! 	  else
! 	    push_number (0);
! 	
! 	  if (closure_hook[H_CRASH].type == T_NUMBER)
! 	    res = apply_master_ob ("crash", 3);
! 	  else
! 	    res = apply_master_ob (closure_hook[H_CRASH].u.string, 3);
!
! 	  succ = !(!res);
! 	}
!       if (succ)
! 	debug_message ("crash function in master object called successfully.  Aborting.\n");
!       else
! 	debug_message ("crash function in master object not found.  Aborting.\n");
!     }
!   flush_all_player_mess ();
! #ifdef SIGABRT
!   (void)signal (SIGABRT, SIG_DFL);
! #endif
! #ifdef SIGILL
!   (void)signal (SIGILL, SIG_DFL);
! #endif
! #ifdef SIGIOT
!   (void)signal (SIGIOT, SIG_DFL);
! #endif
!  in_fatal = 0;
! #endif /* NEW_SIGNAL_HANLDING */
!   abort();
  }

+
  int num_error = 0;
  char *current_error, *current_error_file, *current_error_object_name;
***************
*** 3567,3570 ****
--- 3766,3770 ----
  int master_will_be_updated = 0;

+
  struct svalue *f_shutdown(sp)
      struct svalue *sp;
***************
*** 3575,3578 ****
--- 3775,3780 ----
  }

+ #ifndef NEW_SIGNAL_HANLDING
+
  /* this will be activated by SIGUSR1 */
  void startmasterupdate() {
***************
*** 3583,3586 ****
--- 3785,3921 ----
  }

+ #endif /* NEW_SIGNAL_HANDLING */
+
+ #ifdef NEW_SIGNAL_HANDLING
+
+ void
+ init_signal_handler() {
+ #ifdef SIGHUP
+   (void)signal (SIGHUP, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGINT
+   (void)signal (SIGINT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGQUIT
+   (void)signal (SIGQUIT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGILL
+   (void)signal (SIGILL, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGTRAP
+   (void)signal (SIGTRAP, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGIOT
+   (void)signal (SIGIOT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGEMT
+   (void)signal (SIGEMT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGFPE
+   (void)signal (SIGFPE, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGBUS
+   (void)signal (SIGBUS, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGSEGV
+   (void)signal (SIGSEGV, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGSYS
+   (void)signal (SIGSYS, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGTERM
+   (void)signal (SIGTERM, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGUSR1
+   (void)signal (SIGUSR1, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGUSR2
+   (void)signal (SIGUSR2, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGCLD
+   (void)signal (SIGCLD, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGPWR
+   (void)signal (SIGPWR, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGIO
+   (void)signal (SIGIO, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ }
+
+
+ static void
+ signal_handler(int sig) {
+     switch (sig)
+     {
+ #ifdef SIGHUP
+     case SIGHUP : fatal ("Hangup"); break;
+ #endif
+ #ifdef SIGINT
+     case SIGINT : fatal ("Interrupt"); break;
+ #endif
+ #ifdef SIGQUIT
+     case SIGQUIT : fatal ("Quit"); break;
+ #endif
+ #ifdef SIGILL
+     case SIGILL : fatal  ("Illegal instruction"); break;
+ #endif
+ #ifdef SIGTRAP
+     case SIGTRAP : fatal ("Trace trap"); break;
+ #endif
+ #ifdef SIGIOT
+     case SIGIOT :
+ #endif
+ #ifdef SIGEMT
+     case SIGEMT :
+ #endif
+ #if defined(SIGIOT) || defined(SIGEMT)
+       fatal ("Software generated abort"); break;
+ #endif
+ #ifdef SIGFPE
+     case SIGFPE : (void)signal (SIGFPE, (RETSIGTYPE(*)PROT((int)))signal_handler); break;
+ #endif
+ #ifdef SIGBUS
+     case SIGBUS : fatal ("Bus error"); break;
+ #endif
+ #ifdef SIGSEGV
+     case SIGSEGV : fatal ("Segmentation violation"); break;
+ #endif
+ #ifdef SIGSYS
+     case SIGSYS : fatal ("Bad argument to system call"); break;
+ #endif
+ #ifdef SIGUSR1
+     case SIGUSR1 :
+       {
+     	extra_jobs_to_do = MY_TRUE;
+ 	    master_will_be_updated = 1;
+ 	    add_eval_cost (-initial_eval_cost >> 3 );  // to update the master could be very expensive
+ 	    (void)signal (SIGUSR1, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ 	  	break;
+       }
+ #endif
+ #ifdef SIGUSR2
+     case SIGUSR2 : (void) signal (SIGUSR2, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGCLD
+     case SIGCLD :
+       {
+ 	    int status;
+ 	    wait (&status);
+ 	    (void)signal (SIGCLD, (RETSIGTYPE(*)PROT((int)))signal_handler);
+     	break;
+       }
+ #endif
+ #ifdef SIGPWR
+     case SIGPWR : (void)signal (SIGPWR, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGIO
+     case SIGIO : (void)signal (SIGIO, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+     }
+ }
+
+ #endif /* NEW_SIGNAL_HANDLING */
+
  /*
   * This one is called from the command "shutdown".
***************
*** 3611,3614 ****
--- 3946,3950 ----
      exit(0);
  }
+

  /*
Index: simulate.h
===================================================================
RCS file: /usr/src/cvs/ldmud/simulate.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** simulate.h	1998/12/30 20:17:25	3.2.5.1
--- simulate.h	1998/12/31 11:39:44	3.2.5.2
***************
*** 92,96 ****
--- 92,100 ----
  extern char *check_valid_path PROT((char *path, struct object *caller, char *call_fun, int writeflg));
  extern struct svalue *f_shutdown PROT((struct svalue *sp));
+ #ifndef NEW_SIGNAL_HANDLING
  extern void startmasterupdate PROT((void));
+ #else
+ extern void init_signal_handler();
+ #endif
  extern void shutdowngame PROT((void));

Index: hosts/defines.txt
===================================================================
RCS file: /usr/src/cvs/ldmud/hosts/defines.txt,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** hosts/defines.txt	1998/12/30 20:17:27	3.2.5.1
--- hosts/defines.txt	1998/12/31 12:06:45	3.2.5.2
***************
*** 32,35 ****
  ---------
  gcc:			__GNUC__
! Cygnus gcc for Win32    __CYGWIN32__
  Metrowerks (Be)         __MWERKS__
--- 32,35 ----
  ---------
  gcc:			__GNUC__
! Cygnus gcc for Win32    __CYGWIN__
  Metrowerks (Be)         __MWERKS__
Index: hosts/unix.h
===================================================================
RCS file: /usr/src/cvs/ldmud/hosts/unix.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** hosts/unix.h	1998/12/30 20:17:27	3.2.5.1
--- hosts/unix.h	1998/12/31 11:42:01	3.2.5.2
***************
*** 21,25 ****
  #endif

! #if defined(SunOS4) || defined(ultrix) || defined(__CYGWIN32__)
  extern int gethostname(char *, int);
  extern char *getdomainname(char *, int);
--- 21,25 ----
  #endif

! #if defined(SunOS4) || defined(ultrix)
  extern int gethostname(char *, int);
  extern char *getdomainname(char *, int);
***************
*** 32,41 ****
  #endif

! #if defined(__CYGWIN32__) || defined(sun)
  extern time_t time(time_t *tloc);
- #endif
-
- #if 0 && defined(__CYGWIN32__)
- extern char * ctime(time_t *tloc);
  #endif

--- 32,37 ----
  #endif

! #ifdef sun
  extern time_t time(time_t *tloc);
  #endif

Index: mudlib/sys/driver_hook.h
===================================================================
RCS file: /usr/src/cvs/ldmud/mudlib/sys/driver_hook.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** mudlib/sys/driver_hook.h	1998/12/30 20:17:30	3.2.5.1
--- mudlib/sys/driver_hook.h	1998/12/31 11:41:22	3.2.5.2
***************
*** 16,17 ****
--- 16,19 ----
  #define H_ERQ_STOP	15
  #define H_MODIFY_COMMAND_FNAME 16
+ #define H_SIGNALS 17
+ #define H_RESET_IF_SWAPPED 18
