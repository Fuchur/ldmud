Short: Comparison-by-Value ("===") for Arrays and Mappings
From: wolf.dieter@dallinger.de
Date: 2001-10-09
Type: Feature
State: New

The '==' operator compares mappings and arrays by reference. It would be nice
to have a second operator which compares by value.

------------------

From: "Wolf Dieter Dallinger" <wolf.dieter@dallinger.de>
To: "Lars Duening" <lars@bearnip.com>
References: <000c01c19b9d$a3643a30$0200a8c0@wolf> <0003976460141131_mailit@localhost>
Subject: Re: Echter Vergleich zweier Ausdruecke mittels Operatoren === und !== =
Date: Wed, 16 Jan 2002 13:40:39 +0100

-----Ursprüngliche Nachricht-----
Von: "Lars Duening" <lars@bearnip.com>
An: <wolf.dieter@dallinger.de>
Gesendet: Sonntag, 13. Januar 2002 01:38
Betreff: Re: Echter Vergleich zweier Ausdruecke mittels Operatoren === und
!== =


Hi, Lars!

> Wolf Dieter Dallinger wrote on Saturday, January 12 2002, 11:52:22:
>
> >Ich schlag 'nen Operator === vor, mit dem sich zwei Ausdruecke auf
gleichen
> >Inhalt testen lassen.
>
> Das hast du schon vor drei Monaten schon mal vorgeschlagen (f-011015-2,
und
> es ist eine gute Idee) :-)

Ja, ich stand auch vor dem selben Problem, welches ich jetzt aber anders
lösen konnte. Ich hätte Mappings vergleichen müssen. An sich kein Problem,
aber wieso nicht gleich die große Lösung mit if(mapping1===mapping2).

> Eine Frage: Wie willst du Objekte vergleichen?

Hm, der Hintergedanke ist eigentlich eher, Mappings und Arrays gleichen
Inhaltes auch vergleichen zu koennen. Bei einem Objekt soll nur dann
Gleichheit bestehen, wenn es das selbe ist. Abgesehen davon scheint mir das
Vergleichen von Objekten nicht wirklich eine erfolgversprechende Aufgabe.
Sich darüber Gedanken zu machen ist allerdings interessant.

Bei Lambda-Closures widerrum könnte man auch zwei scheinbar verschiedene
durch Byte-weisen Vergleich als gleich erkennen. Dies wäre allerdings eine
Sache für den Mud-Treiber. Hintergund: Ein Objekt A verpasst anderen
Objekten eine an einen Closure-Container gebundene Lambda-Closure.
Zwischendurch wird A zerstört, wieder geladen, und fährt mit seiner Arbeit
fort. Die alten und neuen Lambdas sind gleich, auch wenn dies so nicht zu
erkennen ist.

> >Gerne natürlich auch eine hart codierte Implementierung. *g*
>
> Ich wollte schon fragen: wieso einen Operator, wenn du eh eine
LPC-Funktion
> aufrufst :-)

Ein Operator ist im Quelltext deutlichst besser zu lesen, und er gehört
einfach zu den anderen Operatoren. Ausserdem halte ich solch einen
Operator/eine Funktion für zwingend notwendig. Ein häufiger Einsatz des
Operators halte ich für wahrscheinlich.

> > Eine LPC-Implementierung fuer das Master-Objekt kann ich gerne
> > programmieren.
>
> Wenn du Lust hast, kannst du das ja erstmal als simul-efun implementieren.

Ja, das werd ich machen. Dann komm ich wieder... *g*

> --
> Lars Duening; lars@bearnip.com
> PGP Key: http://www.bearnip.com/lars/pgp-lars.asc
>


Viele Grüsse

Pulami@UNItopia

PS: Ich hab mal angefragt, ob es möglich wäre, dass functionlist() auch die
Zeilennummer einer Funktionsdeklaration zurückliefern kann. Der Gedanke kam
mir, da ja auch bei Fehlern die Zeilennummer angegeben wird. Eventuell kam
aber meine Email nicht durch, mein Virus-Checker für den Email-Ausgang hat
einige vernichtet... 8-(

PPS: Grüße an das Snörkelchen! *g*

Wolf Dieter Dallinger
Eckartshaldenweg 11 - D-70191 Stuttgart
Tel. (07 11) 25 67 55-0 - Fax (07 11) 25 67 55-5
Email wolf.dieter@dallinger.de
WWW http://www.dallinger.de/wolf.dieter/


