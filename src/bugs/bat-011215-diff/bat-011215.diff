Only in ldmud-20011215: CHANGELOG.BAT
diff -r -u ld33/src/Makefile.in ldmud-20011215/src/Makefile.in
--- ld33/src/Makefile.in	Tue Nov 27 08:50:42 2001
+++ ldmud-20011215/src/Makefile.in	Thu Dec 20 09:51:18 2001
@@ -40,17 +40,17 @@
 #PROFIL=-pg
 PROFIL=
 #Enable warnings from the compiler, if wanted.
-WARN= # no warning options - will work with all compilers :-)
+#WARN= # no warning options - will work with all compilers :-)
 #WARN= -Wall -Wshadow
-#WARN= -Wall -Wshadow -Wparentheses # gcc settings
+WARN= -Wall -Wshadow -Wparentheses # gcc settings
 #
 # Optimization and source level debugging options.
 # adding a -fomit-frame-pointer on the NeXT (gcc version 1.93 (68k, MIT syntax))
 # will corrupt the driver.
-OPTIMIZE = @OCFLAGS@ # high optimization
+#OPTIMIZE = @OCFLAGS@ # high optimization
 #OPTIMIZE= @MCFLAGS@ # medium optimization
 #OPTIMIZE = @LCFLAGS@ # minimal optimization
-#OPTIMIZE= @DCFLAGS@ # no optimization; for frequent recompilations.
+OPTIMIZE= @DCFLAGS@ # no optimization; for frequent recompilations.
 #
 # Debugging options:
 #   -DDEBUG: Enable run time debugging. It will use more time and space.
@@ -61,8 +61,8 @@
 #   -DDEBUG_TELNET: Activates debug prints in the telnet machine
 #   -DDEBUG_SMALLOC_ALLOCS: Activates allocation debug prints in smalloc.
 #DEBUG = -DDEBUG -DTRACE_CODE
-DEBUG = -DDEBUG -DTRACE_CODE # -DDEBUG_TELNET
-#DEBUG=
+#DEBUG = -DDEBUG -DTRACE_CODE # -DDEBUG_TELNET
+DEBUG= -DDEBUG -DTRACE_CODE -DNO_INLINES #-DYYDEBUG=1 -DCHECK_STRINGS
 #
 MPATH=-DMUD_LIB='"$(MUD_LIB)"' -DBINDIR='"$(BINDIR)"' -DERQ_DIR='"$(ERQ_DIR)"'
 #
@@ -84,7 +84,9 @@
       lex.c main.c mapping.c md5.c mempools.c mstrings.c object.c otable.c\
       parser.c parse.c parse_old.c pkg-alists.c pkg-mysql.c port.c ptrtable.c \
       random.c regexp.c rxcache.c simulate.c simul_efun.c stdstrings.c \
-      strfuns.c sprintf.c swap.c wiz_list.c xalloc.c
+      strfuns.c sprintf.c swap.c wiz_list.c xalloc.c bat.c profil2.c \
+      frame.c
+
 OBJ = access_check.o actions.o array.o backend.o bitstrings.o call_out.o \
       closure.o comm.o \
       dumpstat.o ed.o efuns.o files.o gcollect.o hash.o heartbeat.o \
@@ -92,7 +94,8 @@
       lex.o main.o mapping.o md5.o mempools.o mstrings.o object.o otable.o \
       parser.o parse.o parse_old.o pkg-alists.o pkg-mysql.o port.o ptrtable.o \
       random.o regexp.o rxcache.o simulate.o simul_efun.o stdstrings.o \
-      strfuns.o sprintf.o swap.o wiz_list.o xalloc.o @ALLOCA@
+      strfuns.o sprintf.o swap.o wiz_list.o xalloc.o bat.o profil2.o \
+      frame.o @ALLOCA@
 
 driver: $(OBJ)
 	$(CC) @OPTIMIZE_LINKING@ $(LDFLAGS) $(OBJ) -o $@ $(LIBS)
@@ -161,6 +164,13 @@
 
 #--------------------------------------------------------
 # Dependencies, manual and automatic.
+
+frame.o : frame.h
+
+bat.o : bat.h main.h object.h simulate.h interpret.h xalloc.h svalue.h \
+    array.h swap.h typedefs.h comm.h mstrings.h stdstrings.h profil2.h
+
+profil2.o : profil2.h
 
 # --- DO NOT MODIFY THIS LINE -- AUTO-DEPENDS FOLLOW ---
 access_check.o : xalloc.h filestat.h comm.h access_check.h driver.h \
diff -r -u ld33/src/backend.c ldmud-20011215/src/backend.c
--- ld33/src/backend.c	Wed Dec 19 08:44:10 2001
+++ ldmud-20011215/src/backend.c	Thu Dec 20 09:51:18 2001
@@ -78,7 +78,11 @@
 
 /*-------------------------------------------------------------------------*/
 
+#ifdef BAT
+#define ALARM_TIME  3  /* The granularity of alarm() calls */
+#else
 #define ALARM_TIME  2  /* The granularity of alarm() calls */
+#endif
 
 /*-------------------------------------------------------------------------*/
 mp_int current_time;
@@ -260,6 +264,25 @@
 #endif
 } /* handle_hup() */
 
+#ifdef BAT
+/*-------------------------------------------------------------------------*/
+static RETSIGTYPE
+handle_usr2 (int sig UNUSED)
+
+/* SIGUSR2 handler: set eval cost to max
+ */
+
+{
+#ifdef __MWERKS__
+#    pragma unused(sig)
+#endif
+    eval_cost = max_eval_cost;
+    (void)signal(SIGUSR2, handle_usr2);
+#ifndef RETSIGTYPE_VOID
+    return 0;
+#endif
+} /* handle_usr2() */
+#endif
 /*-------------------------------------------------------------------------*/
 static RETSIGTYPE
 handle_usr1 (int sig UNUSED)
@@ -344,6 +367,9 @@
 
     prepare_ipc();
 
+#ifdef BAT
+    (void)signal(SIGUSR2, handle_usr2);
+#endif
     (void)signal(SIGHUP,  handle_hup);
     (void)signal(SIGUSR1, handle_usr1);
     if (!t_flag) {
Only in ldmud-20011215/src: bat.c
Only in ldmud-20011215/src: bat.h
diff -r -u ld33/src/comm.c ldmud-20011215/src/comm.c
--- ld33/src/comm.c	Wed Dec 19 08:44:10 2001
+++ ldmud-20011215/src/comm.c	Thu Dec 20 09:51:18 2001
@@ -114,6 +114,9 @@
 #include "swap.h"
 #include "wiz_list.h"
 #include "xalloc.h"
+#ifdef BAT
+#include "bat.h"
+#endif
 
 #include "../mudlib/sys/driver_hook.h"
 #include "../mudlib/sys/input_to.h"
@@ -1282,6 +1285,26 @@
             srcstr = NULL;
         }
 
+#ifdef BAT
+        if(catching_write)
+	  {
+	    if(srclen > CATCH_WRITE_BUF_LEN - catch_write_len)
+	      {
+		catching_write = 0;
+		catch_write_len = 0;
+		catch_write_buf[0] = '\0';
+		
+		error("catch_write buffer full.\n");
+		return;
+	      }
+	    
+	    strncpy(&catch_write_buf[catch_write_len], source, srclen);
+	    catch_write_len += srclen;
+	    
+	    return;
+	  }
+#endif
+
         /* If we're not sending a telnet command with this message,
          * pass on the new data to any snooper and/or shadow
          */
@@ -3455,6 +3478,9 @@
     {
         add_message(FMT_STRING, prompt->u.str);
     }
+#ifdef BAT
+    add_message("%c%c", IAC, GA);
+#endif
 } /* print_prompt() */
 
 /*-------------------------------------------------------------------------*/
@@ -6694,3 +6720,113 @@
 
 /***************************************************************************/
 
+#ifdef BAT
+/*-------------------------------------------------------------------------*/
+int push_line_to_player(object_t *ob, char *line)
+{
+  interactive_t *ip;
+  int x;
+  int linelen = 0, buflinelen = 0;
+
+  if (strchr(line, '\n'))
+    return 0;
+  if (strchr(line, '\r'))
+    return 0;
+
+  for (x=0; x< MAX_PLAYERS; x++)
+    if (all_players[x] && all_players[x]->ob == ob)
+      break;
+  
+  if (x == MAX_PLAYERS)
+    return 0;
+
+  ip = all_players[x];
+
+  linelen = strlen(line);
+  
+  if (MAX_TEXT - ip->text_end-5 < linelen)
+    return 0;
+
+#if 0
+  printf("push_line(%s) before\n", line);
+  for(asd = 0; asd < ip->text_end; asd++)
+    {
+      if(isprint(ip->text[asd]))
+	printf("'%c'(%d) ", ip->text[asd], ip->text[asd]);
+      else
+	printf("''(%d) ", ip->text[asd]);
+    }
+  printf("\n");
+  printf("%d, %d, %d, %d, %d, %d\n", ip->text_end, ip->command_start, 
+	 ip->command_end, ip->tn_start, ip->tn_end, ip->chars_ready);
+#endif
+
+  if(ip->text_end > 0)
+  {
+      /* alussa on stringi joka paattyy 0:aan. */
+      buflinelen = strlen(ip->text);
+      if(ip->tn_end < ip->text_end)
+      {
+	  /* tn_end:sta lahtien on lisaa tavaraa, 
+	     jotka paattyvat text_end:iin. siirretaan se teksti
+	     tarpeeks eteenpain, jotta uus stringi ja alussa oleva stringi
+	     mahtuvat */
+	  memmove(ip->text + linelen+1 + buflinelen+1, 
+		  ip->text + ip->tn_end, 
+		  ip->text_end - ip->tn_end);
+      }
+
+      /* alussa oleva stringi on jo parsittu ja \n on muutettu 0:aks,
+	 muutetaan takas */
+      ip->text[buflinelen] = '\n';
+      /* siirretaan alussa olevaa stringia (ja \n) */
+      memmove(ip->text + linelen+1, ip->text, buflinelen+1);
+  }
+
+  /* lisataan uus stringi */
+  strcpy(ip->text, line);
+  ip->text_end = (ip->text_end - ip->tn_end) + 
+      (buflinelen ? buflinelen+1 : 0) + linelen+1;
+  ip->tn_end = linelen+1;
+
+#if 0
+  printf("push_line after\n");
+  for(asd = 0; asd < ip->text_end; asd++)
+    {
+      if(isprint(ip->text[asd]))
+	printf("'%c'(%d) ", ip->text[asd], ip->text[asd]);
+      else
+	printf("''(%d) ", ip->text[asd]);
+    }
+  printf("\n");
+  printf("%d, %d, %d, %d, %d, %d\n", ip->text_end, ip->command_start, 
+	 ip->command_end, ip->tn_start, ip->tn_end, ip->chars_ready);
+#endif
+
+  ip->tn_state = TS_READY;
+
+  return 1;
+}
+
+svalue_t *
+f_push_line (svalue_t *sp)
+{
+  if (current_object->flags & O_DESTRUCTED)
+    {
+      free_svalue(sp);
+      put_number(sp, 0);      
+    }
+  else
+    {
+      int i;
+
+      i = push_line_to_player(current_object, get_txt(sp[0].u.str));
+      
+      free_svalue(sp);
+      put_number(sp, i);
+    }
+
+  return sp;
+} /* f_push_line() */
+
+#endif
diff -r -u ld33/src/config.h.in ldmud-20011215/src/config.h.in
--- ld33/src/config.h.in	Wed Dec 19 08:44:10 2001
+++ ldmud-20011215/src/config.h.in	Thu Dec 20 09:51:18 2001
@@ -7,6 +7,9 @@
 #ifndef CONFIG_H__
 #define CONFIG_H__ 1
 
+/* Batmud support */
+#define BAT
+
 /* Should code for the external request demon be included?
  */
 @cdef_erq_demon@ ERQ_DEMON
Only in ldmud-20011215/src: crc32.c
Only in ldmud-20011215/src: crc32.h
diff -r -u ld33/src/efuns.c ldmud-20011215/src/efuns.c
--- ld33/src/efuns.c	Mon Nov 19 08:50:53 2001
+++ ldmud-20011215/src/efuns.c	Thu Dec 20 09:51:18 2001
@@ -2411,6 +2411,9 @@
             continue;
 
         case 'd':
+#ifdef BAT
+        case 'i':
+#endif
             /* Skip leading whitespace */
             while(isspace((unsigned char)*str))
                 str++;
@@ -4715,6 +4718,13 @@
     default:
         fatal("Bad arg 1 to to_array(): type %s\n", typename(sp->type));
         break;
+#ifdef BAT
+    case T_NUMBER:
+      if(sp->type == T_NUMBER && sp->u.number == 0)
+        {
+          break;
+        }
+#endif
     case T_STRING:
     case T_SYMBOL:
         /* Split the string into an array of ints */
@@ -4797,7 +4807,11 @@
         return sp;
 
     case T_STRING:
+#ifdef BAT
+        o = get_object(sp->u.str);
+#else
         o = find_object(sp->u.str);
+#endif
         free_svalue(sp);
         break;
     }
Only in ldmud-20011215/src: frame.c
Only in ldmud-20011215/src: frame.h
diff -r -u ld33/src/func_spec ldmud-20011215/src/func_spec
--- ld33/src/func_spec	Tue Nov 27 08:50:42 2001
+++ ldmud-20011215/src/func_spec	Thu Dec 20 09:51:18 2001
@@ -68,6 +68,9 @@
         parse_command
 #endif
         local
+#ifdef BAT
+        catch_write
+#endif
         catch
         catch_no_log
 "++"    inc
@@ -133,6 +136,9 @@
  * called from LPC.
  */
 
+#ifdef BAT
+        end_catch_write
+#endif
         pop_value
         dup
         clear_locals
@@ -253,6 +259,9 @@
 
         /* Functions and Closures */
 
+#ifdef BAT
+unknown call_shadow(object|string|object *|string *, string, ...);
+#endif
 unknown call_other(object|string|object *|string *, string, ...);
 unknown call_direct(object|string|object *|string *, string, ...);
           /* The lexer switches the return type between 'unknown'
@@ -307,7 +316,11 @@
 int     to_int(int|string|float|closure);
 float   to_float(float|string|int);
 string  to_string(mixed);
+#ifdef BAT
+int    *to_array(string|mixed*|symbol|quoted_array|null);
+#else
 int    *to_array(string|mixed*|symbol|quoted_array);
+#endif
 object  to_object(null|object|string|closure);
 
 mixed   copy(mixed);
@@ -626,4 +639,28 @@
 #endif /* USE_MYSQL */
 
 
+        /* Bat specific efuns */
+
+#ifdef BAT
+int     count_objects(object|string, void|int);
+int     count_lines(string);
+object  first_object(object|string, void|int);
+object  next_object(object, void|int);
+object  *all_objects(object|string, void|int);
+object  *all_shadow(object default: F_THIS_OBJECT);
+object  first_shadow(object default: F_THIS_OBJECT);
+object  last_shadow(object default: F_THIS_OBJECT);
+object  next_shadow(object default: F_THIS_OBJECT);
+string  line_wrap(string, void|null|string, void|null|string, void|int);
+string  nuke_controls(string);
+string  query_input_to(object default: F_THIS_OBJECT);
+int	push_line(string);
+
+int     profil_enable (int);
+int     profil_reset ();
+string  profil_query_results (int,int);
+
+/* mixed *erusage(int); */
+
+#endif
 /***************************************************************************/
diff -r -u ld33/src/interpret.c ldmud-20011215/src/interpret.c
--- ld33/src/interpret.c	Wed Dec 19 08:44:11 2001
+++ ldmud-20011215/src/interpret.c	Thu Dec 20 09:51:18 2001
@@ -225,6 +225,9 @@
 #include "switch.h"
 #include "wiz_list.h"
 #include "xalloc.h"
+#ifdef BAT
+#include "bat.h"
+#endif
 
 #include "../mudlib/sys/driver_hook.h"
 #include "../mudlib/sys/debug_info.h"
@@ -285,8 +288,17 @@
     int variable_index_offset;
       /* Function and variable index offset.
        */
+
+#ifdef BAT
+    char *class_name_for_this_function; /* true class in which this 
+					 * was defined
+					 */
+#endif
+
 };
 
+
+
 /*-------------------------------------------------------------------------*/
 /* Macros */
 
@@ -668,7 +680,11 @@
 /* Forward declarations */
 
 enum { APPLY_NOT_FOUND = 0, APPLY_FOUND, APPLY_DEFAULT_FOUND };
+#ifdef BAT
+static int int_apply(string_t *, object_t *, int, Bool, Bool, Bool);
+#else
 static int int_apply(string_t *, object_t *, int, Bool, Bool);
+#endif
 static void call_simul_efun(int code, object_t *ob, int num_arg);
 #ifdef DEBUG
 static void check_extra_ref_in_vector(svalue_t *svp, size_t num);
@@ -2669,11 +2685,24 @@
                    ));
             return NULL;
         }
+#ifdef BAT
+	ind = i->u.number;
+	if(ind < 0)
+	  ind = VEC_SIZE(vec->u.vec) + ind;
+
+        if (ind < 0)
+        {
+            ERRORF(("Index out of bounds for []: %ld, vector size: %lu.\n"
+                   , (long)ind, VEC_SIZE(vec->u.vec)));
+            return NULL;
+        }
+#else
         if ((ind = i->u.number) < 0)
         {
             ERROR("Illegal index for []: not a positive number.\n");
             return NULL;
         }
+#endif
         if ((size_t)ind >= VEC_SIZE(vec->u.vec))
         {
             ERRORF(("Index out of bounds for []: %ld, vector size: %lu.\n"
@@ -2940,11 +2969,24 @@
                    ));
             return NULL;
         }
+#ifdef BAT
+	ind = i->u.number;
+	if(ind < 0)
+	  ind = VEC_SIZE(vec->u.vec) + ind;
+
+        if (ind < 0)
+        {
+            ERRORF(("Index out of bounds for []: %ld, vector size: %lu.\n"
+                   , (long)ind, VEC_SIZE(vec->u.vec)));
+            return NULL;
+        }
+#else
         if ((ind = i->u.number) < 0)
         {
             ERROR("Illegal index for []: not a positive number.\n");
             return NULL;
         }
+#endif
 
         if ((size_t)ind >= VEC_SIZE(vec->u.vec))
         {
@@ -3260,11 +3302,24 @@
                    ));
             return NULL;
         }
+#ifdef BAT
+	ind = i->u.number;
+	if(ind < 0)
+	  ind = VEC_SIZE(v) + ind;
+
+        if (ind < 0)
+        {
+            ERRORF(("Index out of bounds for []: %ld, vector size: %lu.\n"
+                   , (long)ind, VEC_SIZE(vec->u.vec)));
+            return NULL;
+        }
+#else
         if ((ind = i->u.number) < 0)
         {
             ERROR("Illegal index for []: not a positive number.\n");
             return NULL;
         }
+#endif
 
         if ((size_t)ind >= VEC_SIZE(v))
         {
@@ -3293,11 +3348,24 @@
                    ));
             return NULL;
         }
+#ifdef BAT
+	ind = i->u.number;
+	if(ind < 0)
+	  ind = mstrsize(vec->u.str) + ind;
+
+        if (ind < 0)
+        {
+            ERRORF(("Index for [] out of bounds: %ld, string length: %ld.\n"
+                   , (long)ind, (long)mstrsize(vec->u.str)));
+            return NULL;
+        }
+#else
         if ((ind = i->u.number) < 0)
         {
             ERROR("Illegal index for []: not a positive number.\n");
             return NULL;
         }
+#endif
 
         if (ind >= mstrsize(vec->u.str) )
         {
@@ -3630,11 +3698,24 @@
                        ));
                 return NULL;
             }
+#ifdef BAT
+	    ind = i->u.number;
+	    if(ind < 0)
+	      ind = VEC_SIZE(v) + ind;
+
+            if (ind < 0)
+            {
+                ERRORF(("Index out of bounds for []: %ld, vector size: %lu.\n"
+                       , (long)ind, VEC_SIZE(vec->u.vec)));
+                return NULL;
+            }
+#else
             if ((ind = i->u.number) < 0)
             {
                 ERROR("Illegal index for []: not a positive number.\n");
                 return NULL;
             }
+#endif
 
             if ((size_t)ind >= VEC_SIZE(v))
             {
@@ -3672,11 +3753,24 @@
                        ));
                 return NULL;
             }
+#ifdef BAT
+	    ind = i->u.number;
+	    if(ind < 0)
+	      ind = mstrsize(vec->u.str) + ind;
+
+            if (ind < 0)
+            {
+                ERRORF(("Index for [] out of bounds: %ld, string length: %ld.\n"
+                       , (long)ind, (long)mstrsize(vec->u.str)));
+                return NULL;
+            }
+#else
             if ((ind = i->u.number) < 0)
             {
                 ERROR("Illegal index for []: not a positive number.\n");
                 return NULL;
             }
+#endif
 
             if (ind > mstrsize(vec->u.str) )
             {
@@ -3805,11 +3899,24 @@
                        ));
                 return NULL;
             }
+#ifdef BAT
+	    ind = i->u.number;
+	    if(ind < 0)
+	      ind = mstrsize(vec->u.str) + ind;
+
+            if (ind < 0)
+            {
+                ERRORF(("Index for [] out of bounds: %ld, string length: %ld.\n"
+                       , (long)ind, (long)mstrsize(vec->u.str)));
+                return NULL;
+            }
+#else
             if ((ind = i->u.number) < 0)
             {
                 ERROR("Illegal index for []: not a positive number.\n");
                 return NULL;
             }
+#endif
 
             if (ind > mstrsize(vec->u.str) )
             {
@@ -4743,11 +4850,23 @@
                    ));
             return NULL;
         }
+#ifdef BAT
+	ind = i->u.number;
+	if(ind < 0)
+	  ind = mstrsize(vec->u.str) + ind;
+
+        if (ind < 0)
+        {
+            error("Index for [] out of bounds: %ld, string size: %ld.\n"
+                 , (long)ind, (long)mstrsize(vec->u.str));
+        }
+#else
         if ((ind = i->u.number) < 0)
         {
             ERROR("Illegal index for []: not a positive number.\n");
             return NULL;
         }
+#endif
 
         /* Index the string */
         if (ind > mstrsize(vec->u.str))
@@ -4776,11 +4895,24 @@
                    ));
             return NULL;
         }
+#ifdef BAT
+	ind = i->u.number;
+	if(ind < 0)
+	  ind = VEC_SIZE(vec->u.vec) + ind;
+
+        if (ind < 0)
+        {
+            ERRORF(("Index for [] out of bounds: %ld, vector size: %lu\n"
+                   , (long)ind, VEC_SIZE(vec->u.vec)));
+	    return NULL;
+        }
+#else
         if ((ind = i->u.number) < 0)
         {
             ERROR("Illegal index for []: not a positive number.\n");
             return NULL;
         }
+#endif
 
         /* Drop the arguments */
         sp = vec; /* == sp-1 */
@@ -6886,6 +7018,9 @@
     if (instrs[instruction].min_arg != instrs[instruction].max_arg
      && instruction != F_CALL_OTHER
      && instruction != F_CALL_DIRECT
+#ifdef BAT
+     && instruction != F_CALL_SHADOW
+#endif
        )
     {
         num_arg = GET_UINT8(pc);
@@ -8145,6 +8280,16 @@
         inter_sp = sp;
         inter_pc = pc;
         arg = sp - num_arg + 1;
+#ifdef BAT
+	/* stupid zero check */
+	if(arg[0].type == T_NUMBER && arg[0].u.number == 0)
+	  {
+	    pop_n_elems(num_arg-1);
+	    free_svalue(sp);
+	    put_number(sp, 0);
+	    break;
+	  }
+#endif
         if (arg[0].type != T_STRING)
             BAD_ARG_ERROR(1, T_STRING, arg[0].type);
         if (arg[1].type != T_STRING)
@@ -8282,6 +8427,30 @@
         break;
     }
 
+#ifdef BAT
+    CASE(F_CATCH_WRITE);
+    {
+        begin_catch_write();
+        break;
+    }
+
+    CASE(F_END_CATCH_WRITE);
+    {
+        char *tmpStr = end_catch_write();
+        sp--;
+
+        if(tmpStr)
+          {
+            string_t *new = new_mstring(tmpStr);
+            push_string(sp, new);
+          }
+        else
+            push_number(sp, 0);
+
+        break;
+    }
+#endif
+
     CASE(F_INC);                    /* --- inc                 --- */
     {
         /* void inc (mixed & sp[0])
@@ -14130,6 +14299,9 @@
 
     CASE(F_CALL_DIRECT);            /* --- call_direct         --- */
     CASE(F_CALL_OTHER);             /* --- call_other          --- */
+#ifdef BAT
+    CASE(F_CALL_SHADOW);
+#endif
     {
         /* EFUN call_other(), call_direct()
          *
@@ -14223,7 +14395,12 @@
 
             /* Call the function with the remaining args on the stack.
              */
+#ifdef BAT
+            if (!int_apply(arg[1].u.str, ob, num_arg-2, MY_FALSE, b_use_default, 
+			   instruction == F_CALL_SHADOW ? MY_TRUE : MY_FALSE))
+#else
             if (!int_apply(arg[1].u.str, ob, num_arg-2, MY_FALSE, b_use_default))
+#endif
             {
                 /* Function not found */
                 if (b_use_default) /* int_apply() removed the args */
@@ -14343,7 +14520,12 @@
                 /* Call the function with the remaining args on the stack.
                  */
                 inter_sp = sp; /* update to new setting */
+#ifdef BAT
+                if (!int_apply(arg[1].u.str, ob, num_arg-2, MY_FALSE, b_use_default,
+			       instruction == F_CALL_SHADOW ? MY_TRUE : MY_FALSE))
+#else
                 if (!int_apply(arg[1].u.str, ob, num_arg-2, MY_FALSE, b_use_default))
+#endif
                 {
                     /* Function not found, Assign 0 as result.
                      */
@@ -14572,8 +14754,36 @@
 } /* eval_instruction() */
 
 /*-------------------------------------------------------------------------*/
+
+#ifdef BAT
+
+/* dura */
+char* 
+find_function_name (unsigned int fx, program_t *prog)
+{
+  unsigned int inh;
+  char *p;
+
+  for (inh= 0; inh < prog->num_inherited; inh++)
+    if (prog->inherit [inh].function_index_offset >= fx &&
+	(p= find_function_name (fx- prog->inherit [inh].function_index_offset,
+				prog->inherit [inh].prog)) )
+      return p;
+  
+  if (fx >= prog->num_functions)
+    return NULL;
+  else
+    return prog->name->str->txt;
+}
+
+#endif
+
 static Bool
+#ifdef BAT
+apply_low (string_t *fun, object_t *ob, int num_arg, Bool b_ign_prot, Bool b_ign_shadows)
+#else
 apply_low (string_t *fun, object_t *ob, int num_arg, Bool b_ign_prot)
+#endif
 
 /* The low-level implementation of function calls.
  *
@@ -14616,7 +14826,11 @@
     /* If there is a chain of objects shadowing, start with the first
      * of these.
      */
+#ifdef BAT
+    if (!b_ign_shadows && (ob->flags & O_SHADOW))
+#else
     if (ob->flags & O_SHADOW)
+#endif
     {
         object_t *shadow;
 
@@ -14691,6 +14905,11 @@
              * where.
              */
             fun_hdr_p funstart;
+#ifdef BAT
+	    profil_sample_t sample;
+
+	    memset (&sample, 0, sizeof (sample));
+#endif
 
             push_control_stack(inter_sp, inter_pc, inter_fp);
             csp->ob = current_object;
@@ -14714,7 +14933,25 @@
             previous_ob = current_object;
             current_object = ob;
             save_csp = csp;
+
+#ifdef BAT
+	    if (profil_is_enabled ())
+	      profil_start_sample (&sample);
+#endif
+
             eval_instruction(FUNCTION_CODE(funstart), inter_sp);
+
+#ifdef BAT
+	    if (profil_is_enabled () && sample.c [1])
+		  {
+		    profil_end_sample (&sample);
+
+		    profil_register_sample (
+					    cache [ix].class_name_for_this_function,
+					    fun->str->txt,
+					    &sample, NULL, 1);
+		  }
+#endif
 #ifdef DEBUG
             if (save_csp-1 != csp)
                 fatal("Bad csp after execution in apply_low\n");
@@ -14740,6 +14977,10 @@
         if ( NULL != fun)
         {
             int fx;
+#ifdef BAT
+	    profil_sample_t sample;
+	    memset (&sample, 0, sizeof (sample));
+#endif
 
             /* Yup, fun is a function _somewhere_ */
 
@@ -14791,6 +15032,25 @@
                 cache[ix].flags = progp->functions[fx]
                                   & (TYPE_MOD_STATIC|TYPE_MOD_PROTECTED);
 
+#ifdef BAT
+
+		{
+		  
+		  profil_sample_t sample2;
+		  memset (&sample2, 0, sizeof (sample2));
+
+		  profil_start_sample (&sample2);
+
+		  cache [ix].class_name_for_this_function=
+		    find_function_name (fx, progp);
+		  
+		  profil_end_sample (&sample2);
+		  
+		  profil_register_sample ("overhead2", "",
+					  &sample2, NULL, 1);
+		}
+#endif
+
                 /* Static functions may not be called from outside,
                  * Protected functions not even from the inside.
                  */
@@ -14805,7 +15065,12 @@
                     previous_ob = csp->prev_ob;
                     current_object = csp->ob;
                     pop_control_stack();
+#ifdef BAT
+                    if (!b_ign_shadows && 
+			(ob->flags & O_SHADOW && O_GET_SHADOW(ob)->shadowing))
+#else
                     if (ob->flags & O_SHADOW && O_GET_SHADOW(ob)->shadowing)
+#endif
                     {
                         /* This is an object shadowing another. The function
                          * was not found, but can maybe be found in the object
@@ -14822,7 +15087,26 @@
                 previous_ob = current_object;
                 current_object = ob;
                 save_csp = csp;
+
+#ifdef BAT
+		if (profil_is_enabled ())
+		  profil_start_sample (&sample);
+#endif
+
                 eval_instruction(FUNCTION_CODE(funstart), inter_sp);
+
+#ifdef BAT
+		if (profil_is_enabled () && sample.c[1])
+		  {
+		    profil_end_sample (&sample);
+
+		    profil_register_sample (
+					    cache [ix].class_name_for_this_function,
+					    fun->str->txt,
+					    &sample, NULL, 1);
+		  }
+#endif
+
 #ifdef DEBUG
                 if (save_csp-1 != csp)
                     fatal("Bad csp after execution in apply_low\n");
@@ -14849,7 +15133,12 @@
      * shadowed object.
      */
 
+#ifdef BAT
+    if (!b_ign_shadows && 
+	(ob->flags & O_SHADOW && O_GET_SHADOW(ob)->shadowing))
+#else
     if (ob->flags & O_SHADOW && O_GET_SHADOW(ob)->shadowing)
+#endif
     {
         ob = O_GET_SHADOW(ob)->shadowing;
         goto retry_for_shadow;
@@ -14867,7 +15156,11 @@
 /*-------------------------------------------------------------------------*/
 static int
 int_apply (string_t *fun, object_t *ob, int num_arg
+#ifdef BAT
+	   , Bool b_ign_prot, Bool b_use_default, Bool b_ign_shadows
+#else
           , Bool b_ign_prot, Bool b_use_default
+#endif
           )
 /* The wrapper around apply_low() to handle default methods.
  *
@@ -14899,7 +15192,11 @@
  */
 
 {
+#ifdef BAT
+    if (apply_low(fun, ob, num_arg, b_ign_prot, b_ign_shadows))
+#else
     if (apply_low(fun, ob, num_arg, b_ign_prot))
+#endif
         return APPLY_FOUND;
 
     if (b_use_default)
@@ -14941,7 +15238,11 @@
             /* Call the function */
             if (hook->type == T_STRING)
             {
+#ifdef BAT
+                rc = apply_low(hook->u.str, ob, num_arg+num_extra, b_ign_prot, b_ign_shadows);
+#else
                 rc = apply_low(hook->u.str, ob, num_arg+num_extra, b_ign_prot);
+#endif
             }
             else /* hook->type == T_CLOSURE */
             {
@@ -15060,7 +15361,11 @@
 #endif
 
     /* Do the call */
+#ifdef BAT
+    if (!int_apply(fun, ob, num_arg, b_find_static, b_use_default, MY_FALSE))
+#else
     if (!int_apply(fun, ob, num_arg, b_find_static, b_use_default))
+#endif
     {
         if (!b_use_default) /* int_apply() did not clean up the stack */
             inter_sp = _pop_n_elems(num_arg, inter_sp);
@@ -16048,7 +16353,11 @@
     function_name = simul_efunp[code].name;
 
     /* First, try calling the function in the given object */
+#ifdef BAT
+    if (!int_apply(function_name, ob, num_arg, MY_FALSE, MY_FALSE, MY_FALSE))
+#else
     if (!int_apply(function_name, ob, num_arg, MY_FALSE, MY_FALSE))
+#endif
     {
         /* Function not found: try the alternative sefun objects */
         if (simul_efun_vector)
@@ -16066,7 +16375,11 @@
                 }
                 if ( !(ob = get_object(v->u.str)) )
                     continue;
+#ifdef BAT
+                if (int_apply(function_name, ob, num_arg, MY_FALSE, MY_FALSE, MY_FALSE))
+#else
                 if (int_apply(function_name, ob, num_arg, MY_FALSE, MY_FALSE))
+#endif
                     return;
             }
             return;
@@ -18161,7 +18474,11 @@
      */
     if (ob == master_ob)
         b_use_default = MY_FALSE;
+#ifdef BAT
+    rc = int_apply(arg[2].u.str, ob, num_arg-3, MY_FALSE, b_use_default, MY_FALSE);
+#else
     rc = int_apply(arg[2].u.str, ob, num_arg-3, MY_FALSE, b_use_default);
+#endif
     if (rc == APPLY_NOT_FOUND)
     {
         /* Function not found */
diff -r -u ld33/src/lex.c ldmud-20011215/src/lex.c
--- ld33/src/lex.c	Wed Dec 12 10:42:29 2001
+++ ldmud-20011215/src/lex.c	Thu Dec 20 09:51:18 2001
@@ -416,6 +416,9 @@
  = { { "break",          L_BREAK         }
    , { "case",           L_CASE          }
    , { "catch",          L_CATCH         }
+#ifdef BAT
+   , { "catch_write",    L_CATCH_WRITE   }
+#endif
    , { "closure",        L_CLOSURE_DECL  }
    , { "continue",       L_CONTINUE      }
    , { "default",        L_DEFAULT       }
@@ -3644,6 +3647,12 @@
                         case L_PARSE_COMMAND:
                             code = F_PARSE_COMMAND  + CLOSURE_EFUN_OFFS;
                             break;
+#endif
+
+#ifdef BAT
+			case L_CATCH_WRITE:
+			  code = F_CATCH_WRITE + CLOSURE_EFUN_OFFS;
+			  break;
 #endif
                         case L_SSCANF:
                             code = F_SSCANF  + CLOSURE_EFUN_OFFS;
diff -r -u ld33/src/main.c ldmud-20011215/src/main.c
--- ld33/src/main.c	Wed Dec 19 08:44:11 2001
+++ ldmud-20011215/src/main.c	Thu Dec 20 09:51:18 2001
@@ -61,6 +61,11 @@
 #include "wiz_list.h"
 #include "xalloc.h"
 
+#ifdef BAT
+#include "bat.h"
+#include "frame.h"
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 #define PLAIN_MASTER "secure/master"
@@ -397,6 +402,16 @@
     initialize_host_ip_number();
 
     (void)signal(SIGFPE, SIG_IGN);
+
+#ifdef BAT
+    /* frame.c ++Jam */
+    init_bug_handler();
+    //    init_signal(SIGSEGV, 1);
+    //    init_signal(SIGBUS, 1);
+    /* init_signal(SIGFPE, 1); */
+    init_signal(SIGXCPU, 3);
+#endif
+
     current_object = &dummy_current_object_for_loads;
     if (setjmp(toplevel_context.con.text)) {
         clear_state();
@@ -1024,6 +1039,10 @@
   else
       fputs(LONG_VERSION, stdout);
 
+#ifdef BAT
+  fputs(" (BatMud edition)", stdout);
+#endif
+
   fputs(LOCAL_LEVEL " - a LPMud Game Driver.\n"
         "\nRelease:  " PROJ_VERSION "; " RELEASE_DATE
         "\nCompiled: " __DATE__
@@ -1032,6 +1051,7 @@
 #endif
         "\n"
        , stdout);
+
 } /* version() */
 
 /*-------------------------------------------------------------------------*/
diff -r -u ld33/src/mstrings.c ldmud-20011215/src/mstrings.c
--- ld33/src/mstrings.c	Mon Jun 11 09:12:04 2001
+++ ldmud-20011215/src/mstrings.c	Thu Dec 20 09:51:18 2001
@@ -800,8 +800,19 @@
                  );
         }
         stringtable[idx] = s->link;
+
+#ifdef BAT
+	if(mstrsize(s) > 0)
+	  s->str->txt[0] = 'I';
+#endif
+
         xfree(s->str);
-        xfree(s);
+
+#ifdef BAT
+	s->str = 0;
+#endif
+	    xfree(s);
+
     }
     else if (s->link == NULL)
     {
@@ -810,7 +821,16 @@
         mstr_untabled--;
         mstr_untabled_size -= msize;
 
-        xfree(s->str);
+#ifdef BAT
+	if(mstrsize(s) > 0)
+	  s->str->txt[0] = 'I';
+#endif
+
+	    xfree(s->str);
+
+#ifdef BAT
+		s->str = 0;
+#endif
         xfree(s);
     }
     else
Only in ldmud-20011215/src: profil2.c
Only in ldmud-20011215/src: profil2.h
diff -r -u ld33/src/prolang.y ldmud-20011215/src/prolang.y
--- ld33/src/prolang.y	Tue Dec  4 17:20:39 2001
+++ ldmud-20011215/src/prolang.y	Thu Dec 20 09:51:18 2001
@@ -2755,6 +2755,11 @@
 %token L_BREAK
 %token L_CASE
 %token L_CATCH
+
+%ifdef BAT
+%token L_CATCH_WRITE
+%endif
+
 %token L_CLOSURE
 %token L_CLOSURE_DECL
 %token L_COLON_COLON
@@ -3016,6 +3021,11 @@
 %type <lrvalue>      note_start comma_expr expr0 expr4
 %type <lrvalue>      function_call inline_fun
 %type <lrvalue>      catch sscanf
+
+%ifdef BAT
+%type <lrvalue>      catch_write
+%endif
+
 %type <lrvalue>      for_init_expr for_expr
 %type <lrvalue>      comma_expr_decl expr_decl
 %ifdef SUPPLY_PARSE_COMMAND
@@ -3149,6 +3159,10 @@
           if ($1 & TYPE_MOD_MASK)
           {
               exact_types = $2;
+#ifdef BAT
+              if (pragma_strict_types == PRAGMA_WEAK_TYPES)
+                exact_types = 0;
+#endif
           }
           else
           {
@@ -6466,15 +6480,27 @@
       {
           $$ = $2;
           $$.type = $1;
+#ifdef BAT
+          if ($2.type != TYPE_UNKNOWN
+           && $1 != TYPE_VOID)
+#else
           if ($2.type != TYPE_ANY
            && $2.type != TYPE_UNKNOWN
            && $1 != TYPE_VOID
            && $1 != $2.type
              )
+#endif
           {
               switch($1)
               {
               default:
+#ifdef BAT
+                if($1 & TYPE_MOD_POINTER)
+                  {
+                    ins_f_code(F_TO_ARRAY);
+                    break;
+                  }
+#endif
                   type_error("Illegal cast", $1);
                   break;
               case TYPE_ANY:
@@ -6495,6 +6521,11 @@
               case TYPE_NUMBER|TYPE_MOD_POINTER:
                   ins_f_code(F_TO_ARRAY);
                   break;
+#ifdef BAT
+              case TYPE_MAPPING:
+                /* fall through. hope it works */
+                break;
+#endif
               }
           }
       }
@@ -6879,6 +6910,9 @@
 %ifdef SUPPLY_PARSE_COMMAND
     | parse_command  %prec '~'
 %endif /* SUPPLY_PARSE_COMMAND */
+%ifdef BAT
+    | catch_write    %prec '~'
+%endif
 
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     | L_STRING
@@ -7930,7 +7964,11 @@
 
           /* Return the data */
 
+#ifdef BAT
+          $$.inst  = F_AA_RANGE;
+#else
           $$.inst  = F_RANGE;
+#endif
           $$.start = $3.start;
           $$.end   = $3.end;
           $$.type1 = TYPE_NUMBER;
@@ -8008,7 +8046,11 @@
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     | '['     expr0 L_RANGE     expr0 ']'
       {
+#ifdef BAT
+          $$.inst  = F_AA_RANGE;
+#else
           $$.inst  = F_RANGE;
+#endif
           $$.start = $2.start;
           $$.end   = $4.end;
           $$.type1 = $2.type;
@@ -8098,7 +8140,11 @@
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     | '['     expr0 L_RANGE           ']'
       {
+#ifdef BAT
+          $$.inst  = F_AX_RANGE;
+#else
           $$.inst  = F_NX_RANGE;
+#endif
           $$.start = $2.start;
           $$.end   = $2.end;
           $$.type1 = $2.type;
@@ -9436,6 +9482,28 @@
       }
 ; /* opt_catch_mods */
 
+%ifdef BAT
+/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
+/* catch_write()
+ *
+ */
+catch_write:
+      L_CATCH_WRITE
+{
+  $<number>$ = CURRENT_PROGRAM_SIZE;
+  ins_byte(F_CATCH_WRITE);
+  /*  ins_byte(0); */
+}
+'(' comma_expr ')'
+{
+%line
+   ins_f_code(F_END_CATCH_WRITE);
+
+ $$.start = $<number>2;
+ $$.type  = TYPE_STRING;
+ $$.code = -1;
+};
+%endif
 
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
 /* sscanf() and parse_command()
diff -r -u ld33/src/settings/bat ldmud-20011215/src/settings/bat
--- ld33/src/settings/bat	Wed Dec 19 08:44:11 2001
+++ ldmud-20011215/src/settings/bat	Thu Dec 20 09:51:18 2001
@@ -20,7 +20,7 @@
 with_master_name=secure/master
 with_input_escape="@"
 
-enable_erq=erq
+enable_erq=xerq
 enable_use_mysql=1
 
 enable_supply_parse_command=0
diff -r -u ld33/src/string_spec ldmud-20011215/src/string_spec
--- ld33/src/string_spec	Fri Jul 27 10:51:16 2001
+++ ldmud-20011215/src/string_spec	Thu Dec 20 09:51:18 2001
@@ -89,6 +89,9 @@
 TAIL               "tail"
 WRITE_BYTES        "write_bytes"
 WRITE_FILE         "write_file"
+#ifdef BAT
+COUNT_LINES        "count_lines"
+#endif
 
     /* Object lfuns */
 
diff -r -u ld33/src/util/erq/erq.c ldmud-20011215/src/util/erq/erq.c
--- ld33/src/util/erq/erq.c	Fri Oct 12 16:16:28 2001
+++ ldmud-20011215/src/util/erq/erq.c	Thu Dec 20 09:51:18 2001
@@ -830,7 +830,12 @@
     childs_waited_for = 0;
 
     /* possible race conditions make switching the signal handler awkward */
+
+#ifdef linux
+    signal (SIGCHLD, SIG_IGN);
+#else
     (void)signal(SIGCLD, (RETSIGTYPE(*)())count_sigcld);
+#endif
 
     for (;;) /* The Loop (tm) */
     {
diff -r -u ld33/src/util/xerq/erq.c ldmud-20011215/src/util/xerq/erq.c
--- ld33/src/util/xerq/erq.c	Fri Oct 12 16:16:28 2001
+++ ldmud-20011215/src/util/xerq/erq.c	Thu Dec 20 09:51:18 2001
@@ -11,6 +11,8 @@
  *---------------------------------------------------------------------------
  */
 
+#include <locale.h>
+
 #include "defs.h"
 
 #include "random.c" /* Compile the driver's random module */
@@ -150,6 +152,8 @@
 {
     int num;
 
+    setlocale(LC_ALL, "");
+
     master_pid = getpid();
 
     /* Quick and dirty commandline parser */
@@ -198,7 +202,20 @@
     in_select = 0;
     pending_sig = 0;
 
+#if 1
+    {
+      struct sigaction act;
+      
+      memset (&act, 0, sizeof (act));
+      act.sa_handler= sig_child;
+      act.sa_flags= 0;
+
+      sigaction (SIGCLD, &act, NULL);
+    }
+#else
     signal(SIGCLD, sig_child);
+#endif
+
     signal(SIGPIPE, SIG_IGN);
 
     sockets = NULL;
@@ -516,56 +533,64 @@
     pid_t pid;
     struct child_s *chp;
 
-    pid = wait(&status);
+    for (;;)
+      {
+	pid= waitpid ( (pid_t) -1, &status, WNOHANG);
+
+	if (pid== 0 || pid== (pid_t) -1)
+	  break;
 
+	// pid = wait(&status);
+	
 #ifdef DEBUG
-    fprintf(stderr, "%s [sigchild] pid=%d status=%d\n"
-                  , time_stamp(), pid, status);
+	fprintf(stderr, "%s [sigchild] pid=%d status=%d\n"
+		, time_stamp(), pid, status);
 #endif
-
-    /* Look for the child and mark it as exited */
-    for (chp = childs; chp; chp = chp->next)
-    {
-        if (chp->pid != pid)
-            continue;
-
-        chp->status = CHILD_EXITED;
-        chp->return_code = status;
+	
+	/* Look for the child and mark it as exited */
+	for (chp = childs; chp; chp = chp->next)
+	  {
+	    if (chp->pid != pid)
+	      continue;
+	    
+	    chp->status = CHILD_EXITED;
+	    chp->return_code = status;
 #ifdef DEBUG
-        fprintf(stderr, "%s [sigchild] Caught SIGCLD for pid %d, child %p.\n"
-                      , time_stamp(), pid, chp);
+	    fprintf(stderr, "%s [sigchild] Caught SIGCLD for pid %d, child %p.\n"
+		    , time_stamp(), pid, chp);
 #endif
-        if (in_select)
-            remove_child(chp); /* safe to do it from here */
-        /*  if we're in select, we know we're not going to be messing up
-            the main loop with stuff we're doing here */
-        break;
-    }
-
-    if (!chp)
-    {
-        /* There is no valid child. Maybe we caught the signal before
-         * the child structure was complete (this can happen especially
-         * with short-lived CHILD_FORK sub processes).
-         */
-        if (pending_sig)
-        {
-            fprintf(stderr, "%s [sigchild] SIGCLD for pid %d not delivered.\n"
-                          , time_stamp(), pending_pid);
-        }
-
+	    if (in_select)
+	      remove_child(chp); /* safe to do it from here */
+	    /*  if we're in select, we know we're not going to be messing up
+		the main loop with stuff we're doing here */
+	    break;
+	  }
+	
+	if (!chp)
+	  {
+	    /* There is no valid child. Maybe we caught the signal before
+	     * the child structure was complete (this can happen especially
+	     * with short-lived CHILD_FORK sub processes).
+	     */
+	    if (pending_sig)
+	      {
+		fprintf(stderr, "%s [sigchild] SIGCLD for pid %d not delivered.\n"
+			, time_stamp(), pending_pid);
+	      }
+	    
 #ifdef DEBUG
-        fprintf(stderr, "%s [sigchild] SIGCLD for unknown pid %d received.\n"
-                      , time_stamp(), pid);
+	    fprintf(stderr, "%s [sigchild] SIGCLD for unknown pid %d received.\n"
+		    , time_stamp(), pid);
 #endif
-
-        pending_status = status;
-        pending_pid = pid;
-        pending_sig = 1;
-    }
-
-    /* Restore the signal handler */
-    signal(SIGCLD, sig_child);
+	    
+	    pending_status = status;
+	    pending_pid = pid;
+	    pending_sig = 1;
+	  }
+	
+      }
+	/* Restore the signal handler */
+	// signal(SIGCLD, sig_child);
 } /* sig_child() */
 
 /*-------------------------------------------------------------------------*/
