Short: PCRE Implementation Notes
Date: 2002-03-27
From: Lars
Type: Memo
See: f-010406-0

 - Teach ed() the PCRE options in PERL modifier syntax
 - Document the regexp patterns and options in a (C) manpage.
 - Since PCRE returns error codes, regexp.[ch] might do it as well.
 - Make PCRE the config default, explicitely turn it off for the given
     muds.
 - Detect an existing libpcre, and if its newer, allow to switch
     between the system lib and the included one.
 - Add modifier '?' to old regexp code.

---------------------------------------------------------------------------
( A copy of those parts of f-010406-0 which still need consideration)

Btw kann man den (nichtdeterministischen) Automaten mit einer Zeile in die
ewigen Jagdgruende schicken ('regular expressions' von oreilly entnommen):

 regexp(({"=XX============================================"}), "X(.+)+X")

Eventuell sollte man in dem FA halt einfach jedem Backtracking eine
eval-cost zuordnen um das zu verhindern (die Laufzeit des Matchens oben
ist propotional pow(2, strlen)). Das waere zB moeglich bei Zeile 1158 des
regexp.c:
                        return MY_TRUE;
                /* Couldn't or didn't -- back up. */
                no--;
+               evals += 5;
+               if (evals > evals_max) regerror("too many backtracks");
                reginput = save + no;
            }

(mit evals und evals_max symbolisch fuer die Kosten). Ich schlage gerade
vor genau DAS als Kriterium zu nehmen, weil das ziemlich sicher soetwas
unendliches erkennt, alles andere kann auch 'viel' werden, aber da kanns
trotzdem gleich fertig sein.

Btw PCRE kann man (selbstverstaendlich) mit derselben Regex von
letztens in eine 'unendliche' Schleife schicken. Wie man dort dann
nachtraeglich Evalkosten pro Backtrack einbaut *gruebel*...
Uebrigens ist der Pcre-Automat etwa doppelt so schnell bei der Schleife,
20 '=' nach den XX dauern bei mir 2 bzw 4 Sekunden.
---------------------------------------------------------------------------

Die komplette Umstellung birgt aber ein paar Inkompatibilitaeten:

*  \< und \> sind nicht vorhanden. Eventuell kann man diese durch
   \b (word boundary) ersetzen. Emulieren waere moeglich mit \W\b
   sowie \b\W

*  ( und ) werden wie im 'normalen' Modus behandelt, excompat muss
   emuliert werden (verwendet nur regreplace, ed)

Wie arbeitet der Driver mit Multilines?
   ^      matcht Stringanfang
   $      matcht Stringende; matcht nicht auf \n vor Stringende
   .      matcht \n; matcht nicht Stringende
   [^x]   matcht auf \n

Dies entspricht etwa /s bei Perl und
PCRE_DOLLAR_ENDONLY | PCRE_DOTALL bei Pcre

----------------------------------------------------------------------------
