Subject: Re: catch() / evalcost
From: Michael Sporn <sporn@mathematik.hu-berlin.de>
Date: Fri, 12 Mar 1999 16:56:55 +0100 (MET)
Type: Feature
State: Unclassified

 Hmm, netter Ausdruck, ich hab noch mal ueber die Sache nachgedacht und
 gemerkt, dass meine Aeusserungen auch nich so ganz astrein waren ;). Selbst
 bei unsigned is naemlich a+x-x==a, egal, wie gross x is. Das heisst, das
 Problem kam daher, dass der interpreter ohne assign_eval_cost() zu einem
 anderen objekt gewechselt is. Ich bin mal die instructions durchgegangen und
 fand, dass das bei apply() und funcall() auf closures anderer objekte
 passiert. In den mapping-iterier-funktionen wird die eval_cost wohl auch
 ignoriert (dann in call_lambda() bzw. apply()). Und das alles fiel mir schon
 nach oberflaechlicher Suche auf.
 
 Um vergessene assign_eval_cost()'s zu vermeiden, waere wahrscheinlich eine
 zentrale routine der Art switch_to_object(ob) optimal (also current_object
 ueberall readonly), aber man koennte die eval_cost vielleicht auch generell
 in push_control_stack() zuweisen.
 
 Waehrend des catch() sollte die assigned_eval_cost aber trotzdem hochgesetzt
 werden (is einfach logischer).
