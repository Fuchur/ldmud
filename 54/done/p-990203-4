Short: Bugfix: exec() vs simul_efun
From: Daniel von Dincklage <vondincklage@usa.net>
Date: Fri, 19 Jun 1998 11:46:42 +0200
Type: Patch
State: Rejected: using bind_lambda() is easier understand.

Here are some minor patches for the amylaar-driver:

***************
*** 5948,5960 ****
      CASE(F_EXEC);
      {
        int i;
  
        assign_eval_cost();
        TYPE_TEST1(sp-1, T_OBJECT)
        TYPE_TEST2(sp,   T_OBJECT)
        inter_sp = sp;
        inter_pc = pc;
!       i = replace_interactive((sp-1)->u.ob, sp->u.ob,
current_prog->name);
        pop_stack();
        free_svalue(sp); /* object might have been destructed */
        put_number(i);
--- 5975,5997 ----
      CASE(F_EXEC);
      {
        int i;
+         extern struct object *simul_efun_object;
  
        assign_eval_cost();
        TYPE_TEST1(sp-1, T_OBJECT)
        TYPE_TEST2(sp,   T_OBJECT)
        inter_sp = sp;
        inter_pc = pc;
!   
!         if (current_prog == simul_efun_object->prog) {
!        i = replace_interactive((sp-1)->u.ob, sp->u.ob,
!                                    csp[0].prog->name);
!         } else {
!        i = replace_interactive((sp-1)->u.ob, sp->u.ob,
!                                   current_prog->name);
!         }
!         //           (sp-1)->u.ob->prog->name);
! 
        pop_stack();
        free_svalue(sp); /* object might have been destructed */
        put_number(i);

(Otherwise exec can't be a sefun)

Tim Hollebeek wrote:
> It is for precisely this reason that the (dreadful) set_this_object()
> efun exists.  Hacking this in like this probably isn't a good idea
> unless you intend to change every other place where this_object() is
> assumed.

Unfortunatly, that will not work in this case. 
The check was 
  i = replace_interactive((sp-1)->u.ob, sp->u.ob, current_prog->name);
in oder to get the filename of the program that ran the exec(). 
Unfortunatly, using set_this_object() would change the current_object-
variable and not the program that is running (That wouldn't 
be a good idea ;-) ), so regardless of the current_object the valid_exec
would still get the filename of the simul-efun-object. 

So I guess a better idea would be:

***************
*** 5948,5960 ****
      CASE(F_EXEC);
      {
        int i;
- 
        assign_eval_cost();
        TYPE_TEST1(sp-1, T_OBJECT)
        TYPE_TEST2(sp,   T_OBJECT)
        inter_sp = sp;
        inter_pc = pc;
!       i = replace_interactive((sp-1)->u.ob, sp->u.ob,
current_prog->name);
        pop_stack();
        free_svalue(sp); /* object might have been destructed */
        put_number(i);
--- 5975,5989 ----
      CASE(F_EXEC);
      {
        int i;
        assign_eval_cost();
        TYPE_TEST1(sp-1, T_OBJECT)
        TYPE_TEST2(sp,   T_OBJECT)
        inter_sp = sp;
        inter_pc = pc;
! 
!       i = replace_interactive((sp-1)->u.ob, sp->u.ob,
!           current_object->prog->name);
! 
        pop_stack();
        free_svalue(sp); /* object might have been destructed */
        put_number(i);


> An alternative approach is to say this sort of thing should be done
> with bind_lambda(), which is IMHO much cleaner.
Hm, that would work.

Daniel von Dincklage (sunblade@silicondream)

-- 
 * Daniel von Dincklage (vonDincklage@usa.net) *
Windows95 (noun): 32 bit extensions and a graphical shell for a 16 bit
patch to an 8 bit operating system originally coded for a 4 bit micro
processor, written by a 2 bit company that can't stand 1 bit of
competition.

