-------------------------------------------------------------------------------
Date: Thu, 22 Jul 1993 14:28:40 +0100 (MET DST)
From: amylaar@meolyon.hanse.de (Joern Rennecke)
Subject: Re: Diffs, und eine Frage
To: duening@ibr.cs.tu-bs.de

>
> Hi!
>
> Was genau bedeuten eigentlich MIN_MALLOCED und MAX_MALLOCED? Aus den
> Kommentaren im config.h werd ich nicht so ganz schlau...

MIN_MALLOCED gibt eine groesse an, die gleich beim Programmstart alloziert
wird. Dadurch kann man vermeiden, dass ueberall die luecken zwischen den
large chunks al barrieren fuer die rekombination von bloecken wirken.
Das gilt freilich nur fuer den Bereich, den man gemaess MIN_MALLOCED
alloziert hat. Wenn ein mud eh' kurz nach dem reboot 'ne menge Speicher
geholt hat, kann es ihn aber auch ruhig gleich holen. Zumal meistens
virtueller Speicher im Spiel ist, da macht es auch nicht viel aus, etwas
mehr zu holen. Was aber beim Wald- und Wiesen- Amiga wohl nicht der Fall ist.
Ich habe mir deshalb erlaubt, MIN_MALLOCED fuer den Amiga von 16 MB auf 1 MB
zu vermindern. Sonst gibt es bald kaum Benutzer mehr...

MAX_MALLOCED gib ein limit an. Wenn dass erreicht wird, wird der
slow_shut_down Prozess angeleiert... Z.B. NeXT und linux kennen kein malloc
failure, sondern machen irgendwie weiter oder auch nicht. Bei Linux werden
buffer und shared pages 'rausgeschmissen, bis auf jeden Programmschritt ein
page fault kommt...
Das setzen von process limits ist nicht portabel genug.

> !         NOTE_REF(input_to);

Boeser Fehler...

        Joern

-------------------------------------------------------------------------------
Date: Sat, 24 Jul 1993 02:32:21 +0100 (MET DST)
From: amylaar@meolyon.hanse.de (Joern Rennecke)
Subject: Re: Kleinkram
To: duening@ibr.cs.tu-bs.de

> ! #define MIN_MALLOCED 0x0040000

Das alloziert einen block, der gerade 12 Bytes groesser ist als ein normaler
large chunk. Also malloc(0x4000c) . Das macht ueberhaupt keinen Sinn.
MIN_MALLOCED bringt dir nur was, wenn es ein vielfaches der normalen
large chunk size ist. Ich weiss nicht, wie das beim Amiga aussieht, wenn man
so 'ne krumme groesse alloziert, ob dass dann mehr overhead kostet. Um ein
extrem zu nennen: Gnu malloc wuerde die 0x4000c bytes in einen 0x80000 block
packen. Ausserdem kommt es vor, dass schon ein large chunk alloziert wird,
bevor MIN_MALLOCED zum zuge kommt. Also lass es lieber ganz bleiben,
wenn du keinen wirklich grossen block willst...

        Joern

-------------------------------------------------------------------------------
Date: Thu, 26 Aug 1993 18:11:22 +0200 (MET DST)
From: dack@darmstadt.gmd.de (Sven C. Dack)
Subject: Re: closures (fwd)
To: duening@ibr.cs.tu-bs.de (Lars Duening),
        petri@ibr.cs.tu-bs.de (Stefan Petri)

Hi!

Hier ist  die Antwort auf die Fragen, die ich  an Amylaar und  Macbeth
bzgl.  closures hatte (vorerst nur Amylaars Antwort):

(Am besten auch mal den clsoures Text von Mac anschauen, da sich viele
Fragen an diesen Text richten)

---

> >     ({ #'?, cond1, val1, cond2, val2, ..., condn, valn, valdefault });
>
> Hmm, dem beispiel zu Folge waere:
>   cond1 = ({ #'>, 'x, 'y })
>   val1  = 'x
>   cond2 = 'y ??
> oder ist 'y der valdefault? (Scheint jedenfalls so zu sein, aber doch
> etwas verwirrend)

valdefault.

> > while #'? is somewhat like an if statement, #'?! resembles an if_not
> > statement if there were one.

Naja, if (! ist ja auch nur ein zeichen mehr als if( ... und alles compiliert
zu einem einzigen branch.

> >    ({ #'member_array, 'x, '({ "abc", "xyz }) }). Applying lambda() to
> >    this will not result in an error. Instead, the quote will be stripped
> >    from the array and the result regarded as a normal array literal. The
> >    same can be achieved by using the efun quote(), e.g.:
> >    ({ #'member_array, 'x, quote( ({ "abc", "xyz }) ) })
>
> Hmm, Amylaar sagte was auf dem TubMud Meeting in Kirkel, dass man mit
> apply() oder funcall() an den Inhalt von einem quoted array kommt. Irgendwie
> scheint es nicht zu funktionieren.

Sorry, hab' da was durcheinander gebraucht. Um von dem gequoteten wert q
ein quote wergzunehmen, macht man funcall(lambda(0, q)) .
Einfacher ist es, alle quotes von dem array zu nehmen: to_array(q)

> Wenn ich z.B. eine lfun query_property(prop_name) habe und dann am Ende
> der Funktion return funcall(prop_val) mache, ist es sinnvoll/gefaehrlich
> im Falle einer unbound closure noch ein bind_lambda() einzubauen?

Es ist gefaehrlich, wenn die Rechte des Objects, dass bind_lambda() macht,
nicht in der Schinttmenge der Rechte der Objecte liegt, die die closure
erzeugt haben koennten.

> Erzwingt symbol_function() ein Laden des Objects? Die closure die zurueck ge-
> geben wird ist wohl dann auch nur solange existent, wie das Object.

Ja. Jein. Die closure wird durch das Destructen des Objects unbrauchbar.

> > g) Can I create efun closures dynamically, too?
> >    Yes, just use symbol_function() with a single argument. Most useful
> >    for marker objects and the like. But theoretically a security risk
> >    if not used properly and from inside a security relevant object.
> >    Take care, however, that, if there is a simul_efun with the same
> >    name, it will be preferred as in the case of #'function. Use the
> >    efun:: modifier to get the efun if you need it.
> >
> > h) Are there other uses of closures except using them to store code?
> >    Lots. For example, you can use them within almost all of the
> >    efuns where you give a function as an argument, like filter_array(),
> >    sort_array() or walk_mapping(). sort_array(array,#'>) does indeed
> >    what is expected. Another application is set_prompt(), where a
> >    closure can output your own prompt based on the current time and other
> >    stuff which changes all the time.
> >
> > Finally, there are some special efun/operator closures:
> >
> > #'[ indexes an array.
> > #'[< does the same, but starting at the end.
> > #'negate is for unary minus.
> > #', may be followed by any number of closures,
> > e.g.: ({ #', ({#'= 'h, 'a, }), ({#'=, 'a, 'b }), ({#'=, 'b, 'h }) })
> > will swap 'a and 'b when compiled and executed.
>
> Aeh, was ist #' das genau? Closure einer closure?
>
> Nun noch ein paar zusaetzliche Fragen:
>
> - Was ist schneller:
>     strs = map_array(strs, #'lower_case);
>   oder:
>     for(i = sizeof(strs); i--; )
>       strs[i] = lower_case(strs[i]);

Die Iteration in LPC ist wohl schneller.
>
> - Anderes Beispiel:
>     func(arg) { ... }
>       ...
>       arr = map_array(arr, "func", this_object());
>       ...
>   oder:
>     closure cl;
>     cl = lambda(({ 'arg }), ... ); /* tut dasselbe, wie die lfun func() */
>     arr = map_array(arr, cl);

Der aufruf von lambda() kostet erstmal etwas Zeit, wieviel, hangt von der
komplexitaet des ausdrucks ab. Der funktionsaufruf einer closure duerfte
jedoch noch einen tick schneller sein als der von einer lfun, die im
cache ist.

> - Mal abgesehen von der Performance: was ist Programcode-aufwendiger? Welche
>   Variante schraubt den Speicherverbrauch eines Objects in die Hoehe?

map_array in Zusammenhang mit efun/lfun closure Konstanten macht
kompakteren Code. lambda() hingegen braucht manchmal einigen programmcode
extra fuer die argumente. Dafuer spart man sich einen eintrag in der
funktionstabelle, was bei oft inheriteten objecten wichtig ist.
Bei wenig inheriteten objecten sollte man hingegen ueberlegen, ob man die an
lambda() uebergebenen arrays in eine initialisierte globale variable schreibt.

> - Ich vermute auch mal, dass map_array(arr, #'func) immer schneller ist, als
>   map_array(arr, "func", this_object()).

Ja. Dafuer werden shadows ignoriert...

> - set_prompt() nimmt also auch closures an. Fuer welche efuns gilt das noch?
>   (Mal abgesehen von den offensichtlichen map_ und filter_ efuns).
>   call_out()? input_to()? ed()? Falls nein, wuerde sowas eigentlich moeglich/
>   sinnvoll sein?

call_out() nimmt closures. Die Frage nach dem Sinn fuer andere efuns gebe ich
weiter...

> - Wird es sowas wie this_closure() geben? Also wenn man innerhalb einer
>   closure this_closure() aufruft, dass dann diese zurueck geliefert wird.
>   (Naja, ich seh schon, ist etwas bloed die Idee, waere aber in Verbindung mit
>   call_out() interessant ... falls moeglich)

Dazu waere zusaetzlicher overhead erforderlich. Wenn z.B. eine BOUND_LAMBDA
closure aufgerufen wird, sieht das im control stack genauso aus wie eine
LAMBDA closure.
Hmm, gibt es da ausserdem noch security Probleme?

> - Was ist, wenn man einer closure sich selbst uebergibt? Kann sowas dazu
>   fuehren, dass die closure nicht ge-freed wird? (also sowas aehnliches wie
>   selbst-referenziernde Arrays).

I.d.R. macht man sowas, um Rekursion zu realisieren. Natuerlich kann man
die closure auch in einem array speichern, dass zur closure gehoert. Dann
hat man in der Tat eine rekursive Referenz.

        Joern

---

Am interessantesten  ist, dass laut Amylaar eine Iteration  "von Hand"
schneller  ist, als map_array()  mit  einer Closure  und das  wiederum
schneller  als  map_array()  mit dem  Funktionsnamen als String (wobei
letztere wohl zu erwarten waren).

Sven

-------------------------------------------------------------------------------
Date: Thu, 16 Sep 1993 04:10:35 +0100 (MET DST)
From: amylaar@meolyon.hanse.de (Joern Rennecke)
Subject: Re: Irgendwas stimmt da nicht...
To: duening@ibr.cs.tu-bs.de

>
> Hi!
>
> In letzter Zeit passiert es haeufiger, dass Armageddon gestartet wird,
> und kurz danach der GD crasht.
> Im parse.log steht dann:
>
>     ...
>   Temporary out of MEMORY. Freeing user reserve.
>   Temporary out of MEMORY. Freeing user reserve.
>   Temporary out of MEMORY. Freeing user reserve.
>   Temporary out of MEMORY. Freeing user reserve.
>   Temporary out of MEMORY. Freeing user reserve.
>     ...
>
> Kein 'Totally out of memory.'
>
> Im debug.log findet sich:
>
>     ...
>   Out of memory
>    <Ein paar Fehlermeldungen>
>   Out of memory
>    <Ein paar Fehlermeldungen>
>   Out of memory
>
> Hat da irgendwas den Speicher weggemampft (sprich: unsere Reserve von
> 800k ist zu klein), oder ist es was anderes?

Ich habe neulich den Code fuer die Behandlung von Speicherknappheit geaendert.
Im naechsten backend Zyklus wird automatish der garbage collector gestartet.
Statt dem TOTALLY out of MEMORY gibt es i.d.R einen error("Out of memory") .
Ausserdem wird die user Reserve im backend wiedergeholt, sofern das geht.
Wenn das nicht klappt, wird im master quota_demon() aufgerufen.
Allerdings fehlen da noch Informationen in der wizlist, um da sinnvolle
Schritte gegen speziefische wizards einleiten zu koennnen.
Der armageddon wird nur noch geholt, wenn die user area nicht realloziert
werden kann, normalerweise mit argument 6, wenn die master/system area nicht
wieder geholt werden koennen, mit argument 1.

Der Out of memory error kann etwas wahrscheinlicher entstehen als das
TOTALLY out of MEMORY zuvor, weil die Reallozierungsstrategie mit dem
garbage collector den armageddon den armageddon erst startet, wenn die 800 KB
wirklich gebraucht werden, es also nicht bloss um irgendwelche temporaeren
Werte geht, die nicht untergebracht werden.
Insofern kann es noetig sein, eine groessere user reserve zu haben, um ohne
out of memory error den armageddon zu ende arbeiten zu lassen.

Was den out of memory error angeht, so sollte er eigentlich von jedem code
erzeugt werden keonnen, der unbedingt speicher zum weitermachen braucht,
das ist jedoch noch nicht implementiert, d.h. , es gibt code, der sich noch
darauf verlaesst, das xalloc stets erfolgreich ist - oder ein exit() macht,
das interessiert besagten code aber dann nicht mehr.
Ausserdem gibt es noch stellen im interpreter, die einen Out of memory
error bewirken koennen, aber nicht den Stackpointer abspeichern, das
kann dann zu speichermus fuehren...
Die notwendigen Aenderungen, um das perfekt zu machen, sind recht umfangreich,
deshalb war das ganze eigentlich erst fuer 3.3 vorgesehen. Ich habe
allerdings neulich was an error() umstricken muessen, und damit der code
dann von dauer ist, habe ich es gleicht mit Beruecksichtigung des
moeglichen Fehlschlagens von xalloc() gemacht. Wobei ich den Rest, wie
gesagt, nu teilweise implementiert habe.
Ich hatte mir gedacht, das man in 3.2 dann gerade die Sachen korrigiert,
die konkret Probleme machen. Das ist freilich bei der core-freien nova
nicht moeglich...

In Anbetracht dieser Sacherhalte ist es wohl fuer die nova sinnvoll, die
system und master area auf 'ne symbolische 1 zu setzen, und die user area
zu vergroessern. Da der Armagedon auch etwas spaeter kommt, sollt das
effektiv kein Verlust an uptime sein.

        Joern

-------------------------------------------------------------------------------
Date: Tue, 12 Oct 93 21:07:45 +0100
From: duening@ibr.cs.tu-bs.de (Lars Duening)
To: amylaar@cs.tu-berlin.de
Subject: Wunsch zum GD

Hi!

Es waere eine gute Idee, taete der GD unterscheiden zwischen 'Laden
durch Inherit' und 'Laden durch Gebrauch'.

Wir haben in NF den Fall, dass Objekte, die aktiv im Spiel sind, als
Eltern fuer weitere Inheritance herhalten muessen.
Werden nun die Kinder zuerst angefasst, werden die Eltern zwar geladen
(compiliert), aber nicht initialisiert (deren create() wird ja nur fuer
die Kind-Variablen aufgerufen).

Das macht sich dann boes bemerkbar, sobald die Eltern als Objekte ins
Spiel kommen: der GD sieht sie als geladen an, und merkt nicht, dass
sie nicht initialisiert wurden.

Ich sehe zwei Loesungen: einmal das aktive Verwenden von Blueprints
verbieten; oder aber beim Anfassen einer geladenen, aber nicht
initialisierten Blueprint deren create() nochmal aufrufen
(O_NOT_INITIALISED).

Nebenbei: frueher wurden doch die Blueprints gleich mit initialisiert
 - wann hat sich das denn geaendert?

  Lars

-------------------------------------------------------------------------------
Date: Wed, 13 Oct 1993 06:26:05 +0100 (MET)
From: amylaar@meolyon.hanse.de (Joern Rennecke)
Subject: Re: Wunsch zum GD
To: duening@ibr.cs.tu-bs.de

> (O_NOT_INITIALISED).

Das Problem mit den Flags ist, dass sie recht knapp sind...

> Nebenbei: frueher wurden doch die Blueprints gleich mit initialisiert
>  - wann hat sich das denn geaendert?

Das gehoert zum native mode.

        Joern

-------------------------------------------------------------------------------
Date: Wed, 3 Nov 93 21:22:19 +0100
From: duening@ibr.cs.tu-bs.de (Lars Duening)
To: brenner@tat.physik.uni-tuebingen.de,
        dack@darmstadt.gmd.de.petri@ibr.cs.tu-bs.de
Subject: dumpstat aufgebohrt

Hi!

Ich hab das dumpstat() mal aufgebohrt, auf dass es jedes
Array/Mapping/SharedString wirklich nur einmal mitzaehlt.
Die Tests lieferten sinnvolle Zahlen, von daher nehme ich an, dass es
funktioniert.

Im OBJ_DUMP steht jetzt sowas:

obj/tool/xtool#4       960   760 (    0) ref 436    std/player#1 (0)
obj/tool/xtool       22168 21796 (21208) ref 108    -- (0)

Die erste Zahl ist der alte Wert, die zweite Zahl ist die mit jedem
Array nur einmal gezaehlt. Die dritte Zahl ist der Overhead fuer die
Blueprint selber (Programmcode+Funktionstabellen).

Die zweite Zahl ist ein bisschen mit Vorsicht zu geniessen, da die nur
einmal gezaehlten Sachen dem Objekt zugeordnet werden, bei dem sie das
erste mal aufgefuehrt werden. Doch leider kann man mehrfache
Referenzen leider erst ab der zweiten Referenz sicher erkennen - und
da noch ein Backpatching einzubauen ("Mapping# shared by obj/tool/foo,
std/player#69,...") hatte ich keine Lust mehr.

 -- Lars

-------------------------------------------------------------------------------
Date: Tue, 9 Nov 93 19:13:16 +0100
From: petri@ibr.cs.tu-bs.de (Stefan Petri)
To: amylaar@cs.tu-berlin.de, dack@darmstadt.gmd.de, mateese@ibr.cs.tu-bs.de,
        brenner@nova.tat.physik.uni-tuebingen.de
Subject: Returned mail: unknown mailer error 42

Hi!

On Tue, 9 Nov 1993 01:25:55 +0100 (MET),
MAILER-DAEMON@ibr.cs.tu-bs.de (Mail Delivery Subsystem) said:

Mail>      ----- Transcript of session follows -----
Mail>   555 cookie mismatch
Mail>   554 | /usr/local/lib/lpmud/.rdist/procmail... unknown mailer error 42

I got the bouncogram with full contents, no need to send it again

Joern>  Sven Dack proposes to christen efun308() 'set_environment()' .

not too bad.

Joern>  I propose to introduce the following predefined macros:
Joern>  __HOST_NAME__ (query_host_name() will become a simul_efun)
Joern>  __DOMAIN_NAME__
Joern>  __MAX_ARRAY_SIZE__
Joern>  __MAX_EVALCOST__

__HOST_NAME__ Predefined where? I hope not at compile time, because if
you run the mud on a different host but same mudlib (via NFS) to test
things, it is _somewhat_ useful to have the actual hostname at hand,
so you can e.g. write logs into different files. So iff you remove
efun::query_host_name(), you need to pre-#define __HOST_NAME__ with
the result of gethostname(2). Same goes for __DOMAIN_NAME__

__MAX_ARRAY_SIZE__ and __MAX_EVALCOST__ seem to be ok for me.

Joern>  I'd like to hear your opinion on these names, no matter if it
Joern>  is another suggestion, approval, disapproval or that you don't
Joern>  give a damn :-)

A bit off topic: The fine new features of microcode & friends:

I cannot see that the added flexibilty of move_object as microcode
compensates for the loss in memory and speed. So Please please please
put some nice #ifdef around the new features.

In this way it would also be possible to keep a unified source tree for
3.2@late and 3.2.1@early.

                                                        Stefan

-------------------------------------------------------------------------------
Date: Tue, 9 Nov 93 19:26:18 +0100
From: petri@ibr.cs.tu-bs.de (Stefan Petri)
To: amylaar-users@ibr.cs.tu-bs.de
Subject: diff3.2.1@1-2 / some questions

Hi!

The last diff failed to go into the ftp area automagically, so I sned
the Comments by hand. The file is
ftp.tu-bs.de:pub/games/lpmud/amylaar/diff3.2.1@1-2.z

                                                        Stefan

\begin{Amylaars comments}
Use efun:: to avoid set_this_player() / efun308 being used from simul_efun
  after reload.
Removed some dependencies on instrs.h and lang.h .
efun to_int() .
Fixed a bug in find_virtual_value() .
efun308() can take 0 as destination argument.


             ************************************
Sven Dack proposes to christen efun308() 'set_environment()' .

I propose to introduce the following predefined macros:
__HOST_NAME__ (query_host_name() will become a simul_efun)
__DOMAIN_NAME__
__MAX_ARRAY_SIZE__
__MAX_EVALCOST__

I'd like to hear your opinion on these names, no matter if it is another
suggestion, approval, disapproval or that you don't give a damn :-)
             ***********************************
\end{Amylaars comments}

My (Stefan's) opinion:

set_environment() is not to bad a name.

__HOST_NAME__ and __DOMAIN_NAME__ must be initialsed at runtime to the
results of gethostname(2) and getdomainname(2), because it is (we find
it) often useful to run the mud on the same mudlib but a different
host (via NFS or some such), to test things. In this case it is
extremeley useful to have the actual hostname , so that e.g. logging
output can go to different files.

__MAX_ARRAY_SIZE__ and __MAX_EVALCOST__ seem ok for me.

And a side note:

I would very very much like to have all the fancy new features of
3.2.1 have enclosed between thick #ifdef. Reasons:

* It would be possible to have a unified source tree for 3.2@late and
  3.2.1@early

* first of all: I don't think the added flexibilty of doing things
  like move_object() in microcode compensates for the loss in memory
  requirements and execution speed (If I wanted a slow game driver at
  first , I wouldnt have switched to Amylaar's ;-)

-------------------------------------------------------------------------------
Date: Tue, 9 Nov 93 22:29:20 +0100
From: duening@ibr.cs.tu-bs.de (Lars Duening)
To: petri@ibr.cs.tu-bs.de
To: amylaar-users@ibr.cs.tu-bs.de, amylaar@cs.tu-berlin.de
Subject: Re: some questions

Hi!

Amylaar> Sven Dack proposes to christen efun308() 'set_environment()' .

Sounds nice, though 'move_to()' would be easier to type.
How about 'set_hook()' or similar for efun309() (which it seems to be)?

Amylaar> I propose to introduce the following predefined macros:
Amylaar> __HOST_NAME__ (query_host_name() will become a simul_efun)
Amylaar> __DOMAIN_NAME__

As Stefan pointed out, these both defines are useful when running
several gamedrivers for one lib one multiple hosts, so they should be
initialised at runtime only.

Amylaar> __MAX_ARRAY_SIZE__
Amylaar> __MAX_EVALCOST__

Ok for me.

Stefan> And a side note:

Stefan> [...]
Stefan> * first of all: I don't think the added flexibilty of doing things
Stefan>  like move_object() in microcode compensates for the loss in memory
Stefan>  requirements and execution speed (If I wanted a slow game driver at
Stefan>  first , I wouldnt have switched to Amylaar's ;-)

The loss in speed isn't that dramatic for move_object() (due to the
many embedded calls to init()), but I find the way of implementation
awkward: why not having just set_environment() and making
move_object() a simulated efun? Did I miss something subtle?

Btw: isn't it possible to denote closures using an array of strings
(for the code) and actual values (to be inserted into the code)?
Imho the ({,,,}) notation should gain automatic fubar awards
\footnote{Awards given out in NF for bad or unreadable programs}, and
in most cases it is used just to construct functions at runtime, but not
to change them afterwards.

        Lars

-------------------------------------------------------------------------------
Date: Tue, 9 Nov 1993 22:55:31 +0100 (MET)
From: dack@darmstadt.gmd.de (Sven C. Dack)
Subject: Re: some questions
To: duening@ibr.cs.tu-bs.de
Cc: petri@ibr.cs.tu-bs.de, amylaar-users@ibr.cs.tu-bs.de,
        amylaar@cs.tu-berlin.de

> The loss in speed isn't that dramatic for move_object() (due to the
> many embedded calls to init()), but I find the way of implementation
> awkward: why not having just set_environment() and making
> move_object() a simulated efun? Did I miss something subtle?

  The problem is, when you  do it with a  simul_efun  you have to  use
set_this_object() which has to be used with care.
  Also I assume Amylaar not only wants to microcode efuns but other GD
behaviours like reset(0) vs. create().
  But I guess Amylaar can explain it much better than I :-)

> Btw: isn't it possible to denote closures using an array of strings
> (for the code) and actual values (to be inserted into the code)?
> Imho the ({,,,}) notation should gain automatic fubar awards
> \footnote{Awards given out in NF for bad or unreadable programs}, and
> in most cases it is used just to construct functions at runtime, but not
> to change them afterwards.

Hmm? What is so ugly about it? The only thing I  don't like about them
is the ' sign for closures and symbols. IMHO $ would be much nicer and
my c++-mode.el wouldn't  puke  on it  P-). Guess  they are so   'ugly'
because of compilation speed *shrug*.

Sven

-------------------------------------------------------------------------------
Date: Wed, 10 Nov 1993 22:54:41 +0100 (MET)
From: amylaar@meolyon.hanse.de (Joern Rennecke)
Subject: Re: some questions
To: amylaar-users@ibr.cs.tu-bs.de (Especially Lars Duening)

> Amylaar> Sven Dack proposes to christen efun308() 'set_environment()' .
>
> Sounds nice, though 'move_to()' would be easier to type.

The question is not wheather it is easy to type. m() is easy to type.
The question is what you think would be a good name.
Thus, do you prefer set_environment() or move_to() ? Btw. , it could also
be named _move_object() or __move_object() , as it is some kind of low-level
function for move_object() . But I feel a bit uneasy about these as the
underscore as a starting letter is unprecedented in the efun names.

> How about 'set_hook()' or similar for efun309() (which it seems to be)?

Hmm, is there no danger that this collides with an obvious name for mudlib
lfuns ?

> Amylaar> I propose to introduce the following predefined macros:
> Amylaar> __HOST_NAME__ (query_host_name() will become a simul_efun)
> Amylaar> __DOMAIN_NAME__
>
> As Stefan pointed out, these both defines are useful when running
> several gamedrivers for one lib one multiple hosts, so they should be
> initialised at runtime only.

Of course, this should only be a macro on LPC level. It is one of the
current design goals that you can use the same binary for different muds,
so that heavy optimizations on a machine larger than an mud host and
binary distributions for underpowered hosts make sense.

        Amylaar

-------------------------------------------------------------------------------
Date: Wed, 10 Nov 1993 22:36:52 +0100 (MET)
From: amylaar@meolyon.hanse.de (Joern Rennecke)
Subject: Re: some questions
To: amylaar-users@ibr.cs.tu-bs.de (Especially Sven C. Dack)

First, please don't sent mail that is addressed both to
amylaar-users@ibr.cs.tu-bs.de and to one of my personal email addresses,
because this results in me getting several copies of the mail.
I got 28 mails today...

>   The problem is, when you  do it with a  simul_efun  you have to  use
> set_this_object() which has to be used with care.

This is true. Unless you use bind_lambda(), which will mean one extra
function call overhead. Moreover, it seems to me that a closure on itself
is more persistant than the simul_efun object.

>   Also I assume Amylaar not only wants to microcode efuns but other GD
> behaviours like reset(0) vs. create().
>   But I guess Amylaar can explain it much better than I :-)

Well, this is one place that could need some cleanup and generalisation,
but I have not decided yet on a particular sheme.

> > Btw: isn't it possible to denote closures using an array of strings
> > (for the code) and actual values (to be inserted into the code)?
> > Imho the ({,,,}) notation should gain automatic fubar awards
> > \footnote{Awards given out in NF for bad or unreadable programs}, and
> > in most cases it is used just to construct functions at runtime, but not
> > to change them afterwards.

This is because there is not much experience yet with using closures.
Their full potential still has to unfold. The data structure used as
input for lambda() is in essence a parse tree, thus it is ideal for
creation, manipulation and interpretation by programs.

> Hmm? What is so ugly about it? The only thing I  don't like about them
> is the ' sign for closures and symbols. IMHO $ would be much nicer and
> my c++-mode.el wouldn't  puke  on it  P-). Guess  they are so   'ugly'
> because of compilation speed *shrug*.

' / '# is used because it resembles LISP syntax, and because it think it
looks nice (unlike Common LISP as a whole). $ is reserved for yacc .

        Amylaar

-------------------------------------------------------------------------------
Date: Thu, 11 Nov 93 21:35:59 +0100
From: duening@ibr.cs.tu-bs.de (Lars Duening)
To: amylaar-users@ibr.cs.tu-bs.de
Subject: some questions

Hi!

>>> Btw: isn't it possible to denote closures using an array of strings
>>> (for the code) and actual values (to be inserted into the code)?
>>> Imho the ({,,,}) notation should gain automatic fubar awards
>>> \footnote{Awards given out in NF for bad or unreadable programs}, and
>>> in most cases it is used just to construct functions at runtime, but not
>>> to change them afterwards.

> This is because there is not much experience yet with using
> closures.Their full potential still has to unfold.

We'll see.

> ' / '# is used because it resembles LISP syntax, and because it think it
> looks nice (unlike Common LISP as a whole). $ is reserved for yacc .

(+ foo bar baz) is ok, but ({'+, ({'+, foo, bar}), baz }) not (esp.
the , in it). Well, just mho.

        Lars

-------------------------------------------------------------------------------
Date: Sat, 13 Nov 93 17:50:23 EST
From: MUD Development <water@cairo.anu.edu.au>
Subject: Just out of curiousity..
To: amylaar-users@ibr.cs.tu-bs.de

Is there any chance of "interpret.c" being cut into a couple of seperate
files? It's getting awefully huge and the compiler here can't cope...
(unless you make it warning free, and then compile it using gcc -O -- which
IMHO isn't exactly nice :)

Also, what are the chances of the following:

1. A fix in main.c to get rid of the defunct (or zombie) process being
created when parse is run in the background, or "nohup"

2. A fix to stop memory being chewed up when SMALLOC_TRACE is undefined
(starts between pl180-pl190) -- by chewed I mean that it takes a minimum
of 13MBytes and on average 20MBytes to run.. and this is with no users
logged in at all....

Here's hoping...

Metta

-------------------------------------------------------------------------------
Date: Sun, 14 Nov 93 16:48:27 +0100
From: petri@ibr.cs.tu-bs.de (Stefan Petri)
To: water@cairo.anu.edu.au
Cc: amylaar-users@ibr.cs.tu-bs.de
Subject: Just out of curiousity..

Hi!

could you please give us more details on what kind of machine you are
compiling / running the mud, and how you start it?

We have never experienced zombies, on SunOS or SGI. However, we have
trouble with scarce memory, though we believe the main reason for
chewing up lots of memory is the design of our mudlib and how people
se it (creating > 6000 Objects with more than 14 MB memory usage in
less than 2 hours uptime :-(

As for interpret.c : that file mainly consists of one monster size
switch() with cases for every instruction of the stack machine. I
guess the only solution to this is to split the switch, and thus
loosing a good bit of performance :-( Anyway, ``gcc -O'' is the only
compiler that we found useful for the driver at all.

                                                        Stefan

-------------------------------------------------------------------------------
Date: Sun, 28 Nov 93 23:38:10 +0100
From: petri@ibr.cs.tu-bs.de (Stefan Petri)
To: dack@darmstadt.gmd.de, mateese@ibr.cs.tu-bs.de, meha@etzh.ch
Subject: driver kuenstler

Hi!

grad auf nova den mwho-daemon belauscht

probe from TestNase@129.132.57.66 (pass=YourPassword)
petri@sol 187 > traceroute 129.132.57.66
12  dancer.ethz.ch (129.132.57.66)  152 ms  151 ms  142 ms

Als in der default-Distribution noch ``Genesis'' drin stand, hat mich
sowas ja immer heftig irritiert. Aber so weiss ich einfach, dass da
mal jemand sein driver/mudwho.h huebsch machen muss ...

:-)

                                                        Stefan

-------------------------------------------------------------------------------
Date: Sat, 13 Nov 1993 03:11:29 +0100 (MET)
From: amylaar@meolyon.hanse.de (Joern Rennecke)
Subject: LPmud Copyright
To: busey@ux1.cso.uiuc.edu (busey andrew), lars@cd.chalmers.se,
        croes@swi.psy.uva.nl, gusar@uniwa.uwa.OZ.AU, duening@ibr.cs.tu-bs.de,
        jacob@cd.chalmers.se, r_behren@informatik.uni-kl.de,
        mud@alijku05.edvz.uni-linz.ac.at, alcaman@cs.tu-berlin.de

Motivation of this letter:
There seems to be a potential for muds that run on dedicated machines
that charge fees from player to make the mud economically feasible.
The Copyright file says that LPmud can freely used iff it is not for
monetary gain. Now the debate what constitutes monetary gain and if
an individual license is an license to break the copyright,
is an interpretation of the license in Copyright or gives rights
independent the restrictions in Copyright has become a normal flame
war in the rec.games.mud.* groups. That is to say, one of the worst
thinkable.

To allow muds to charge fees to cover costs, without going through
such debates every time, I suggest to amend the Copyright file
with terms under witch such a mud is considered to comply to the
'no monetary gain clause' .

Explanation of the recipient list and some individual messages:

Busey Andrew: wants to set up a mud that charges fees to cover costs.
  If the below rules won't make it into the Copyright, you can regard this
  as a license - of course only for the code written by me.
Lars Pensj|: original author.
  Please forward this letter to other authors that have contributed to 3.1.2
  who have a say in the copyright.
Felix A. Croes: wrote the non-corrupting indentation code for ed.
Sean A Reith: wrote Mud-sprintf() .
Lars Duening: wrote the Amiga port.
Reimer Behrends: wrote mergesort based sort_array() .
Herp: wrote get_object_actions() .
Jacob Hallen: is one of the people involved with the CD driver; the email
 address was in the news recently...
  Please forward this letter to the person holding the copyright for the
  UDP connectivity(unless it's yourself :-) .
Alexander Weidt:
  Please try to forward this letter to my brother...

I hope to finally get terms which all autors can agree on that can be included
into the Copyright file. I suggest group replies, so that we can get some
kind of discussion going (unless there is immediate approval from all
authors :-) . When you have objections, please try to point out what is
wrong with these terms. Even better would it be if you had a solution
to the problem.

        Joern Rennecke (Amylaar)

Proposed Terms:
1. A LPmud may charge fees from players to cover running and machine costs.
2. Running costs in these terms are the cost for the network connection,
   electric power to operate the host machine, wear of backup media,
   repair costs for the host machine, and cost for a bank account.
   For the costs of a bank account to be considered runnung costs,
   they must not habe been considered according to 8. , and the
   institute has to be choosen with at least usual consideration on
   terms and costs of the account and that there must be no affiliaton
   with the institute.
3. Money to cover running costs for a maximum of 18 month may be accumulated
   in advance from fees to smoothe fluctation and to ensure stability of
   the mud. The spare money has to be kept separate from personal money
   and should be invested in trustee investment if liquidity allows.
   If the mud is permanently put down, this money has to be refounded to the
   playeres.
4. Machine costs are costs for buying, installation and upgrade of the host
   machine. The costs have to appear on a bona fide purchase / service
   contract with a person/institution that is not affiliated with the
   person who sets up the mud.
   When the host machine is put out of use, or parts of it are removed for
   other than technical reasons, are parts are nor re-inserted after the
   technical resons for removal and not re-inserting have become void,
   the current value of the machine that has put out of use/the removed
   parts is to be subtracted from the machine costs.
   If thus more money has been paid for machine costs than there are
   currently, the surplus amount has to be refounded to the mud players.
5. The machine cost share in the fee may not be more than 1/2400th
   of the machine costs per month. If the mud has less than 100 players,
   it may be up to machine costs / 24 / number of players, but not more than
   1/120th of the machine costs per month.
6. When money has to be payed back to the mud players, only those that
   have payed at least once a fee within the last 24 month are to be
   considered. For these players, the money is distributed in the ratio
   of the all fee shares ever payed to cover machine costs.
7. All players pay equal fees.
8. Banking costs that have to be paid by the mud administration and are
   immediately connected to incoming money transactions can be subtracted
   from the transferred amount before counting it as payment of fees,
   provided that the institute was choosen with at least usual
   consideration on terms and costs of the account, and that there is
   no affiliaton with the institute.
9. The amount of voluntary donations is unlimited. A donation is not
   considered voluntary if it is connected with special features or
   favours in the mud other than an hounarary mentioning of the donor,
   or if the donor is made to believe that such a connection exists.
   Reasonable measures have to be taken that there is no
   misunderstanding on this point.

Comments:
3. You may not use the money of the mud to bridge personal inliquidity.
   Don't gamble with other persons money, e.g. investing it in junk bonds.
5. Fees should not be arbitrarily raised so that players can be driven
   out. I considered a fixed minimal distributen of the costs to be
   the best means to codify this.
   Absolute figures are bound to become void by inflation.
6. The 24 month period is introduced to allow to erease records of
   clients after two years, and to keep overhead affordable.
7. We don't want favourites to get a free lift, and others grudgingly
   paying extra. If you think somebody needs free access, find someone
   who pays for it, or make a found payed from voluntary donations.

-------------------------------------------------------------------------------
Date: Sat, 13 Nov 1993 15:41:14 +0800 (WST)
From: Sean A Reith <gusar@uniwa.uwa.edu.au>
Subject: Re: LPmud Copyright
To: amylaar@meolyon.hanse.de (Joern Rennecke)
Cc: busey@ux1.cso.uiuc.edu, lars@cd.chalmers.se, croes@swi.psy.uva.nl,
        gusar@uniwa.uwa.OZ.AU, duening@ibr.cs.tu-bs.de, jacob@cd.chalmers.se,
        r_behren@informatik.uni-kl.de, mud@alijku05.edvz.uni-linz.ac.at,
        alcaman@cs.tu-berlin.de

> Motivation of this letter:
> There seems to be a potential for muds that run on dedicated machines
> that charge fees from player to make the mud economically feasible.
> The Copyright file says that LPmud can freely used iff it is not for
> monetary gain. Now the debate what constitutes monetary gain and if
> an individual license is an license to break the copyright,
> is an interpretation of the license in Copyright or gives rights
> independent the restrictions in Copyright has become a normal flame
> war in the rec.games.mud.* groups. That is to say, one of the worst
> thinkable.
>
> To allow muds to charge fees to cover costs, without going through
> such debates every time, I suggest to amend the Copyright file
> with terms under witch such a mud is considered to comply to the
> 'no monetary gain clause' .

[recipient list deleted]

> Proposed Terms:
[list of terms deleted]

Sounds good :)  I consider the code I wrote public-domain (and bloody
awful, but that's beside the point, I'm not involved enough (at all?)
will muds to be bothered re-writing it :), and frankly, whatever Lars'
thinks is fair for his code applies for any additions I made to it
(though sprintf() seems to be all that made it further than discworld :).

The list appears well thought-out (at least to non-lawyer me :).
Especially the clauses about _not_ extra fees == extra facilities within the
mud, though this may be justifiable in terms of extra disk space/processor
time.

Enjoy, be free,
Sean.
--
Sean A Reith                         | gusar@uniwa.uwa.edu.au
C programmer and net.addict at large | sean@ucc.gu.uwa.edu.au
Obquote:                             | reith_s@kultarr.cs.uwa.edu.au
 "I have a cunning Plan" - Baldrick  | sean@his.own.really.fast.machine (RSN)

-------------------------------------------------------------------------------
Date: Sat, 13 Nov 1993 12:38:41 +0100
From: "Felix A. Croes" <croes@swi.psy.uva.nl>
To: alcaman@cs.tu-berlin.de, amylaar@meolyon.hanse.de, busey@ux1.cso.uiuc.edu,
        croes@swi.psy.uva.nl, duening@ibr.cs.tu-bs.de, gusar@uniwa.uwa.OZ.AU,
        jacob@cd.chalmers.se, lars@cd.chalmers.se,
        mud@alijku05.edvz.uni-linz.ac.at, r_behren@informatik.uni-kl.de
Subject: Re:  LPmud Copyright

> [...]

> Explanation of the recipient list and some individual messages:

> [...]

> Felix A. Croes: wrote the non-corrupting indentation code for ed.

   Though I donated the indent code to LPmud before I ever released DGD, it
is part of DGD (in fact, the code itself says it is part of DGD).  DGD has
its own copyright, which is different from the LPmud copyright.  To avoid
confusion, let me make the following statement:

   I donate the code for the editor 'I' command to LPmud, with the following
two restrictions: 1) that I (Felix A. Croes, croes@swi.psy.uva.nl) am noted
as the author; 2) that the code is marked as originally coming from DGD.

   There are no other restrictions.

> [...]

> I hope to finally get terms which all autors can agree on that can be included
> into the Copyright file. I suggest group replies, so that we can get some
> kind of discussion going (unless there is immediate approval from all
> authors :-) . When you have objections, please try to point out what is
> wrong with these terms. Even better would it be if you had a solution
> to the problem.
>
>       Joern Rennecke (Amylaar)
>
> Proposed Terms:

> [...]

   Fine with me.  Get some competition with DGD going ;-)
   One important point: what exactly is LPmud?  With regard to my indent code,
I consider LPmud to be LPmud 3.2, or any version derived therefrom.

   Regards, Felix Croes

-------------------------------------------------------------------------------
Date: Fri, 19 Nov 1993 17:10:44 +0100 (MET)
From: Lars Pensj| <lars@cd.chalmers.se>
Subject: Re: LPmud Copyright
To: amylaar@meolyon.hanse.de (Joern Rennecke)
Cc: busey@ux1.cso.uiuc.edu, lars@cd.chalmers.se, croes@swi.psy.uva.nl,
        gusar@uniwa.uwa.OZ.AU, duening@ibr.cs.tu-bs.de, jacob@cd.chalmers.se,
        r_behren@informatik.uni-kl.de, mud@alijku05.edvz.uni-linz.ac.at,
        alcaman@cs.tu-berlin.de

I agree that fix of the copyright is needed. I would prefer to use the
Gnu Copyleft, as I don't care any longer if anyone makes money from it. The
important thing is that it is free, which means noone will be able to make
much money anyway.

Any thoughts about it ?

/Lars

-------------------------------------------------------------------------------
Date: Fri, 19 Nov 1993 20:14:10 +0100 (MET)
From: Jacob Hallen <jacob@cd.chalmers.se>
Subject: Re: LPmud Copyright
To: amylaar@meolyon.hanse.de (Joern Rennecke)
Cc: busey@ux1.cso.uiuc.edu, lars@cd.chalmers.se, croes@swi.psy.uva.nl,
        gusar@uniwa.uwa.OZ.AU, duening@ibr.cs.tu-bs.de, jacob@cd.chalmers.se,
        r_behren@informatik.uni-kl.de, mud@alijku05.edvz.uni-linz.ac.at,
        alcaman@cs.tu-berlin.de

> Jacob Hallen: is one of the people involved with the CD driver; the email
>  address was in the news recently...
>   Please forward this letter to the person holding the copyright for the
>   UDP connectivity(unless it's yourself :-) .

I represent everyone involved in the CD driver. The UDP stuff is to be
considered public domain. All other parts are covered by the non-profit clause.
Code origination from me, Johan Andersson (Commander), Ronny Wikh (Mrpr),
Lennart Augustsson (Marvin) is covered by it. We have no intention of
allowing people to charge money for the usage of our driver, or borrowed
pieces thereof.
We consider the acceptance of volontary donations as fair practice, and we
can accept the charging for the use of extra equipment needed to allow
people to access the mud, as long as there is a reasonable way to access the
mud without being charged. (Providing modem access at a cost while allowing
free access over the internet is an example of such a setup.)

My personal view is that an elaborate setup of terms like the one in the
original letter is unreasonable. It is designed for a very specific set of
circumstances. It is impossible to check and it is very bureaucratic.
It does not have my support.

Jacob Hallen

-------------------------------------------------------------------------------
Date: Sat, 20 Nov 1993 23:35:12 +0100 (MET)
From: Multi User Dungeon <mud@alijku05.edvz.uni-linz.ac.at>
Subject: Re: LPmud Copyright
To: lars@cd.chalmers.se (Lars Pensj|)
Cc: busey@ux1.cso.uiuc.edu, croes@swi.psy.uva.nl, gusar@uniwa.uwa.OZ.AU,
        duening@ibr.cs.tu-bs.de, jacob@cd.chalmers.se,
        r_behren@informatik.uni-kl.de, alcaman@cs.tu-berlin.de

Lars> important thing is that it is free, which means noone will be able to make
Lars> much money anyway.

You are speaking about the GD,correct ? Normally, many a site uses an unmodified
GD based upon which is a more or less heavily or not heavily Mudlib. Based upon
this Mudlib is the work of the `wizards' ... Sorry for repeating known stuff.

This makes most Muds differ from each other. So, the fact that the GD itself
is free, doesn't imply that you won't make money.

Another point to argue: maintainig a Mud takes time .. a LOT of time. Usually,
doing so is not fun at all. I experienced that the more players you have, the
less fun it is fore the adminstrators. You spend a lot of time coding,
searching and fixing bugs ... and I think, this can be regarded as a
service for players (... and players really can be a pain sometimes ...)
Would it be legal to charge money for that ?

Another thought: Internet Muds. They run on internet, usually on computers
owned by a school or university, some with, some without the knowledge of
the site adminstrators. Would it be legal to charge money when you run
a Mud on equipment not owned by yourself ? And, even if you own the computer,
do you pay for the internet link ? If not, I fear you must not charge money
for a Mud without speaking with the network adminstrator since you are using
the network components (router/bridges, even cables :-> ...) for free.

How difficult is charging money in European Muds ? Not that I plan
to do so for HM (it's closed for players currently anyway), but isn't there a
big difference according to the "accounting mechanism" (ugh, bad english :-)
that is used in the States ? I heard that it is much more easy to make
financial transactions within the States. So, I suspect the "Mud money charging"
discussion arrives from the US :-)

Greetings, Herp (mud@mud.uni-linz.ac.at)

-------------------------------------------------------------------------------
Date: Fri, 19 Nov 1993 19:16:11 +0100 (MET)
From: dack@darmstadt.gmd.de (Sven C. Dack)
Subject: inheritance bug?
To: amylaar@cs.tu-berlin.de (Joern Rennecke)
Cc: duening@ibr.cs.tu-bs.de (Lars Duening)

Hi!

  Bisher dachte ich immer, dass wenn eine Funktion als 'public' markiert wurde,
diese dann nicht mehr von einer Subklasse als 'private' deklariert werden kann.
Habe immer angenommen, dass man dadurch wichtige Funktionen wie SetProp() davor
schuetzen koennte  'versteckt' zu werden.    'nomask public' ist hierbei  nicht
sinnvoll,   da man   ja  immernoch  die  Moeglichkeit   zur  Redefinition geben
moechte. Natuerlich kann jemand dann SetProp() 'deaktivieren' indem man einfach
0 zureuck gibt, aber das ist dann Sache des Objekts.

Ich hab folgende Files gegeben:

--- a.c ---
public f() { return 13; }
--- b.c ---
inherit "/players/hyp/test/a";
private f();
-----------

call b->f()  =>  0

  Selbiges gilt dann auch fuer    den Fall, wenn   man  eine ganze Klasse   via
'private  inherit'  erben tut.  Dann   sollten   die als 'public'    markierten
Funktionen immernoch 'public' bleiben.

  Etwas  anderes  ist die Art   und Weise  wie  nach geerbeten  Funktionen  und
Variablen gesucht wird:

--- a.c ---
int i;
a() { if (i) write("a::i\n"); }
f() {        write("a::f()\n"); }
--- b.c ---
inherit "/players/hyp/test/a";
--- c.c ---
inherit "/players/hyp/test/a";
int i;
c() { if (i) write("c::i\n"); }
f() {        write("c::f()\n"); }
--- d.c ---
inherit "/players/hyp/test/b";
inherit "/players/hyp/test/c";
f() { i++; a(); c(); ::f(); }
-----------

Das ergibt folgende Strukturen:

Funktionen:    a      Variablen:  a   a
              / \                 |   |
             b   c                b   c
              \ /                  \ /
               d                    d

Ruft man nun d->f() auf, wird das ausgegeben:

c::i
a::f()

Es scheint  also,  dass bei Variablen eine   Breitensuche gemacht wird  und bei
Funktionen Tiefensuche. Ist das Absicht oder ein Bug?

Sven

-------------------------------------------------------------------------------
Date: Mon, 22 Nov 1993 18:17:40 +0100 (MET)
From: dack@darmstadt.gmd.de (Sven C. Dack)
Subject: Re: inheritance bug?
To: duening@ibr.cs.tu-bs.de

Zu 1.): Das verstoesst ganz klar gegen das OOP Paradigma und Amylaar hats
        ja auch gleich gefixt.

Zu 2.): Das hat nichts mit virtual oder static inheritance zu tun.

Grund: Wenn Du den Graph hast:

   a
  / \
 b   c
  \ /
   d

Dann sehe die Variablen so aus:

a   a               a
|   |              / \
b   c   oder so:  b   c
 \ /               \ /
  d                 d

Wobei a eine Funktiuon f() und eine Variable <i> definiert und c das
genauso macht. Und nun erklaer mir mal, warum der GD bei Funktionen
links herum geht, aber bei Variablen rechts herum? Funktionen werden
nach deep-first und Variablen nach breadth-first Richtung gesucht.
IMHO sollte da etwas mehr Konsitenz sein. Leider bounce die scheiss
Mails in RIchtung Amylaar staendig :-(

Sven

-------------------------------------------------------------------------------
Date: Mon, 10 Jan 94 17:52:10 GMT
Return-Path: <@castle.ed.ac.uk:p90175@cplab.physics.edinburgh.ac.uk>
From: p90175@cplab.ph.ed.ac.uk
To: duening@ibr.cs.tu-bs.de

Hallo Lars !

Vielen Dank fuer deine ausfuehrliche Mail ueber
die Speicherroutinen von NF.
Ich sehe dass ihr wohl schon ziemlich ausgefeilte
Routinen verwendet ! Meine Vorschlaege habe sich
im Wesentlichen auf den Fall des ploetzlichen
Absturzes (wohl durch Inkonsistenzen) bezogen.
Dies kam (zumindesents vor Weihnachten, als ich
dass letzte Mal eingeloggt war) ziemlich oft vor.
Und es ist fuer die Spieler aergerlich Mitten in
einer Quest alles zu verlieren. Deshalb dachte ich
mir, dass man den Zustand soweit wieder herstellt,
um wenigstens so ungefaehr weiter machen zu koennen.

Die anderen Situationen sind klar und meiner Meinung
nach auch gut geloest. Es ist nicht notwendig NPC's oder
alle Gegenstaende eines Spielers zu speichern.
(Dies haette wohl auch Konsequenzen auf die anderen
Gegenstaende - Alle guten Waffen, etc waeren staendig
belegt ...)
Auch ein angekuendigter Reboot ist nicht so schlimm.
(Naja, toll natuerlich auch nicht.)

Weisst du eigentlich wie gross NF ist ? Wieviel Objekte ?

So erstmal tschuess und viele Gruesse aus Edinburgh,

Martin (Apollo)

------------------------------------------------------------------------------
Date: Mon, 5 Dec 1994 11:12:03 -0800 (PST)
From: Christine Maxwell <kaila@crl.com>
Subject: Re: local mud
To: duening@ibr.cs.tu-bs.de (Lars Duening)

> As long as your operating system is able to do networking and your
> system just lacks the hardware, you can run every networking mud and
> access it as 'localhost' aka '127.0.0.1'.
>
> For FTP addresses see the Mud FAQs.
> --
> Lars Duening; duening@ibr.cs.tu-bs.de
>

I thank you for your reply.  I am using Coherent, which, unfortunately,
does not support networking beyond a socket emulation library.  I have a
modified copy of KA9Q, but somehow doubt that would serve the same purpose.

This is the reason for my specifications... I hope to find one using
local interprocess communication only, to allow me to port it...

Thank you again for your time,
Christine

------------------------------------------------------------------------------
Date: Wed, 25 Jan 1995 10:45:19 +0100
From: Stefan Petri <petri@ibr.cs.tu-bs.de>
To: brenner@nova.tat.physik.uni-tuebingen.de, duening@achill.ibr.cs.tu-bs.de,
        martin@ego.oche.de, petri@achill.ibr.cs.tu-bs.de
Subject: sigalrm vs sockets on irix

Newsgroups: comp.unix.programmer,comp.unix.bsd
Path: tubsibr!gs.dfn.de!fauern!xlink.net!howland.reston.ans.net!vixen.cso.uiuc.edu!uwm.edu!reuter.cse.ogi.edu!psgrain!library.ucla.edu!csulb.edu!csus.edu!netcom.com!carnal
From: carnal@netcom.com (Dave Carnal)
Subject: Re: Datagram Sockets and Signals
Message-ID: <carnalD2vwv7.654@netcom.com>
Followup-To: comp.unix.programmer,comp.unix.bsd
Organization: NETCOM On-line Communication Services (408 261-4700 guest)
X-Newsreader: TIN [version 1.2 PL1]
References: <D2uA2E.16u@murdoch.acc.Virginia.EDU>
Date: Tue, 24 Jan 1995 00:47:31 GMT
Lines: 20
Xref: tubsibr comp.unix.programmer:191215 comp.unix.bsd:17167

Alan Chih-Chang Tai (act9m@uvacs.cs.Virginia.EDU) wrote:
: I'm having problems getting my UDP sockets and Irix interval timer to
: coexist.  My timer causes a SIGALRM, which dumps control to a short
: timer handler every couple of seconds.  Now, my BSD socket calls
: recvfrom and sendto are constantly interrupted.  I can eventually
: receive a packet by detecting the error return value from recvfrom and
: retrying.  With sendto, I end up retrying forever :-(.  I would rather not
: switch to TCP, but it looks like I might have to go that route.  Does
: anyone have any suggestions?  Thanks.

Your protocol isn't your problem. UDP will work fine.  I'm not sure what
an Irix interval timer is.  Is this someones library?   Why don't you
use select() to wait on your socket and take the timeout.
That's how most folks in Unix land do it.

I have seen a few third party libraries that give you 'Timer' wrappers
around SIGALRM.  Generally, they don't really work well.

Dave Carnal
Senior Systems Programmer / NationsBank - CRT

------------------------------------------------------------------------------
