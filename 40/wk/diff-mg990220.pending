diff -u -r --ignore-space-change driver/dumpstat.c driver.140/dumpstat.c
--- driver/dumpstat.c	Mon Nov  2 22:49:18 1998
+++ driver.140/dumpstat.c	Wed Nov 26 13:45:23 1997
@@ -207,12 +207,13 @@
 	} else {
 	    tmp = 0;
 	}
-	fprintf(f, "%-20s %5ld ref %2ld %s %s (%ld) %s\n", ob->name,
+	fprintf(f, "%-20s %5ld ref %2ld %s %s (%.0lf) %s\n", ob->name,
 		tmp + (long)data_size(ob) + sizeof (struct object) +
 		sizeof(p_int) /* smalloc overhead */ ,
 		ob->ref,
 		ob->flags & O_HEART_BEAT ? "HB" : "  ",
-		ob->super ? ob->super->name : "--",/*ob->cpu*/ 0L,
+		ob->super ? ob->super->name : "--",
+                (double)ob->_my_cost, /* Kirk: was 0L */
 		swapstrings[(O_PROG_SWAPPED(ob)?1:0) | (O_VAR_SWAPPED(ob)?2:0)]
 	);
     }
diff -u -r --ignore-space-change driver/func_spec driver.140/func_spec
--- driver/func_spec	Mon Nov  2 22:49:18 1998
+++ driver.140/func_spec	Sat Feb  6 22:42:16 1999
@@ -181,6 +181,7 @@
 mixed *filter_array(mixed *, string|closure|mapping, ...);
 int find_call_out(string|closure);
 object find_object(string);
+mixed *object_info(object);
 string function_exists(string, object default: F_THIS_OBJECT);
 string implode(string *, string);
 int input_to(string, void|int, ...);
@@ -220,6 +221,7 @@
 string set_bit(string, int);
 int set_heart_beat(int);
 int set_light(int);
+void set_next_reset(int);
 void set_this_object(object);
 int sizeof(mixed *|mapping);
 mixed *slice_array F_RANGE (mixed *,int,int);
@@ -433,6 +435,7 @@
 int attach_erq_demon(object|string, int default: F_CONST0);
 int send_erq(int, int*|string, closure default: F_CONST0);
 #endif
+int absolute_hb_count();
 #ifdef UDP_SEND
 int send_imp(string, int, string|int*);
 #endif
diff -u -r --ignore-space-change driver/interpret.c driver.140/interpret.c
--- driver/interpret.c	Mon Nov  2 22:49:18 1998
+++ driver.140/interpret.c	Sat Feb  6 22:58:16 1999
@@ -122,6 +122,7 @@
 extern struct object *current_heart_beat, *current_interactive;
 extern int out_of_memory;
 extern char *out_of_memory_string;
+extern int absolute_hb_num;
 
 /* A function call can cause an eval_cost overflow linear to the number of
  * shadows. Well, adding more than a million is likely to cause memory
@@ -220,7 +221,8 @@
 #define ASSIGN_EVAL_COST \
     if (current_object->user)\
 	current_object->user->cost += eval_cost - assigned_eval_cost;\
-    assigned_eval_cost = eval_cost;
+	current_object->_my_cost += eval_cost - assigned_eval_cost;\
+    assigned_eval_cost = eval_cost; /* Kirk */
 
 void assign_eval_cost() { ASSIGN_EVAL_COST }
 
@@ -3403,6 +3405,10 @@
     CASE(F_POP_VALUE);
 	pop_stack();
 	break;
+    CASE(F_SET_NEXT_RESET);
+        TYPE_TEST1(sp, T_NUMBER)
+        set_next_reset(sp->u.number);
+        break;
     CASE(F_DUP);
 	sp++;
 	assign_svalue_no_free(sp, sp-1);
@@ -7888,6 +7894,70 @@
 	pc++;
 	break;
     }
+#ifdef F_OBJECT_INFO
+    CASE(F_OBJECT_INFO);
+    {
+	struct vector *oi;
+	struct svalue *v;
+	int flags, i;
+	struct object *ob, *prev, *obj2;
+	char xtmp[1024];
+
+	TYPE_TEST1(sp,T_OBJECT);
+	ob=sp->u.ob;
+	oi = allocate_array(20);
+	v = oi->item;
+	flags=ob->flags;
+
+	v[ 0].u.number = (flags & O_HEART_BEAT ? 1 : 0);
+	v[ 1].u.number = (flags & O_IS_WIZARD ? 1 : 0);
+	v[ 2].u.number = (flags & O_ENABLE_COMMANDS ? 1 : 0);
+	v[ 3].u.number = (flags & O_CLONE ? 1 : 0);
+	v[ 4].u.number = (flags & O_DESTRUCTED ? 1 : 0);
+	v[ 5].u.number = (flags & O_SWAPPED ? 1 : 0);
+	v[ 6].u.number = (flags & O_ONCE_INTERACTIVE ? 1 : 0);
+	v[ 7].u.number = (flags & O_APPROVED ? 1 : 0);
+	v[ 8].u.number = (flags & O_RESET_STATE ? 1 : 0);
+	v[ 9].u.number = (flags & O_WILL_CLEAN_UP ? 1 : 0);
+	v[10].u.number = ob->total_light;
+	v[11].u.number = ob->next_reset;
+	v[12].u.number = ob->time_of_ref;
+	v[13].u.number = ob->ref;
+	v[14].u.number = (int)ob->_my_cost;
+	v[15].u.number = O_SWAP_NUM(ob);
+
+	v[16].type = T_STRING;
+	v[16].x.string_type = STRING_MALLOC;
+	v[16].u.string = string_copy(ob->name);
+	
+	v[17].type = T_STRING;
+	v[17].x.string_type = STRING_MALLOC;
+	for (obj2=ob->next_all; obj2 && obj2->flags & O_DESTRUCTED;)
+	    obj2=obj2->next_all;
+	sprintf(xtmp,"%s",obj2->next_all?obj2->name:"NULL");
+	v[17].u.string = string_copy(xtmp);
+	
+	v[18].type = T_STRING;
+	v[18].x.string_type = STRING_MALLOC;
+	sprintf(xtmp,"NULL");
+	for (prev=0,obj2=obj_list,i=0;obj2;obj2=obj2->next_all) {
+	    if ( !(obj2->flags & O_DESTRUCTED) )
+		prev = obj2, i++;
+	    if (obj2->next_all == ob) {
+		if (prev) 
+		    sprintf(xtmp,"%s",prev->name);
+		else 
+		    i=-1;
+		break;
+	    }
+	}
+	v[18].u.string = string_copy(xtmp);
+	v[19].u.number = i;
+	
+	push_referenced_vector(oi);
+	break;
+    }
+#endif /* F_OBJECT_INFO */
 #ifdef F_RUSAGE
     CASE(F_RUSAGE);
     {
@@ -12049,6 +12124,14 @@
     return sp;
 }
 
+struct svalue *f_absolute_hb_count(sp)
+   struct svalue *sp;
+{   
+    sp++;
+    put_number(absolute_hb_num);
+    return sp;
+}
+
 struct svalue *f_set_modify_command(sp)
     struct svalue *sp;
 {
@@ -12343,6 +12426,7 @@
 #ifdef DEBUG
 	add_message("extra_ref   : %ld\n", ob->extra_ref);
 #endif
+	add_message("evalcost    : %.0lf\n", (double)ob->_my_cost); /* Kirk */
 	add_message("swap_num    : %ld\n", O_SWAP_NUM(ob));
 	add_message("name        : '%s'\n", ob->name);
 	for (obj2 = ob->next_all; obj2 && obj2->flags & O_DESTRUCTED; )
diff -u -r --ignore-space-change driver/object.h driver.140/object.h
--- driver/object.h	Mon Nov  2 22:49:18 1998
+++ driver.140/object.h	Wed Nov 26 13:45:28 1997
@@ -55,6 +55,7 @@
     /* amylaar : used to determine where to check ref counts at all... */
 #endif
     struct svalue *variables;		/* All variables to this program */
+    long long _my_cost; /* Kirk */
 };
 
 struct replace_ob {
diff -u -r --ignore-space-change driver/simulate.c driver.140/simulate.c
--- driver/simulate.c	Mon Nov  2 22:49:18 1998
+++ driver.140/simulate.c	Sat Feb  6 22:44:46 1999
@@ -461,6 +461,7 @@
     ob->prog = prog;
     ob->next_all = obj_list;
     obj_list = ob;
+    ob->_my_cost=0; /* Kirk */
     enter_object_hash(ob);	/* add name to fast object lookup table */
 
     push_give_uid_error_context(ob);
@@ -614,6 +615,7 @@
 	fatal("clone_object() from no current_object !\n");
 #endif
     new_ob->next_all = obj_list;
+    new_ob->_my_cost=0; /* Kirk */
     obj_list = new_ob;
     enter_object_hash(new_ob);	/* Add name to fast object lookup table */
     push_give_uid_error_context(new_ob);
@@ -4383,4 +4385,21 @@
 	}
     }
     return sp;
+}
+
+void set_next_reset(num)
+    int num;
+{
+    extern int current_time;
+
+    if (current_object->flags & O_DESTRUCTED) return;
+    if (num>=0) {
+        int oldnum;
+
+        oldnum=num;
+        num+=current_time;
+        if (num<oldnum) num=MAXINT;
+    }
+    else num=MAXINT;
+    current_object->next_reset = num;
 }
