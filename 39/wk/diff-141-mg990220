Only in driver.140: Makefile
diff -u -r --ignore-space-change driver/Makefile.in driver.140/Makefile.in
--- driver/Makefile.in	Mon Nov  2 22:49:18 1998
+++ driver.140/Makefile.in	Wed Nov 26 13:42:21 1997
@@ -25,12 +25,15 @@
 # Use the standard malloc on your system:
 #MALLOC=sysmalloc
 #
+# Which HASH-Source should we use?
+HASH=hosts/i386/hash.S
+#HASH=hash.c
 # Set MUD_LIB to the directory which contains the mud data. Was formerly
 # defined in config.h !
-MUD_LIB = /user/mud/mudlib
+MUD_LIB = /u/mud/mudlib
 #
 # Set BINDIR to the directory where you want to install the executables.
-BINDIR = /mud/bin
+BINDIR = /u/mud/bin.${OS}
 #
 #PROFIL= -DOPCPROF -DVERBOSE_OPCPROF
 #PROFIL=-p -DMARK
@@ -74,7 +77,7 @@
 #
 SRC=lex.c main.c interpret.c simulate.c object.c backend.c array.c\
     comm1.c ed.c regexp.c mapping.c wiz_list.c swap.c $(MALLOC).c\
-    call_out.c otable.c dumpstat.c stralloc.c hash.c port.c\
+    call_out.c otable.c dumpstat.c stralloc.c $(HASH) port.c\
     access_check.c parse_old.c parse.c prolang.y\
     simul_efun.c sprintf.c gcollect.c closure.c random.c
 OBJ=lang.o lex.o main.o interpret.o simulate.o object.o backend.o array.o\
@@ -87,7 +90,7 @@
 	$(CC) @OPTIMIZE_LINKING@ $(LDFLAGS) $(OBJ) -o $@ $(LIBS)
 
 install: driver
-	$(INSTALL) -c $? $(BINDIR)/parse
+	$(INSTALL) $? $(BINDIR)/Parse.install
 
 install.utils:
 	(cd util; $(MAKE) $(MFLAGS) install)
@@ -170,7 +173,7 @@
 gcollect.o : gcollect.c lint.h config.h machine.h interpret.h object.h exec.h \
   sent.h comm.h smalloc.h instrs.h lang.h wiz_list.h stralloc.h
 
-hash.o : hash.c
+hash.o : $(HASH)
 
 interpret.o : interpret.c lint.h config.h machine.h interpret.h lang.h exec.h \
   object.h wiz_list.h instrs.h comm.h sent.h switch.h smalloc.h stralloc.h
diff -u -r --ignore-space-change driver/backend.c driver.140/backend.c
--- driver/backend.c	Mon Nov  2 22:49:18 1998
+++ driver.140/backend.c	Tue Feb 16 11:13:53 1999
@@ -33,6 +33,7 @@
  * The 'current_time' is updated at every heart beat.
  */
 int current_time;
+int absolute_hb_num;
 
 extern struct object *command_giver, *current_interactive;
 extern int num_player, d_flag;
@@ -365,7 +366,11 @@
 	/*
 	 * Should this object have reset(1) called ?
 	 */
-	if (ob->next_reset < current_time && !(ob->flags & O_RESET_STATE)) {
+	if (ob->next_reset < current_time && !(ob->flags & O_SWAPPED)) {
+	if (ob->flags & O_RESET_STATE)
+	    ob->next_reset = current_time + TIME_TO_RESET/2
+	    	+random_number(TIME_TO_RESET/2);
+	else {
 	    if (d_flag)
 		fprintf(stderr, "RESET %s\n", ob->name);
 	    CLEAR_EVAL_COST;
@@ -375,6 +380,7 @@
 	    if (ob->flags & O_DESTRUCTED)
 		continue;
 	}
+	}
 #if TIME_TO_CLEAN_UP > 0
 	/*
 	 * Has enough time passed, to give the object a chance
@@ -496,6 +502,7 @@
 
     current_time = get_current_time();
     current_interactive = 0;
+    absolute_hb_num++;
 
     hb_last_to_call = hb_last_called;
     hb_num_done = 0;
diff -u -r --ignore-space-change driver/comm1.c driver.140/comm1.c
--- driver/comm1.c	Mon Nov  2 22:49:18 1998
+++ driver.140/comm1.c	Fri Feb  5 22:06:50 1999
@@ -2209,6 +2209,22 @@
 	telopts_wont[i] = reply_nil;
     }
     telopts_wont[TELOPT_SGA] = reply_to_wont_sga;
+    telopts_do[TELOPT_NEWENV] = reply_h_telnet_neg;
+    telopts_dont[TELOPT_NEWENV] = reply_h_telnet_neg;
+    telopts_will[TELOPT_NEWENV] = reply_h_telnet_neg;
+    telopts_wont[TELOPT_NEWENV] = reply_h_telnet_neg;
+    telopts_do[TELOPT_ENVIRON] = reply_h_telnet_neg;
+    telopts_dont[TELOPT_ENVIRON] = reply_h_telnet_neg;
+    telopts_will[TELOPT_ENVIRON] = reply_h_telnet_neg;
+    telopts_wont[TELOPT_ENVIRON] = reply_h_telnet_neg;
+    telopts_do[TELOPT_XDISPLOC] = reply_h_telnet_neg;
+    telopts_dont[TELOPT_XDISPLOC] = reply_h_telnet_neg;
+    telopts_will[TELOPT_XDISPLOC] = reply_h_telnet_neg;
+    telopts_wont[TELOPT_XDISPLOC] = reply_h_telnet_neg;
+    telopts_do[TELOPT_LINEMODE] = reply_h_telnet_neg;
+    telopts_dont[TELOPT_LINEMODE] = reply_h_telnet_neg;
+    telopts_will[TELOPT_LINEMODE] = reply_h_telnet_neg;
+    telopts_wont[TELOPT_LINEMODE] = reply_h_telnet_neg;
     telopts_do[TELOPT_NAWS] = reply_h_telnet_neg;
     telopts_dont[TELOPT_NAWS] = reply_h_telnet_neg;
     telopts_will[TELOPT_NAWS] = reply_h_telnet_neg;
@@ -2217,6 +2233,22 @@
     telopts_dont[TELOPT_TTYPE] = reply_h_telnet_neg;
     telopts_will[TELOPT_TTYPE] = reply_h_telnet_neg;
     telopts_wont[TELOPT_TTYPE] = reply_h_telnet_neg;
+    telopts_do[TELOPT_TSPEED] = reply_h_telnet_neg;
+    telopts_dont[TELOPT_TSPEED] = reply_h_telnet_neg;
+    telopts_will[TELOPT_TSPEED] = reply_h_telnet_neg;
+    telopts_wont[TELOPT_TSPEED] = reply_h_telnet_neg;
+
+    telopts_do[TELOPT_EOR] = reply_h_telnet_neg;
+    telopts_dont[TELOPT_EOR] = reply_h_telnet_neg;
+    telopts_will[TELOPT_EOR] = reply_h_telnet_neg;
+    telopts_wont[TELOPT_EOR] = reply_h_telnet_neg;
+
+	/* Tinyfugue can do bad things to your health */
+    telopts_do[EOR] = reply_h_telnet_neg;
+    telopts_dont[EOR] = reply_h_telnet_neg;
+    telopts_will[EOR] = reply_h_telnet_neg;
+    telopts_wont[EOR] = reply_h_telnet_neg;
+
     /* Go Ahead does not make any sense when coupling multiple
      * interactive users. It is debatable if we are sending
      * Go Ahead every time it is appropriate (i.e. , never),
diff -u -r --ignore-space-change driver/config.h driver.140/config.h
--- driver/config.h	Mon Nov  2 22:49:18 1998
+++ driver.140/config.h	Thu Jun 18 08:00:00 1998
@@ -1,27 +1,29 @@
 #ifndef CONFIG_H
 #define CONFIG_H
 
+#undef DRAND48
+
 /* Should code for the external request demon be included?  */
-#define ERQ_DEMON
+#undef ERQ_DEMON
 #define ERQ_MAX_REPLY 256
 
 /* Only executables that are safe no matter what arguments/options
  * are supplied should be placed in ERQ_DIR. If you want something
  * different, consider writing a wrapper program or shell script.
  */
-#define ERQ_DIR "/user/src/mud/erq"
+#define ERQ_DIR "/u/mud/bin/erq.d"
 
 /* #define ACCESS_CONTROL if you want the driver to do any access control,
  * either using the old style ACCESS.DENY or the new ACCESS.ALLOW .
  */
-#define ACCESS_CONTROL
+#undef ACCESS_CONTROL
 
 /*
  * Define this if you want to use the improved access restriction system.
  * Look at the file ACCESS.ALLOW for information. It replaces the old
  * ACCESS.DENY.
  */
-#define ACCESS_RESTRICTED
+#undef ACCESS_RESTRICTED
 
 /* Some configurations for this system. Needn't be changed if you don't use
  * the new access restriction system.
@@ -43,7 +45,7 @@
 /*
  * Max size of a file allowed to be read by 'read_file()'.
  */
-#define READ_FILE_MAX_SIZE	50000
+#define READ_FILE_MAX_SIZE	200000
 
 /* Version of the game in the form xx.xx.xx (leading zeroes) gc.
  * A dot and two digits may be appended, that is the patch level.
@@ -58,7 +60,9 @@
  *
  * This time should be substantially longer than the swapping time.
  */
-#define TIME_TO_CLEAN_UP	5400
+
+#ifndef JOF_DEBUG
+#define TIME_TO_CLEAN_UP	36000
 
 /*
  * How long time until an unused object is swapped out.
@@ -66,8 +70,8 @@
  * Machine with few players and lot of memory: 10000
  * Machine with infinite memory: 0 (never swap).
  */
-#define TIME_TO_SWAP		900
-#define TIME_TO_SWAP_VARIABLES	1800
+#define TIME_TO_SWAP		14000
+#define TIME_TO_SWAP_VARIABLES	22000
 
 /*
  * How many seconds until an object is reset again.
@@ -76,8 +80,19 @@
  * >100 castles:10000	(almost 3 hours).
  */
 #define TIME_TO_RESET	3600	/* one hour */
-
-#define RESET_GRANULARITY 900	/* 15 minutes */
+#else /* JOF_DEBUG */
+#define TIME_TO_CLEAN_UP	540
+#define TIME_TO_SWAP		90
+#define TIME_TO_SWAP_VARIABLES	180
+#define TIME_TO_RESET		360
+#endif
+
+#define RESET_GRANULARITY 300	/* 5 minutes */
+
+#ifdef JOF_DEBUG
+#undef RESET_GRANULARITY
+#define RESET_GRANULARITY 60
+#endif
  
 /*
  * Define the maximum stack size of the stack machine. This stack will also
@@ -103,12 +118,12 @@
  * Maximum number of bits in a bit field. They are stored in printable
  * strings, 6 bits per byte.
  */
-#define MAX_BITS		1200	/* 200 bytes */
+#define MAX_BITS		4800
 
 /*
  * Define what port number the game is to use.
  */
-#define PORTNO			7680
+#define PORTNO			23
 
 /*
  * Max number of local variables in a function.
@@ -119,13 +134,13 @@
  * If this is exceeded, the current function is halted.
  * ls() can take about 30000 for large directories.
  */
-#define MAX_COST	100000
+#define MAX_COST	1000000
 /* to catch an eval_cost too big error in an object that called recursive
  * master functions, CATCH_RESERVED_COST should be greater than
  * MASTER_RESERVED_COST * 2.
  */
-#define CATCH_RESERVED_COST 2000
-#define MASTER_RESERVED_COST 0x200 /* must be power of 2 */
+#define CATCH_RESERVED_COST 4000
+#define MASTER_RESERVED_COST 0x400 /* must be power of 2 */
 
 /*
  * Where to swap out objects. This file is not used if TIME_TO_SWAP is 0.
@@ -133,17 +148,25 @@
  * periodically either, it's a good idea to place the swap file there.
  * The hostname will be appended to the filename defined here.
  */
-#define SWAP_FILE		"LP_SWAP.3"
+#ifndef BLA
+#define SWAP_FILE		"/u/mud/swapfiles/SwapFile"
+#else
+#define SWAP_FILE		"/tmp/MudSwap"
+#endif
 
 /*
  * This is the maximum array size allowed for one single array.
  */
-#define MAX_ARRAY_SIZE 3000
+#if !defined(DEBUG) && !defined(XDEBUG)
+#define MAX_ARRAY_SIZE 10000
+#else
+#define MAX_ARRAY_SIZE 100000
+#endif
 
 /*
  * Maximum number of players in the game.
  */
-#define MAX_PLAYERS	40
+#define MAX_PLAYERS    225
 
 /*
  * When uploading files, we want fast response; however, normal players
@@ -162,8 +185,8 @@
  * If this value is 0, no area will be reserved.
  */
 #define RESERVED_USER_SIZE	800000
-#define RESERVED_MASTER_SIZE	 50000
-#define RESERVED_SYSTEM_SIZE	100000
+#define RESERVED_MASTER_SIZE   100000
+#define RESERVED_SYSTEM_SIZE   200000
 
 /* Define the size of the shared string hash table.  This number needn't
  * be prime, probably between 1000 and 30000; if you set it to about 1/5
@@ -174,7 +197,7 @@
  * If the size is a power of two, hashing will be faster.
  */
 
-#define	HTABLE_SIZE	4096
+#define	HTABLE_SIZE	32768
 
 /* Define the size of the table of defines, reserved words, identifiers
  * and efun names. Should be either several times smaller than HTABLE_SIZE
@@ -189,12 +212,12 @@
  * objects is somewhat more uniform than that of strings.
  */
 
-#define OTABLE_SIZE	1024
+#define OTABLE_SIZE	16384
 
-#define DEFMAX         12000
+#define DEFMAX         32000
 
 /* the number of apply_low cache entries will be 2^APPLY_CACHE_BITS */
-#define APPLY_CACHE_BITS 10
+#define APPLY_CACHE_BITS 12
 
 /*
  * Should newly defined LPC functions be aligned in memory? this costs 1.5
@@ -208,9 +231,9 @@
  * replaces the old command line option -o.
  */
 
-#define COMPAT_MODE
-#undef NATIVE_MODE
-#undef EUIDS
+#undef COMPAT_MODE
+#define NATIVE_MODE
+#define EUIDS
 
 /* Define OLD_PREVIOUS_OBJECT_BEHAVIOUR if the new behaviour gives problems
  * in your security system.
@@ -226,7 +249,7 @@
  * If you don't need it, better #undef it, lest some new wiz can inadvertly
  * crash your mud or make it leak memory.
  */
-#define SUPPLY_PARSE_COMMAND
+#undef SUPPLY_PARSE_COMMAND
 
 /* Define INITIALIZATION_BY___INIT if you want all initializations of variables
  * to be suspended till the object is created ( as supposed to initialization
@@ -234,7 +257,7 @@
  * at cloning, while the former allows to use efuns, e.g. shutdown().
  */
 
-#undef INITIALIZATION_BY___INIT
+#define INITIALIZATION_BY___INIT
 
 /* Define MASTER_NAME if you want something different from "obj/master" resp.
  * "secure/master" as default.
@@ -246,7 +269,7 @@
  * and written with read_bytes and write_bytes
  */
 
-#define MAX_BYTE_TRANSFER 50000
+#define MAX_BYTE_TRANSFER 200000
 
 /* Define FLOATS if you want code for the floating-point type
  */
@@ -280,9 +303,10 @@
 /* When smalloc is used without SBRK_OK, MIN_MALLOCED will lower large block
    fragmentation.
  */
-/* #define MIN_MALLOCED	   0x1000000 */
-#define MAX_MALLOCED	   0x4000000
-#define MAX_SMALL_MALLOCED 0x1000000
+
+#define MIN_MALLOCED	   0x80000
+#define MAX_MALLOCED	   0xe000000
+#define MAX_SMALL_MALLOCED 0x4000000
 
 #undef SMALLOC_TRACE /* do 'make clean' after changing this... */
 #undef SMALLOC_LPC_TRACE /* do 'make clean' after changing this... */
Only in driver.140: config.h~
Only in driver.140: config.status
diff -u -r --ignore-space-change driver/dumpstat.c driver.140/dumpstat.c
--- driver/dumpstat.c	Mon Nov  2 22:49:18 1998
+++ driver.140/dumpstat.c	Wed Nov 26 13:45:23 1997
@@ -207,12 +207,13 @@
 	} else {
 	    tmp = 0;
 	}
-	fprintf(f, "%-20s %5ld ref %2ld %s %s (%ld) %s\n", ob->name,
+	fprintf(f, "%-20s %5ld ref %2ld %s %s (%.0lf) %s\n", ob->name,
 		tmp + (long)data_size(ob) + sizeof (struct object) +
 		sizeof(p_int) /* smalloc overhead */ ,
 		ob->ref,
 		ob->flags & O_HEART_BEAT ? "HB" : "  ",
-		ob->super ? ob->super->name : "--",/*ob->cpu*/ 0L,
+		ob->super ? ob->super->name : "--",
+                (double)ob->_my_cost, /* Kirk: was 0L */
 		swapstrings[(O_PROG_SWAPPED(ob)?1:0) | (O_VAR_SWAPPED(ob)?2:0)]
 	);
     }
diff -u -r --ignore-space-change driver/func_spec driver.140/func_spec
--- driver/func_spec	Mon Nov  2 22:49:18 1998
+++ driver.140/func_spec	Sat Feb  6 22:42:16 1999
@@ -181,6 +181,7 @@
 mixed *filter_array(mixed *, string|closure|mapping, ...);
 int find_call_out(string|closure);
 object find_object(string);
+mixed *object_info(object);
 string function_exists(string, object default: F_THIS_OBJECT);
 string implode(string *, string);
 int input_to(string, void|int, ...);
@@ -220,6 +221,7 @@
 string set_bit(string, int);
 int set_heart_beat(int);
 int set_light(int);
+void set_next_reset(int);
 void set_this_object(object);
 int sizeof(mixed *|mapping);
 mixed *slice_array F_RANGE (mixed *,int,int);
@@ -433,6 +435,7 @@
 int attach_erq_demon(object|string, int default: F_CONST0);
 int send_erq(int, int*|string, closure default: F_CONST0);
 #endif
+int absolute_hb_count();
 #ifdef UDP_SEND
 int send_imp(string, int, string|int*);
 #endif
diff -u -r --ignore-space-change driver/hosts/fcrypt/crack-fcrypt.c driver.140/hosts/fcrypt/crack-fcrypt.c
--- driver/hosts/fcrypt/crack-fcrypt.c	Mon Nov  2 22:38:10 1998
+++ driver.140/hosts/fcrypt/crack-fcrypt.c	Wed Nov 26 13:22:13 1997
@@ -517,7 +517,7 @@
 }
 
 char *
-fcrypt (pw, salt)
+crypt (pw, salt)
     char *pw;
     char *salt;
 {
Only in driver/hosts: win32
diff -u -r --ignore-space-change driver/interpret.c driver.140/interpret.c
--- driver/interpret.c	Mon Nov  2 22:49:18 1998
+++ driver.140/interpret.c	Sat Feb  6 22:58:16 1999
@@ -122,6 +122,7 @@
 extern struct object *current_heart_beat, *current_interactive;
 extern int out_of_memory;
 extern char *out_of_memory_string;
+extern int absolute_hb_num;
 
 /* A function call can cause an eval_cost overflow linear to the number of
  * shadows. Well, adding more than a million is likely to cause memory
@@ -220,7 +221,8 @@
 #define ASSIGN_EVAL_COST \
     if (current_object->user)\
 	current_object->user->cost += eval_cost - assigned_eval_cost;\
-    assigned_eval_cost = eval_cost;
+	current_object->_my_cost += eval_cost - assigned_eval_cost;\
+    assigned_eval_cost = eval_cost; /* Kirk */
 
 void assign_eval_cost() { ASSIGN_EVAL_COST }
 
@@ -3403,6 +3405,10 @@
     CASE(F_POP_VALUE);
 	pop_stack();
 	break;
+    CASE(F_SET_NEXT_RESET);
+        TYPE_TEST1(sp, T_NUMBER)
+        set_next_reset(sp->u.number);
+        break;
     CASE(F_DUP);
 	sp++;
 	assign_svalue_no_free(sp, sp-1);
@@ -7888,6 +7894,70 @@
 	pc++;
 	break;
     }
+#ifdef F_OBJECT_INFO
+    CASE(F_OBJECT_INFO);
+    {
+	struct vector *oi;
+	struct svalue *v;
+	int flags, i;
+	struct object *ob, *prev, *obj2;
+	char xtmp[1024];
+
+	TYPE_TEST1(sp,T_OBJECT);
+	ob=sp->u.ob;
+	oi = allocate_array(20);
+	v = oi->item;
+	flags=ob->flags;
+
+	v[ 0].u.number = (flags & O_HEART_BEAT ? 1 : 0);
+	v[ 1].u.number = (flags & O_IS_WIZARD ? 1 : 0);
+	v[ 2].u.number = (flags & O_ENABLE_COMMANDS ? 1 : 0);
+	v[ 3].u.number = (flags & O_CLONE ? 1 : 0);
+	v[ 4].u.number = (flags & O_DESTRUCTED ? 1 : 0);
+	v[ 5].u.number = (flags & O_SWAPPED ? 1 : 0);
+	v[ 6].u.number = (flags & O_ONCE_INTERACTIVE ? 1 : 0);
+	v[ 7].u.number = (flags & O_APPROVED ? 1 : 0);
+	v[ 8].u.number = (flags & O_RESET_STATE ? 1 : 0);
+	v[ 9].u.number = (flags & O_WILL_CLEAN_UP ? 1 : 0);
+	v[10].u.number = ob->total_light;
+	v[11].u.number = ob->next_reset;
+	v[12].u.number = ob->time_of_ref;
+	v[13].u.number = ob->ref;
+	v[14].u.number = (int)ob->_my_cost;
+	v[15].u.number = O_SWAP_NUM(ob);
+
+	v[16].type = T_STRING;
+	v[16].x.string_type = STRING_MALLOC;
+	v[16].u.string = string_copy(ob->name);
+	
+	v[17].type = T_STRING;
+	v[17].x.string_type = STRING_MALLOC;
+	for (obj2=ob->next_all; obj2 && obj2->flags & O_DESTRUCTED;)
+	    obj2=obj2->next_all;
+	sprintf(xtmp,"%s",obj2->next_all?obj2->name:"NULL");
+	v[17].u.string = string_copy(xtmp);
+	
+	v[18].type = T_STRING;
+	v[18].x.string_type = STRING_MALLOC;
+	sprintf(xtmp,"NULL");
+	for (prev=0,obj2=obj_list,i=0;obj2;obj2=obj2->next_all) {
+	    if ( !(obj2->flags & O_DESTRUCTED) )
+		prev = obj2, i++;
+	    if (obj2->next_all == ob) {
+		if (prev) 
+		    sprintf(xtmp,"%s",prev->name);
+		else 
+		    i=-1;
+		break;
+	    }
+	}
+	v[18].u.string = string_copy(xtmp);
+	v[19].u.number = i;
+	
+	push_referenced_vector(oi);
+	break;
+    }
+#endif /* F_OBJECT_INFO */
 #ifdef F_RUSAGE
     CASE(F_RUSAGE);
     {
@@ -10257,10 +10327,13 @@
 	    malloc_privilege = save_privilege;
 	}
     offset = p - progp->program;
-#ifdef DEBUG
     if (p < progp->program || p > PROGRAM_END(*progp))
-	fatal("Illegal offset %d in object %s\n", offset, progp->name);
-#endif
+    {
+      (void)printf("Illegal offset %d in object %s\n", offset, progp->name);
+      debug_message("Illegal offset %d in object %s\n", offset, progp->name);
+      return 0;
+    }
+	/*fatal("Illegal offset %d in object %s\n", offset, progp->name);*/
     include_names = progp->strings + progp->num_strings;
     for (i=0,p=progp->line_numbers; ; ) {
 	int o;
@@ -10430,6 +10503,8 @@
 	if (p > &control_stack[0] && p->funstart == p[-1].funstart)
 	{
 	    unsigned char *pc = p->pc;
+	    if (!pc) goto not_catch;/* Quickhack - Marcus */
+	    	
 	    if (*pc == F_LBRANCH - F_OFFSET) {
 		union {
 		    char bytes[2];
@@ -12049,6 +12124,14 @@
     return sp;
 }
 
+struct svalue *f_absolute_hb_count(sp)
+   struct svalue *sp;
+{   
+    sp++;
+    put_number(absolute_hb_num);
+    return sp;
+}
+
 struct svalue *f_set_modify_command(sp)
     struct svalue *sp;
 {
@@ -12343,6 +12426,7 @@
 #ifdef DEBUG
 	add_message("extra_ref   : %ld\n", ob->extra_ref);
 #endif
+	add_message("evalcost    : %.0lf\n", (double)ob->_my_cost); /* Kirk */
 	add_message("swap_num    : %ld\n", O_SWAP_NUM(ob));
 	add_message("name        : '%s'\n", ob->name);
 	for (obj2 = ob->next_all; obj2 && obj2->flags & O_DESTRUCTED; )
Only in driver.140: lang.y
Only in driver: lpmud.prj
Only in driver.140: machine.h
Only in driver.140: make_func
Only in driver.140: make_func.c
diff -u -r --ignore-space-change driver/object.h driver.140/object.h
--- driver/object.h	Mon Nov  2 22:49:18 1998
+++ driver.140/object.h	Wed Nov 26 13:45:28 1997
@@ -55,6 +55,7 @@
     /* amylaar : used to determine where to check ref counts at all... */
 #endif
     struct svalue *variables;		/* All variables to this program */
+    long long _my_cost; /* Kirk */
 };
 
 struct replace_ob {
diff -u -r --ignore-space-change driver/prolang.y driver.140/prolang.y
--- driver/prolang.y	Mon Nov  2 22:49:18 1998
+++ driver.140/prolang.y	Fri Apr  3 16:21:23 1998
@@ -3328,6 +3328,8 @@
 
 	    check_aggregate_types($4[0]);
 	    num_keys = $4[0] / ($4[1]+1);
+	    if ((num_keys|$4[1]) & ~0xffff)
+	    	yyerror("cannot handle more than 65535 keys/values in mapping aggregate");
 	    if ( (num_keys | $4[1]) &~0xff) {
 		ins_f_byte(F_M_AGGREGATE);
 		ins_short(num_keys);
diff -u -r --ignore-space-change driver/random.c driver.140/random.c
--- driver/random.c	Mon Nov  2 22:49:18 1998
+++ driver.140/random.c	Thu Jun 18 07:56:59 1998
@@ -1,54 +1,71 @@
-/* Copyright 1995 Joern Rennecke */
+#ifndef DRAND48
+#include<stdio.h>
 
-#include "lint.h"
-
-/* Implement a(i) = a(i-24) + a(i-55) */
-
-#define OFFSET1 24U
-#define OFFSET2 55U
-#define RAND_STATE_SIZE OFFSET2
-#define RAND_I_SHIFT (sizeof(int) * 4U)
-
-static struct {
-  mp_uint pred[RAND_STATE_SIZE];
-  unsigned int i;
-} rand_state;
-
-mp_uint random_number(n)
-    mp_uint n;
+/* Period parameters */  
+#define N 624
+#define M 397
+#define MATRIX_A 0x9908b0df   /* constant vector a */
+#define UPPER_MASK 0x80000000 /* most significant w-r bits */
+#define LOWER_MASK 0x7fffffff /* least significant r bits */
+
+/* Tempering parameters */   
+#define TEMPERING_MASK_B 0x9d2c5680
+#define TEMPERING_MASK_C 0xefc60000
+#define TEMPERING_SHIFT_U(y)  (y >> 11)
+#define TEMPERING_SHIFT_S(y)  (y << 7)
+#define TEMPERING_SHIFT_T(y)  (y << 15)
+#define TEMPERING_SHIFT_L(y)  (y >> 18)
+
+static unsigned long mt[N]; /* the array for the state vector  */
+static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */
+
+/* initializing the array with a NONZERO seed */
+void
+seed_random(seed)
+    unsigned long seed;
 {
-    unsigned int i;
-    mp_uint sum;
-
-    i = rand_state.i;
-    i++;
-    i &= i - RAND_STATE_SIZE >> RAND_I_SHIFT;
-    rand_state.i = i;
-    sum = rand_state.pred[i];
-    i -= OFFSET2 - OFFSET1;
-    i += RAND_STATE_SIZE & i >> RAND_I_SHIFT;
-    sum = rand_state.pred[i] += sum;
-#if defined(HAVE_LONG_LONG) && SIZEOF_P_INT == 4
-    return (unsigned long long)sum * (unsigned long long)n >>
-	sizeof(mp_uint) * 8;
-#else
-    return sum % n;
-#endif
+    /* setting initial seeds to mt[N] using         */
+    /* the generator Line 25 of Table 1 in          */
+    /* [KNUTH 1981, The Art of Computer Programming */
+    /*    Vol. 2 (2nd Ed.), pp102]                  */
+    mt[0]= seed & 0xffffffff;
+    for (mti=1; mti<N; mti++)
+        mt[mti] = (69069 * mt[mti-1]) & 0xffffffff;
 }
 
-void seed_random(seed)
-    int seed;
+unsigned long 
+random_number(unsigned int n)
 {
-    int i;
+    unsigned long y;
+    static unsigned long mag01[2]={0x0, MATRIX_A};
+    /* mag01[x] = x * MATRIX_A  for x=0,1 */
+
+    if (mti >= N) { /* generate N words at one time */
+        int kk;
+
+        if (mti == N+1)   /* if sgenrand() has not been called, */
+            seed_random(4357); /* a default initial seed is used   */
+
+        for (kk=0;kk<N-M;kk++) {
+            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
+            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
+        }
+        for (;kk<N-1;kk++) {
+            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
+            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
+        }
+        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
+        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];
+
+        mti = 0;
+    }
+  
+    y = mt[mti++];
+    y ^= TEMPERING_SHIFT_U(y);
+    y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;
+    y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;
+    y ^= TEMPERING_SHIFT_L(y);
 
-    memset(rand_state.pred, seed, sizeof rand_state.pred);
-    rand_state.pred[0] = seed;
-    rand_state.pred[RAND_STATE_SIZE-2] = seed;
-    rand_state.i = seed & RAND_STATE_SIZE - 1;
-    strcpy((char *)&rand_state.pred[1],
-      "The quick brown fox jumps over the lazy dog\n");
-    i = RAND_STATE_SIZE * 3;
-    do {
-	random_number(1);
-    } while (--i);
+    return y%n; 
 }
+#endif /* DRAND48 */
Only in driver.140: random.c.amylaar
diff -u -r --ignore-space-change driver/regexp.c driver.140/regexp.c
--- driver/regexp.c	Mon Nov  2 22:49:18 1998
+++ driver.140/regexp.c	Wed Nov 26 13:49:31 1997
@@ -1,6 +1,6 @@
-/* $Source: wk/diff-141-mg990220 $
+/* $Source: wk/diff-141-mg990220 $
  *
- * $Revision: 1.1 $
+ * $Revision: 1.1 $
  *
  * regexp.c - regular expression matching
  *
@@ -151,7 +151,7 @@
 #include "lint.h" /* for <string.h>, <values.h> and free() */
 
 #ifndef lint
-static char    *Ident = "$Id: diff-141-mg990220 1.1 Mon, 22 Feb 1999 17:05:44 -0700 baron $";
+static char    *Ident = "$Id: diff-141-mg990220 1.1 Mon, 22 Feb 1999 17:05:44 -0700 baron $";
 #endif
 
 
diff -u -r --ignore-space-change driver/simulate.c driver.140/simulate.c
--- driver/simulate.c	Mon Nov  2 22:49:18 1998
+++ driver.140/simulate.c	Sat Feb  6 22:44:46 1999
@@ -461,6 +461,7 @@
     ob->prog = prog;
     ob->next_all = obj_list;
     obj_list = ob;
+    ob->_my_cost=0; /* Kirk */
     enter_object_hash(ob);	/* add name to fast object lookup table */
 
     push_give_uid_error_context(ob);
@@ -614,6 +615,7 @@
 	fatal("clone_object() from no current_object !\n");
 #endif
     new_ob->next_all = obj_list;
+    new_ob->_my_cost=0; /* Kirk */
     obj_list = new_ob;
     enter_object_hash(new_ob);	/* Add name to fast object lookup table */
     push_give_uid_error_context(new_ob);
@@ -4383,4 +4385,21 @@
 	}
     }
     return sp;
+}
+
+void set_next_reset(num)
+    int num;
+{
+    extern int current_time;
+
+    if (current_object->flags & O_DESTRUCTED) return;
+    if (num>=0) {
+        int oldnum;
+
+        oldnum=num;
+        num+=current_time;
+        if (num<oldnum) num=MAXINT;
+    }
+    else num=MAXINT;
+    current_object->next_reset = num;
 }
diff -u -r --ignore-space-change driver/swap.c driver.140/swap.c
--- driver/swap.c	Mon Nov  2 22:49:18 1998
+++ driver.140/swap.c	Thu Feb 18 22:26:52 1999
@@ -24,6 +24,7 @@
  * Swap out programs / variables from objects.
  */
 
+extern int current_time;
 mp_int num_swapped = 0, num_unswapped = 0;
 mp_int total_bytes_swapped = 0, total_bytes_unswapped = 0;
 mp_int num_swapfree = 0;
@@ -1060,6 +1061,7 @@
     int result;
 
     result = 0;
+    ob->next_reset = current_time + random_number(TIME_TO_RESET);
     swap_num = (p_int)ob->prog;
     if (swap_num & 1) {
 	extern int errno;
diff -u -r --ignore-space-change driver/telnet.h driver.140/telnet.h
--- driver/telnet.h	Mon Nov  2 22:38:10 1998
+++ driver.140/telnet.h	Mon Feb  8 16:23:11 1999
@@ -91,9 +91,14 @@
 #define	TELOPT_TSPEED	32	/* terminal speed */
 #define	TELOPT_LFLOW	33	/* remote flow control */
 #define TELOPT_LINEMODE	34	/* Linemode option */
+#define TELOPT_XDISPLOC 35      /* X Display Location */
+#define	TELOPT_ENVIRON	36	/* Environment opt for Port ID */
+#define TELOPT_AUTHENTICATION 37/* authentication */
+#define TELOPT_ENCRYPT 38/* authentication */
+#define	TELOPT_NEWENV	39	/* Environment opt for Port ID */
 #define	TELOPT_EXOPL	255	/* extended-options-list */
 
-#define	NTELOPTS	(1+TELOPT_LINEMODE)
+#define	NTELOPTS	(256)		/* yes */
 #ifdef TELOPTS
 char *telopts[NTELOPTS] = {
 	"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
