diff -u -r --ignore-space-change driver/dumpstat.c driver.140/dumpstat.c
--- driver/dumpstat.c	Mon Nov  2 22:49:18 1998
+++ driver.140/dumpstat.c	Wed Nov 26 13:45:23 1997
@@ -207,12 +207,13 @@
 	} else {
 	    tmp = 0;
 	}
-	fprintf(f, "%-20s %5ld ref %2ld %s %s (%ld) %s\n", ob->name,
+	fprintf(f, "%-20s %5ld ref %2ld %s %s (%.0lf) %s\n", ob->name,
 		tmp + (long)data_size(ob) + sizeof (struct object) +
 		sizeof(p_int) /* smalloc overhead */ ,
 		ob->ref,
 		ob->flags & O_HEART_BEAT ? "HB" : "  ",
-		ob->super ? ob->super->name : "--",/*ob->cpu*/ 0L,
+		ob->super ? ob->super->name : "--",
+                (double)ob->_my_cost, /* Kirk: was 0L */
 		swapstrings[(O_PROG_SWAPPED(ob)?1:0) | (O_VAR_SWAPPED(ob)?2:0)]
 	);
     }
diff -u -r --ignore-space-change driver/func_spec driver.140/func_spec
--- driver/func_spec	Mon Nov  2 22:49:18 1998
+++ driver.140/func_spec	Sat Feb  6 22:42:16 1999
@@ -181,6 +181,7 @@
 mixed *filter_array(mixed *, string|closure|mapping, ...);
 int find_call_out(string|closure);
 object find_object(string);
+mixed *object_info(object);
 string function_exists(string, object default: F_THIS_OBJECT);
 string implode(string *, string);
 int input_to(string, void|int, ...);
@@ -220,6 +221,7 @@
 string set_bit(string, int);
 int set_heart_beat(int);
 int set_light(int);
+void set_next_reset(int);
 void set_this_object(object);
 int sizeof(mixed *|mapping);
 mixed *slice_array F_RANGE (mixed *,int,int);
@@ -433,6 +435,7 @@
 int attach_erq_demon(object|string, int default: F_CONST0);
 int send_erq(int, int*|string, closure default: F_CONST0);
 #endif
+int absolute_hb_count();
 #ifdef UDP_SEND
 int send_imp(string, int, string|int*);
 #endif
diff -u -r --ignore-space-change driver/interpret.c driver.140/interpret.c
--- driver/interpret.c	Mon Nov  2 22:49:18 1998
+++ driver.140/interpret.c	Sat Feb  6 22:58:16 1999
@@ -122,6 +122,7 @@
 extern struct object *current_heart_beat, *current_interactive;
 extern int out_of_memory;
 extern char *out_of_memory_string;
+extern int absolute_hb_num;
 
 /* A function call can cause an eval_cost overflow linear to the number of
  * shadows. Well, adding more than a million is likely to cause memory
@@ -220,7 +221,8 @@
 #define ASSIGN_EVAL_COST \
     if (current_object->user)\
 	current_object->user->cost += eval_cost - assigned_eval_cost;\
-    assigned_eval_cost = eval_cost;
+	current_object->_my_cost += eval_cost - assigned_eval_cost;\
+    assigned_eval_cost = eval_cost; /* Kirk */
 
 void assign_eval_cost() { ASSIGN_EVAL_COST }
 
@@ -3403,6 +3405,10 @@
     CASE(F_POP_VALUE);
 	pop_stack();
 	break;
+    CASE(F_SET_NEXT_RESET);
+        TYPE_TEST1(sp, T_NUMBER)
+        set_next_reset(sp->u.number);
+        break;
     CASE(F_DUP);
 	sp++;
 	assign_svalue_no_free(sp, sp-1);
@@ -7888,6 +7894,70 @@
 	pc++;
 	break;
     }
+#ifdef F_OBJECT_INFO
+    CASE(F_OBJECT_INFO);
+    {
+	struct vector *oi;
+	struct svalue *v;
+	int flags, i;
+	struct object *ob, *prev, *obj2;
+	char xtmp[1024];
+
+	TYPE_TEST1(sp,T_OBJECT);
+	ob=sp->u.ob;
+	oi = allocate_array(20);
+	v = oi->item;
+	flags=ob->flags;
+
+	v[ 0].u.number = (flags & O_HEART_BEAT ? 1 : 0);
+	v[ 1].u.number = (flags & O_IS_WIZARD ? 1 : 0);
+	v[ 2].u.number = (flags & O_ENABLE_COMMANDS ? 1 : 0);
+	v[ 3].u.number = (flags & O_CLONE ? 1 : 0);
+	v[ 4].u.number = (flags & O_DESTRUCTED ? 1 : 0);
+	v[ 5].u.number = (flags & O_SWAPPED ? 1 : 0);
+	v[ 6].u.number = (flags & O_ONCE_INTERACTIVE ? 1 : 0);
+	v[ 7].u.number = (flags & O_APPROVED ? 1 : 0);
+	v[ 8].u.number = (flags & O_RESET_STATE ? 1 : 0);
+	v[ 9].u.number = (flags & O_WILL_CLEAN_UP ? 1 : 0);
+	v[10].u.number = ob->total_light;
+	v[11].u.number = ob->next_reset;
+	v[12].u.number = ob->time_of_ref;
+	v[13].u.number = ob->ref;
+	v[14].u.number = (int)ob->_my_cost;
+	v[15].u.number = O_SWAP_NUM(ob);
+
+	v[16].type = T_STRING;
+	v[16].x.string_type = STRING_MALLOC;
+	v[16].u.string = string_copy(ob->name);
+	
+	v[17].type = T_STRING;
+	v[17].x.string_type = STRING_MALLOC;
+	for (obj2=ob->next_all; obj2 && obj2->flags & O_DESTRUCTED;)
+	    obj2=obj2->next_all;
+	sprintf(xtmp,"%s",obj2->next_all?obj2->name:"NULL");
+	v[17].u.string = string_copy(xtmp);
+	
+	v[18].type = T_STRING;
+	v[18].x.string_type = STRING_MALLOC;
+	sprintf(xtmp,"NULL");
+	for (prev=0,obj2=obj_list,i=0;obj2;obj2=obj2->next_all) {
+	    if ( !(obj2->flags & O_DESTRUCTED) )
+		prev = obj2, i++;
+	    if (obj2->next_all == ob) {
+		if (prev) 
+		    sprintf(xtmp,"%s",prev->name);
+		else 
+		    i=-1;
+		break;
+	    }
+	}
+	v[18].u.string = string_copy(xtmp);
+	v[19].u.number = i;
+	
+	push_referenced_vector(oi);
+	break;
+    }
+#endif /* F_OBJECT_INFO */
 #ifdef F_RUSAGE
     CASE(F_RUSAGE);
     {
@@ -12049,6 +12124,14 @@
     return sp;
 }
 
+struct svalue *f_absolute_hb_count(sp)
+   struct svalue *sp;
+{   
+    sp++;
+    put_number(absolute_hb_num);
+    return sp;
+}
+
 struct svalue *f_set_modify_command(sp)
     struct svalue *sp;
 {
@@ -12343,6 +12426,7 @@
 #ifdef DEBUG
 	add_message("extra_ref   : %ld\n", ob->extra_ref);
 #endif
+	add_message("evalcost    : %.0lf\n", (double)ob->_my_cost); /* Kirk */
 	add_message("swap_num    : %ld\n", O_SWAP_NUM(ob));
 	add_message("name        : '%s'\n", ob->name);
 	for (obj2 = ob->next_all; obj2 && obj2->flags & O_DESTRUCTED; )
diff -u -r --ignore-space-change driver/object.h driver.140/object.h
--- driver/object.h	Mon Nov  2 22:49:18 1998
+++ driver.140/object.h	Wed Nov 26 13:45:28 1997
@@ -55,6 +55,7 @@
     /* amylaar : used to determine where to check ref counts at all... */
 #endif
     struct svalue *variables;		/* All variables to this program */
+    long long _my_cost; /* Kirk */
 };
 
 struct replace_ob {
diff -u -r --ignore-space-change driver/random.c driver.140/random.c
--- driver/random.c	Mon Nov  2 22:49:18 1998
+++ driver.140/random.c	Thu Jun 18 07:56:59 1998
@@ -1,54 +1,71 @@
-/* Copyright 1995 Joern Rennecke */
+#ifndef DRAND48
+#include<stdio.h>
 
-#include "lint.h"
-
-/* Implement a(i) = a(i-24) + a(i-55) */
-
-#define OFFSET1 24U
-#define OFFSET2 55U
-#define RAND_STATE_SIZE OFFSET2
-#define RAND_I_SHIFT (sizeof(int) * 4U)
-
-static struct {
-  mp_uint pred[RAND_STATE_SIZE];
-  unsigned int i;
-} rand_state;
-
-mp_uint random_number(n)
-    mp_uint n;
+/* Period parameters */  
+#define N 624
+#define M 397
+#define MATRIX_A 0x9908b0df   /* constant vector a */
+#define UPPER_MASK 0x80000000 /* most significant w-r bits */
+#define LOWER_MASK 0x7fffffff /* least significant r bits */
+
+/* Tempering parameters */   
+#define TEMPERING_MASK_B 0x9d2c5680
+#define TEMPERING_MASK_C 0xefc60000
+#define TEMPERING_SHIFT_U(y)  (y >> 11)
+#define TEMPERING_SHIFT_S(y)  (y << 7)
+#define TEMPERING_SHIFT_T(y)  (y << 15)
+#define TEMPERING_SHIFT_L(y)  (y >> 18)
+
+static unsigned long mt[N]; /* the array for the state vector  */
+static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */
+
+/* initializing the array with a NONZERO seed */
+void
+seed_random(seed)
+    unsigned long seed;
 {
-    unsigned int i;
-    mp_uint sum;
-
-    i = rand_state.i;
-    i++;
-    i &= i - RAND_STATE_SIZE >> RAND_I_SHIFT;
-    rand_state.i = i;
-    sum = rand_state.pred[i];
-    i -= OFFSET2 - OFFSET1;
-    i += RAND_STATE_SIZE & i >> RAND_I_SHIFT;
-    sum = rand_state.pred[i] += sum;
-#if defined(HAVE_LONG_LONG) && SIZEOF_P_INT == 4
-    return (unsigned long long)sum * (unsigned long long)n >>
-	sizeof(mp_uint) * 8;
-#else
-    return sum % n;
-#endif
+    /* setting initial seeds to mt[N] using         */
+    /* the generator Line 25 of Table 1 in          */
+    /* [KNUTH 1981, The Art of Computer Programming */
+    /*    Vol. 2 (2nd Ed.), pp102]                  */
+    mt[0]= seed & 0xffffffff;
+    for (mti=1; mti<N; mti++)
+        mt[mti] = (69069 * mt[mti-1]) & 0xffffffff;
 }
 
-void seed_random(seed)
-    int seed;
+unsigned long 
+random_number(unsigned int n)
 {
-    int i;
+    unsigned long y;
+    static unsigned long mag01[2]={0x0, MATRIX_A};
+    /* mag01[x] = x * MATRIX_A  for x=0,1 */
+
+    if (mti >= N) { /* generate N words at one time */
+        int kk;
+
+        if (mti == N+1)   /* if sgenrand() has not been called, */
+            seed_random(4357); /* a default initial seed is used   */
+
+        for (kk=0;kk<N-M;kk++) {
+            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
+            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
+        }
+        for (;kk<N-1;kk++) {
+            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
+            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
+        }
+        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
+        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];
+
+        mti = 0;
+    }
+  
+    y = mt[mti++];
+    y ^= TEMPERING_SHIFT_U(y);
+    y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;
+    y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;
+    y ^= TEMPERING_SHIFT_L(y);
 
-    memset(rand_state.pred, seed, sizeof rand_state.pred);
-    rand_state.pred[0] = seed;
-    rand_state.pred[RAND_STATE_SIZE-2] = seed;
-    rand_state.i = seed & RAND_STATE_SIZE - 1;
-    strcpy((char *)&rand_state.pred[1],
-      "The quick brown fox jumps over the lazy dog\n");
-    i = RAND_STATE_SIZE * 3;
-    do {
-	random_number(1);
-    } while (--i);
+    return y%n; 
 }
+#endif /* DRAND48 */
diff -u -r --ignore-space-change driver/simulate.c driver.140/simulate.c
--- driver/simulate.c	Mon Nov  2 22:49:18 1998
+++ driver.140/simulate.c	Sat Feb  6 22:44:46 1999
@@ -461,6 +461,7 @@
     ob->prog = prog;
     ob->next_all = obj_list;
     obj_list = ob;
+    ob->_my_cost=0; /* Kirk */
     enter_object_hash(ob);	/* add name to fast object lookup table */
 
     push_give_uid_error_context(ob);
@@ -614,6 +615,7 @@
 	fatal("clone_object() from no current_object !\n");
 #endif
     new_ob->next_all = obj_list;
+    new_ob->_my_cost=0; /* Kirk */
     obj_list = new_ob;
     enter_object_hash(new_ob);	/* Add name to fast object lookup table */
     push_give_uid_error_context(new_ob);
@@ -4383,4 +4385,21 @@
 	}
     }
     return sp;
+}
+
+void set_next_reset(num)
+    int num;
+{
+    extern int current_time;
+
+    if (current_object->flags & O_DESTRUCTED) return;
+    if (num>=0) {
+        int oldnum;
+
+        oldnum=num;
+        num+=current_time;
+        if (num<oldnum) num=MAXINT;
+    }
+    else num=MAXINT;
+    current_object->next_reset = num;
 }
