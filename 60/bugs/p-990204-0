Short: Patches from Finalfrontier
From: Stefan Riemer <Barbara.Riemer@t-online.de>
Date: 990204
Type: Patch
State: Unclassified

ich hab mal in einem Anflug von Wahnsinn versucht, die Aenderungen, die
DanS@FF an den Sourcen bis zur 3.2.1@141 gemacht hat, auf die 3.2.5 zu
uebertragen. Ich hatte das Changelog vom FF-Driver bei Dir im wk-Verzeichnis
gefunden und das hat mich auf die Idee gebracht. Da ich das ganze auf ner
NT-Machine unter der Cygwin-Umgebung mache, sind gleich noch ein paar
Patches dafuer rausgekommen.

Ok, falls es interessant ist und Du was einbauen willst, muesstest du
allerdings DanS fragen, da der Code nicht von mir ist.
Soweit es die Cygwin-Sachen betrifft: viel Spass damit.
Das Define dafuer heisst uebrigens __CYGWIN__, nicht mehr __CYGWIN32__.

Tschau sagt Stefan (Peng@FinalFrontier)


Index: Makefile.in
===================================================================
RCS file: /usr/src/cvs/ldmud/Makefile.in,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** Makefile.in	1998/12/30 20:17:25	3.2.5.1
--- Makefile.in	1998/12/31 11:39:42	3.2.5.2
***************
*** 86,90 ****
  
  install: driver
! 	$(INSTALL) -c $? $(BINDIR)/parse
  
  install-utils:
--- 86,90 ----
  
  install: driver
! 	$(INSTALL) -c $?@EXEEXT@ $(BINDIR)/parse@EXEEXT@
  
  install-utils:
***************
*** 95,100 ****
  
  parse: driver
! 	-$(MV) parse parse.old
! 	$(CP) driver parse
  
  lint: *.c
--- 95,100 ----
  
  parse: driver
! 	-$(MV) parse@EXEEXT@ parse.old
! 	$(CP) driver@EXEEXT@ parse@EXEEXT@
  
  lint: *.c
***************
*** 104,112 ****
  	$(RM) $(YACCTAB)h $(YACCTAB)c make_func.c *.o make_func@EXEEXT@
  	$(RM) efun_defs.c instrs.h lang.y lang.h lang.c y.output tags TAGS
! 	$(RM) parse core mudlib/core mudlib/debug.log lpmud.log driver
  	(cd util ; echo "Cleaning in util." ; $(MAKE) clean)
  
  distclean: clean
! 	$(RM) driver config.status machine.h Makefile
  
  tags: $(SRC)
--- 104,112 ----
  	$(RM) $(YACCTAB)h $(YACCTAB)c make_func.c *.o make_func@EXEEXT@
  	$(RM) efun_defs.c instrs.h lang.y lang.h lang.c y.output tags TAGS
! 	$(RM) parse@EXEEXT@ core mudlib/core mudlib/debug.log lpmud.log driver@EXEEXT@
  	(cd util ; echo "Cleaning in util." ; $(MAKE) clean)
  
  distclean: clean
! 	$(RM) driver@EXEEXT@ config.status machine.h Makefile
  
  tags: $(SRC)
Index: backend.c
===================================================================
RCS file: /usr/src/cvs/ldmud/backend.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** backend.c	1998/12/30 20:17:24	3.2.5.1
--- backend.c	1998/12/31 11:39:42	3.2.5.2
***************
*** 63,66 ****
--- 63,67 ----
  #include "mapping.h"
  #include "my-alloca.h"
+ #include "my-rusage.h"
  #include "object.h"
  #include "regexp.h"
***************
*** 127,130 ****
--- 128,134 ----
  int32 assigned_eval_cost; /* TODO: What is this? */
  
+ int32 eval_start_time;
+   /* The start time for running eval, used by get_eval_time */
+ 
  /* TODO: BOOL */ int extra_jobs_to_do = MY_FALSE;
    /* True: the backend has other things to do in this cycle than just
***************
*** 185,188 ****
--- 189,197 ----
  
  
+ #ifdef LAZY_SWAP
+ struct _swap_cache * swap_cache;
+ static struct _swap_cache * swap_cache_top;
+ #endif /* LAZY_SWAP */
+ 
  /* --- Forward declarations --- */
  
***************
*** 277,281 ****
--- 286,363 ----
  
  #endif
+ #ifdef LAZY_SWAP
+ static void
+ try_to_swap ()
+ {
+     int i;
  
+     for (i = LAZY_SWAP; i--; )
+     {
+       int time_since_ref;
+       
+       if (!swap_cache->next && !swap_cache->ob)
+ 	    {
+ 	      if (swap_cache != swap_cache_top)
+ 	        fatal ("swap_cache_top does not point correctly to the top of the FIFO\n");
+ 	        return;
+ 	    }
+ 
+       time_since_ref = current_time - swap_cache->ob->time_of_ref;
+       if ((swap_cache->ob->flags & O_DESTRUCTED) ||
+ 	        (swap_cache->ob->flags & O_HEART_BEAT) ||
+ 	        (time_since_ref < time_to_swap) )
+ 	    {
+ 	      if (swap_cache->next)
+ 	      {
+ 	        struct _swap_cache * dummy = swap_cache->next;
+ 
+ 	        swap_cache->ob = NULL;
+ 	        swap_cache->next = NULL;
+ 	        xfree (swap_cache);
+ 	        swap_cache = dummy;
+ 	      }
+ 	      else
+ 	      {
+ 	        /* this is never touched; but we should have this */
+ 	        swap_cache->ob = NULL;
+ 	        return;
+ 	      }
+ 	  
+ 	    continue;
+ 	    }
+       
+       /* lets swap ... first try to swap variables */
+       if (time_since_ref >= time_to_swap_variables)
+ 	      if (!O_VAR_SWAPPED(swap_cache->ob))
+ 	      {
+ 	        if (d_flag)
+ 	          fprintf(stderr, "swap vars of %s\n", swap_cache->ob->name);
+ 	        swap_variables (swap_cache->ob);
+ 	      }
+         if (!O_PROG_SWAPPED(swap_cache->ob))
+ 	      {
+ 	        if (d_flag)
+ 	          fprintf(stderr, "swap %s\n", swap_cache->ob->name);
+ 	        swap_program (swap_cache->ob);
+ 	      }
+         if (swap_cache->next)
+ 	      {
+       	  struct _swap_cache * dummy = swap_cache->next;
+ 	  
+ 	        swap_cache->ob = NULL;
+ 	        swap_cache->next = NULL;
+ 	        xfree (swap_cache);
+ 	        swap_cache = dummy;
+ 	      }
+         else
+ 	      {
+ 	        /* this is never touched; but we should have this */
+       	  swap_cache->ob = NULL;
+ 	        return;
+ 	      }
+     } /* for */
+ }
+ #endif /* LAZY_SWAP */
+ 
  /*-------------------------------------------------------------------------*/
  void
***************
*** 298,308 ****
  
      prepare_ipc();
! 
      (void)signal(SIGHUP,  (RETSIGTYPE(*)PROT((int)))f_shutdown);
      (void)signal(SIGUSR1, (RETSIGTYPE(*)PROT((int)))startmasterupdate);
      if (!t_flag) {
          ALARM_HANDLER_FIRST_CALL(catch_alarm);
          call_heart_beat();
      }
  #ifdef AMIGA
      atexit(exit_alarm_timer);
--- 380,399 ----
  
      prepare_ipc();
! #ifndef NEW_SIGNAL_HANDLING
      (void)signal(SIGHUP,  (RETSIGTYPE(*)PROT((int)))f_shutdown);
      (void)signal(SIGUSR1, (RETSIGTYPE(*)PROT((int)))startmasterupdate);
+ #else
+     init_signal_handler();
+ #endif /* NEW_SIGNAL_HANDLING */
      if (!t_flag) {
          ALARM_HANDLER_FIRST_CALL(catch_alarm);
          call_heart_beat();
      }
+ #ifdef LAZY_SWAP
+     swap_cache = xalloc (sizeof (struct _swap_cache));
+     swap_cache->ob = NULL;
+     swap_cache->next = NULL;
+     swap_cache_top = swap_cache;
+ #endif /* LAZY_SWAP */
  #ifdef AMIGA
      atexit(exit_alarm_timer);
***************
*** 339,343 ****
--- 430,442 ----
  
          CLEAR_EVAL_COST;
+ 	{
+ 	  struct rusage rus;
  
+ 	  if (getrusage(RUSAGE_SELF, &rus) < 0)
+ 	    eval_start_time = 0;
+ 	  else
+ 	    eval_start_time = RUSAGE_TIME(rus.ru_utime) +
+ 	                      RUSAGE_TIME(rus.ru_stime);
+ 	}
          /* Execute pending deallocations */
  #ifdef C_ALLOCA
***************
*** 416,419 ****
--- 515,522 ----
           */
  
+ #ifdef LAZY_SWAP
+       	try_to_swap ();  /* lets try to swap something */
+ #endif /* LAZY_SWAP */
+ 
          if (get_message(buff))
          {
***************
*** 582,586 ****
  
          /* Check if a reset() is due. */
!         if (ob->next_reset < current_time && !(ob->flags & O_RESET_STATE)) {
              if (d_flag)
                  fprintf(stderr, "RESET %s\n", ob->name);
--- 685,698 ----
  
          /* Check if a reset() is due. */
!   	if ((ob->flags & O_WILL_RESET) && ob->next_reset < current_time
! #if RESET_IF_SWAPPED == 0
! 	      && !(ob->flags & O_RESET_STATE)
! #else
! #if RESET_IF_SWAPPED == -1
! 	      && (!(ob->flags & O_RESET_STATE) || (ob->flags & O_RESET_IF_SWAPPED))
! #endif /* RESET_IF_SWAPPED == -1 */
! #endif /* RESET_IF_SWAPPED == 0 */
! 	      )
! 	      {
              if (d_flag)
                  fprintf(stderr, "RESET %s\n", ob->name);
***************
*** 656,677 ****
           * out.
           */
!         if ((time_to_swap <= 0 && time_to_swap_variables <= 0)
!         ||  (ob->flags & O_HEART_BEAT))
!             continue;
!         if (time_since_ref >= time_to_swap_variables && time_to_swap_variables > 0) {
!             if (!O_VAR_SWAPPED(ob)) {
!                 if (d_flag)
!                     fprintf(stderr, "swap vars of %s\n", ob->name);
!                 swap_variables(ob);
!             }
!         }
!         if (time_since_ref >= time_to_swap && time_to_swap_variables > 0) {
!             if (!O_PROG_SWAPPED(ob)) {
!                 if (d_flag)
!                     fprintf(stderr, "swap %s\n", ob->name);
!                 swap_program(ob);
!             }
!         }
! #endif
      }
      error_recovery_pointer = error_recovery_info.last;
--- 768,798 ----
           * out.
           */
! 	if ((time_since_ref < time_to_swap) || (ob->flags & O_HEART_BEAT))
! 	    continue;
! #ifndef LAZY_SWAP
! 	if (time_since_ref >= time_to_swap_variables) {
! 	    if (!O_VAR_SWAPPED(ob)) {
! 		if (d_flag)
! 		    fprintf(stderr, "swap vars of %s\n", ob->name);
! 		swap_variables(ob);
! 	    }
! 	}
! 	if (!O_PROG_SWAPPED(ob)) {
! 	    if (d_flag)
! 		fprintf(stderr, "swap %s\n", ob->name);
! 	    swap_program(ob);	/* See if it is possible to swap out to disk */
! 	}
! #else
! 	if (((time_since_ref >= time_to_swap_variables) && !O_VAR_SWAPPED(ob)) ||
! 	    !O_PROG_SWAPPED(ob) )
! 	  {
! 	    swap_cache_top->ob = ob;
! 	    swap_cache_top->next = xalloc (sizeof (struct _swap_cache));
! 	    swap_cache_top->next->ob = NULL;
! 	    swap_cache_top->next->next = NULL;
! 	    swap_cache_top = swap_cache_top->next;
! 	  }
! #endif /* LAZY_SWAP */
! #endif /* TIME_TO_SWAP > 0 || TIME_TO_SWAP_VARIABLES > 0 */
      }
      error_recovery_pointer = error_recovery_info.last;
Index: comm.c
===================================================================
RCS file: /usr/src/cvs/ldmud/comm.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2.1.1
diff -c -2 -r3.2.5.1 -r3.2.5.2.1.1
*** comm.c	1998/12/30 20:17:24	3.2.5.1
--- comm.c	1998/12/31 17:12:02	3.2.5.2.1.1
***************
*** 140,147 ****
  #endif /* SunOS4 */
  
- #if defined(__CYGWIN32__)
- extern int socketpair(int, int, int, int[2]);
- #endif
- 
  #ifndef EPROTO
  #    define EPROTO EINTR
--- 140,143 ----
***************
*** 231,234 ****
--- 227,232 ----
    /* The first free entry in the freelist in pending_erq[] */
  
+ #endif /* ERQ_DEMON */            // was ten lines wrong, we need IPSIZE even if we have ERQ_DEMON not defined
+ 
  #define IPSIZE 200
  static struct ipentry {
***************
*** 240,245 ****
     */
  
- #endif /* ERQ_DEMON */
- 
  /*-------------------------------------------------------------------------*/
  
--- 238,241 ----
***************
*** 1601,1606 ****
           *   tricky, we check if the socket is actually ready, to prevent
           *   freezing.
           */
! #ifndef __BEOS__
          if (udp_s >= 0)
  #else
--- 1597,1603 ----
           *   tricky, we check if the socket is actually ready, to prevent
           *   freezing.
+          * Same for CYGWIN, it aktually freezes the driver without FD_ISSET (Stef)
           */
! #if !defined(__BEOS__) && !defined(__CYGWIN__)
          if (udp_s >= 0)
  #else
***************
*** 1681,1684 ****
--- 1678,1687 ----
                          continue;
                      }
+                     if (errno == ESHUTDOWN) {
+                         debug_message("Connection to socket %d is lost.\n",
+                                       ip->socket);
+                         remove_interactive(ip->ob);
+                         continue;
+                     }
                      perror("read");
                      debug_message("Unknown errno %d\n", errno);
***************
*** 2110,2114 ****
--- 2113,2119 ----
      set_socket_nonblocking(new_socket);
      set_close_on_exec(new_socket);
+ #ifndef __CYGWIN__
      set_socket_own(new_socket);
+ #endif /* __CYGWIN__ */
  
  #ifdef ACCESS_CONTROL
Index: config.h
===================================================================
RCS file: /usr/src/cvs/ldmud/config.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** config.h	1998/12/30 20:17:24	3.2.5.1
--- config.h	1998/12/31 11:39:42	3.2.5.2
***************
*** 2,5 ****
--- 2,110 ----
  #define __CONFIG_H__ 1
  
+ /* the driver now handles the most recent signals and fatals
+    by calling the driver hook H_CRASH, wich maybe either a string with the
+    name of the function to call in the master object or a closure with
+    up to 3 arguments:
+ 	    H_CRASH == T_STRING:
+ 	      call the function named by H_CRASH with 3 arguments:
+ 	        1. argument: a string containing the reason why the driver
+ 		   goes down
+ 		2. argument: type object; will contain the command giver
+ 		   for the current execution or 0 if none
+ 		3. argument: type object; will contain the current object
+ 		   or 0 if none
+ 	    H_CRASH == T_CLOSURE:
+ 	      call the closure with up to 3 arguments. Arguments and types are
+ 	      as specified above. If the number of arguments is less than 3
+ 	      the list will be truncated.
+    default type for the hook is T_STRING; default value is "crash"
+    default signal for offline-reload of the master object: SIGUSR1
+    define this if you want to include th new signal handling package */
+ #define NEW_SIGNAL_HANDLING
+ 
+ /* Include code for EFun 'reload_object'. This function resets the specified
+    object without reloading it from the source.
+    The idea and some lines of source are taken from the MudOS
+    development project*/
+ #define RELOAD_OBJECT
+ 
+ /* Include code for some additional math EFuns:
+    float ceil  (float f)          - returns the smallest int not < f
+    float floor (float f)          - returns the largest int not > f
+    float pow   (float x, float y) - returns x^y */
+ #define ADDITIONAL_MATH
+ 
+ /* Include code for EFun int set_eval_cost(int a).
+    return types and actions:
+    a == 0 - reset the maximum number of evaluation nodes per loop
+    a < 0  - return the maximum number of evaluation nodes per loop
+    a > 0  - set the maximum number of evaluation nodes per loop to a
+    The idea and some lines of source are taken from the MudOS
+    development project. */
+ #define SET_EVAL_COST
+ 
+ /* Include code for EFun int get_eval_time(). This EFun returns the number of
+    miliseconds since the start of the current evaluation loop. */
+ #define GET_EVAL_TIME
+ 
+ /* Include code for the get_num_args EFun.
+    this efun returns the number of arguments for the current function.
+    This only works if you assign the return value of get_num_args()
+    to a local variable.*/
+ #define GET_NUM_ARGS
+ 
+ /* write the drivers process ID into a file called
+    'driver_pid' inside the directory where the driver is installed 
+    (BIN_DIR in Makefile) */
+ #define WRITE_PID
+ 
+ /* Include code for a new functionality of the '...' operator:
+    it now expands function arguments:
+      void test (int x, int y, int z) {}
+    the call
+      a = ({ 1, 2, 3 });
+      test(a...);
+    results in:
+      x = 1;
+      y = 2
+      z = 3;
+    (idea taken from the MudOS development project)
+    */
+ #define EXPAND_ARRAY
+ 
+ /* If you define this the EFun mixed debug_info (int flag, object obj)
+    gets some additional features
+    flag == 5 - returns the size of obj in memory
+    flag == 6 - returns the time obj was last referenced
+    flag == 7 - returns obj's reference count
+    flag == 8 - returns true if obj is swapped */
+ #define XTENDED_DEBUG_INFO
+ 
+ /* default value for RESET_IF_SWAPPED is 0
+    If RESET_IF_SWAPPED equals:
+      0 :  this is the old behaviour;
+           the driver will not reset objects swapped out
+      1 :  the driver will reset objects even if they are swapped out
+      -1:  the driver will only reset swapped objects if they have
+           the O_RESET_IF_SWAPPED bit set. This bit will be set during
+ 	  the creation phase of the object using the driver hook
+ 	  H_RESET_IF_SWAPPED which maybe either a closure or a string.
+ 	  if the type of H_RESET_IF_SWAPPED equals:
+ 	    T_STRING
+ 	      the driver will call the function namend by the hook inside
+ 	      the object. Remember - this is done once during creation time
+ 	    T_CLOSURE
+ 	      the driver will call the closure
+ 	  If the hook returns 0 no reset will be called if the object is
+ 	  swapped. A value other than 0 will result in calling reset
+ 	  for this object even if it is swapped out. */
+ #define RESET_IF_SWAPPED -1
+ 
+ /* If lazy swapping is enabled, the look_for_objects_to_swap function
+    in backend.c just fills a FIFO. That FIFO is then emptied during
+    the next loops, prozessing LAZY_SWAP objects each loop. */
+ /* #define LAZY_SWAP 10 */
+ #undef LAZY_SWAP
+ 
  /* Should code for the external request demon be included?
   */
Index: configure
===================================================================
RCS file: /usr/src/cvs/ldmud/configure,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** configure	1998/12/30 20:17:24	3.2.5.1
--- configure	1998/12/31 11:39:43	3.2.5.2
***************
*** 2535,2552 ****
    CONFIG_SHELL='/bin/sh'
  fi
! if test "${OSTYPE}" = 'win32'; then
    EXEEXT='.exe'
-   
- {
- test -n "$verbose" && \
- echo "	defining" HOST_INCLUDE to be \"hosts/GnuWin32/GnuWin32.h\"
- echo "#define" HOST_INCLUDE \"hosts/GnuWin32/GnuWin32.h\" >> confdefs.h
- DEFS="$DEFS -DHOST_INCLUDE=\"hosts/GnuWin32/GnuWin32.h\""
- SEDDEFS="${SEDDEFS}\${SEDdA}HOST_INCLUDE\${SEDdB}HOST_INCLUDE\${SEDdC}\"hosts/GnuWin32/GnuWin32.h\"\${SEDdD}
- \${SEDuA}HOST_INCLUDE\${SEDuB}HOST_INCLUDE\${SEDuC}\"hosts/GnuWin32/GnuWin32.h\"\${SEDuD}
- \${SEDeA}HOST_INCLUDE\${SEDeB}HOST_INCLUDE\${SEDeC}\"hosts/GnuWin32/GnuWin32.h\"\${SEDeD}
- "
- }
- 
  fi
  
--- 2535,2540 ----
    CONFIG_SHELL='/bin/sh'
  fi
! if test "${OSTYPE}" = 'cygwin32'; then
    EXEEXT='.exe'
  fi
  
Index: datatypes.h
===================================================================
RCS file: /usr/src/cvs/ldmud/datatypes.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** datatypes.h	1998/12/30 20:17:25	3.2.5.1
--- datatypes.h	1998/12/31 11:39:43	3.2.5.2
***************
*** 241,243 ****
--- 241,250 ----
  #endif
  
+ #ifdef LAZY_SWAP
+ struct _swap_cache {
+   struct object * ob;
+   struct _swap_cache * next;
+ };
+ #endif /* LAZY_SWAP */
+ 
  #endif /* __DATATYPES_H__ */
Index: exec.h
===================================================================
RCS file: /usr/src/cvs/ldmud/exec.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** exec.h	1998/12/30 20:17:25	3.2.5.1
--- exec.h	1998/12/31 11:39:43	3.2.5.2
***************
*** 212,216 ****
--- 212,232 ----
  #define H_ERQ_STOP          15
  #define H_MODIFY_COMMAND_FNAME 16
+ #if defined(NEW_SIGNAL_HANDLING) && RESET_IF_SWAPPED == -1
+ #define H_CRASH           17
+ #define H_RESET_IF_SWAPPED 18
+ #define NUM_CLOSURE_HOOKS 19
+ #else
+ #if !defined(NEW_SIGNAL_HANDLING) && RESET_IF_SWAPPED == -1
+ #define H_RESET_IF_SWAPPED 17
+ #define NUM_CLOSURE_HOOKS 18
+ #else
+ #if defined(NEW_SIGNAL_HANDLING) && RESET_IF_SWAPPED != -1
+ #define H_CRASH           17
+ #define NUM_CLOSURE_HOOKS 18
+ #else
  #define NUM_CLOSURE_HOOKS 17
+ #endif /* NEW_SIGNAL_HANDLING && RESET_IF_SWAPPED != -1 */
+ #endif /* !NEW_SIGNAL_HANDLING && RESET_IF_SWAPPED == -1 */
+ #endif /* NEW_SIGNAL_HANDLING && RESET_IF_SWAPPED == -1 */
  
  extern struct svalue closure_hook[NUM_CLOSURE_HOOKS];
Index: func_spec
===================================================================
RCS file: /usr/src/cvs/ldmud/func_spec,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** func_spec	1998/12/30 20:17:25	3.2.5.1
--- func_spec	1998/12/31 11:39:43	3.2.5.2
***************
*** 91,94 ****
--- 91,97 ----
  "!"     not
  ".."    range
+ #ifdef EXPAND_ARRAY
+ "..."	expand
+ #endif /* EXPAND_ARRAY */
  
    /* These values are used by the stack machine, and can not be directly
***************
*** 181,184 ****
--- 184,190 ----
  string clear_bit(string, int);
  object clone_object(string);
+ #ifdef RELOAD_OBJECT
+ void reload_object(object);
+ #endif
  int command(string, void|object);
  string crypt(string, string|int default: F_CONST0);
***************
*** 389,392 ****
--- 395,403 ----
  float exp(float);
  float sqrt(float);
+ #ifdef ADDITIONAL_MATH
+ float ceil(float);
+ float floor(float);
+ float pow(float, float);
+ #endif /* ADDITIONAL_MATH */
  #endif /* TRANSCENDENT_FUNCTIONS */
  
***************
*** 404,407 ****
--- 415,430 ----
  int typeof(mixed);
  mixed get_type_info(mixed, int default: F_THIS_OBJECT);
+ 
+ #ifdef SET_EVAL_COST
+ int set_eval_cost(int default: F_CONST0);
+ #endif /* SET_EVAL_COST */
+ 
+ #ifdef GET_EVAL_TIME
+ int get_eval_time();
+ #endif /* GET_EVAL_TIME */
+ 
+ #ifdef GET_NUM_ARGS
+ int get_num_args();
+ #endif /* GET_NUM_ARGS */
  
  /*---------------------------------------------------------------------------
Index: interpret.c
===================================================================
RCS file: /usr/src/cvs/ldmud/interpret.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** interpret.c	1998/12/30 20:17:25	3.2.5.1
--- interpret.c	1998/12/31 11:39:43	3.2.5.2
***************
*** 159,162 ****
--- 159,170 ----
  #define STACK_OVERFLOW(sp, fp, pc) stack_overflow(sp, fp, pc)
  
+ #ifdef EXPAND_ARRAY
+ static int f_expand = 0;
+ #endif /* EXPAND_ARRAY */
+ 
+ #ifdef F_GET_NUM_ARGS
+ static unsigned short num_args_for_function;
+ #endif /* F_GET_NUM_ARGS */
+ 
  /* defines and a helpfun for F_TERMINAL_COLOUR */
  
***************
*** 2872,2875 ****
--- 2880,2887 ----
      int num_arg;
  
+ #ifdef EXPAND_ARRAY
+     f_expand = 0;
+ #endif
+ 
      inter_fp = sp - csp->num_local_variables + 1;
      num_arg = EXTRACT_SCHAR(&funstart[0]);
***************
*** 3741,3744 ****
--- 3753,3768 ----
      }
  #endif /* F_CLONE_OBJECT */
+ #ifdef F_RELOAD_OBJECT
+     CASE(F_RELOAD_OBJECT);
+     {
+         assign_eval_cost();
+         TYPE_TEST1(sp, T_OBJECT)
+         inter_sp = sp;
+         inter_pc = pc;
+         reload_object(sp->u.ob);
+         pop_stack();
+         break;
+     }
+ #endif /* F_RELOAD_OBJECT */
      CASE(F_AGGREGATE);
      {
***************
*** 3981,3984 ****
--- 4005,4011 ----
           */
          csp->num_local_variables = EXTRACT_UCHAR(pc);
+ #ifdef EXPAND_ARRAY
+       	csp->num_local_variables += f_expand;
+ #endif /* EXPAND_ARRAY */
          flags = setup_new_frame1(func_offset, 0, 0);
          funstart = current_prog->program + (flags & FUNSTART_MASK);
***************
*** 6017,6020 ****
--- 6044,6050 ----
              csp->funstart = funstart;
              csp->num_local_variables = num_arg;
+ #ifdef EXPAND_ARRAY
+       	    csp->num_local_variables += f_expand;
+ #endif /* EXPAND_ARRAY */
              current_prog = prog = entry->program;
              function_index_offset = entry->function_index_offset;
***************
*** 9720,9723 ****
--- 9750,9798 ----
            }
  #endif
+ #ifdef ADDITIONAL_MATH
+ #ifdef F_CEIL
+ 	  XCASE(F_CEIL);
+ 	  {
+ 	    STORE_DOUBLE_USED
+ 	    double d;
+ 
+ 	    if (sp->type != T_FLOAT) goto xbad_arg_1;
+ 	    d = ceil(READ_DOUBLE(sp));
+ 	    STORE_DOUBLE(sp, d);
+ 	    break;
+ 	  }
+ #endif /* F_CEIL */
+ #ifdef F_FLOOR
+ 	  XCASE(F_FLOOR);
+ 	  {
+ 	    STORE_DOUBLE_USED
+ 	    double d;
+ 
+ 	    if (sp->type != T_FLOAT) goto xbad_arg_1;
+ 	    d = floor(READ_DOUBLE(sp));
+ 	    STORE_DOUBLE(sp, d);
+ 	    break;
+ 	  }
+ #endif /* F_FLOOR */
+ #ifdef F_POW
+ 	  XCASE(F_POW);
+ 	  {
+ 	    STORE_DOUBLE_USED
+ 	    double x, y, d;
+ 	    
+ 	    if ((sp-1)->type != T_FLOAT) goto xbad_arg_1;
+ 	    x = READ_DOUBLE((sp - 1));
+ 	    if (sp->type != T_FLOAT) goto xbad_arg_2;
+ 	    y = READ_DOUBLE(sp);
+ 	    if (((x == 0.) && (y < 0.)) ||
+ 		((x < 0.) && (y != (double)((int)y))) )
+ 	      goto xbad_arg_2;
+ 	    d = pow (x, y);
+ 	    pop_stack();
+ 	    STORE_DOUBLE(sp, d);
+ 	    break;
+ 	  }
+ #endif /* F_POW */
+ #endif /* ADDITIONAL_MATH */
            XCASE(F_CALL_RESOLVED);
            {
***************
*** 9864,9867 ****
--- 9939,9958 ----
              ERRORF(("%s", sp->u.string));
            }
+ 	  XCASE(F_GET_EVAL_TIME);
+ 	  {
+ 	    struct rusage rus;
+ 	    extern int32 eval_start_time;
+ 
+ 	    if (getrusage(RUSAGE_SELF, &rus) < 0)
+ 	      {
+ 		push_number(0);
+ 		break;
+ 	      }
+ 	    
+ 	    push_number ((RUSAGE_TIME(rus.ru_utime) +
+ 			  RUSAGE_TIME(rus.ru_stime)) -
+ 			 eval_start_time);
+ 	    break;
+ 	  }
            XCASE(F_GET_EVAL_COST);
            {
***************
*** 9869,9872 ****
--- 9960,9995 ----
              break;
            }
+ 	  XCASE(F_SET_EVAL_COST);
+ 	  {
+ 	    if ((sp->type != T_NUMBER) || (sp->u.number < -1))
+ 	      goto xbad_arg_1;
+ 	    if (privilege_violation("set_eval_cost", sp) > 0)
+ 	      {
+ 		switch (sp->u.number)
+ 		  {
+ 		  case 0 :
+ 		    sp->u.number = -CLEAR_EVAL_COST;
+ 		    break;
+ 		  case -1 :
+ 		    sp->u.number = -initial_eval_cost;
+ 		    break;
+ 		  default :
+ 		    {
+ 		      p_int dummy;
+ 		  
+ 		      dummy = -initial_eval_cost;
+ 		      initial_eval_cost = -sp->u.number;
+ 		      sp->u.number = dummy;
+ 		      break;
+ 		    }
+ 		  }
+ 	      }
+ 	    break;
+ 	  }
+ 	  XCASE(F_GET_NUM_ARGS);
+ 	  {
+ 	    push_number (num_args_for_function);
+ 	    break;
+ 	  }
            XCASE(F_GARBAGE_COLLECTION);
            {
***************
*** 10182,10185 ****
--- 10305,10311 ----
              csp->prev_ob = previous_ob;
              csp->num_local_variables = num_arg;
+ #ifdef EXPAND_ARRAY
+       	    csp->num_local_variables += f_expand;
+ #endif /* EXPAND_ARRAY */
              csp->funstart = funstart = cache_funstart[ix];
              current_prog = cache_progp[ix];
***************
*** 10245,10248 ****
--- 10371,10377 ----
                  cache_name[ix] = shared_name;
                  csp->num_local_variables = num_arg;
+ #ifdef EXPAND_ARRAY
+           	    csp->num_local_variables += f_expand;
+ #endif /* EXPAND_ARRAY */
                  current_prog = progp;
                  flags = setup_new_frame1(fx, 0, 0);
***************
*** 12534,12538 ****
            flags&O_DESTRUCTED      ?"TRUE":"FALSE");
          add_message("O_SWAPPED         : %s\n",
!           flags&O_SWAPPED          ?"TRUE":"FALSE");
          add_message("O_ONCE_INTERACTIVE: %s\n",
            flags&O_ONCE_INTERACTIVE?"TRUE":"FALSE");
--- 12663,12667 ----
            flags&O_DESTRUCTED      ?"TRUE":"FALSE");
          add_message("O_SWAPPED         : %s\n",
!           flags&O_SWAPPED         ?"TRUE":"FALSE");
          add_message("O_ONCE_INTERACTIVE: %s\n",
            flags&O_ONCE_INTERACTIVE?"TRUE":"FALSE");
***************
*** 12543,12546 ****
--- 12672,12677 ----
          add_message("O_WILL_CLEAN_UP   : %s\n",
            flags&O_WILL_CLEAN_UP   ?"TRUE":"FALSE");
+       	add_message("O_WILL_RESET      : %s\n",
+ 		      flags&O_WILL_RESET      ?"TRUE":"FALSE");
          add_message("total light : %d\n", ob->total_light);
          add_message("next_reset  : %d\n", ob->next_reset);
***************
*** 12647,12650 ****
--- 12778,12833 ----
          break;
        }
+ #ifdef XTENDED_DEBUG_INFO
+       /* return object-size */
+       case 5:
+       {
+ 	struct program *pg;
+ 	mp_int tmp;
+ 	
+ 	if (num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+ 	TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	if(!O_PROG_SWAPPED(sp->u.ob) &&
+ 	   (sp->u.ob->ref == 1 || !(sp->u.ob->flags & O_CLONE)))
+ 	  tmp = sp->u.ob->prog->total_size;
+ 	else
+ 	  tmp = 0;
+ 	res.type = T_NUMBER;
+ 	pg = sp->u.ob->prog;
+ 	res.u.number = tmp + (long)data_size(sp->u.ob) + sizeof(struct object) +
+ 	  sizeof(p_int);
+ 	break;
+       }
+       /* return time_of_last_ref */
+       case 6:
+       {
+ 	if (num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+ 	TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	res.type = T_NUMBER;
+ 	res.u.number = (p_int)sp->u.ob->time_of_ref;
+ 	break;
+       }
+       /* return ref_count */
+       case 7:
+       {
+ 	if(num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+         TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	res.type = T_NUMBER;
+ 	res.u.number = (p_int)sp->u.ob->ref;
+ 	break;
+       }
+       /* return if object is swapped */
+       case 8:
+       {
+ 	if (num_arg != 2)
+ 	  ERROR("bad number of arguments to debug_info\n")
+ 	TYPE_TEST2(arg+1, T_OBJECT, F_DEBUG_INFO)
+ 	res.type = T_NUMBER;
+ 	res.u.number = O_PROG_SWAPPED(sp->u.ob);
+ 	break;
+       }
+ #endif /* XTENDED_DEBUG_INFO */
        default: bad_xefun_vararg(1, sp);
      }
***************
*** 12677,12680 ****
--- 12860,12866 ----
      csp->prev_ob = previous_ob;
      csp->num_local_variables = num_arg;
+ #ifdef EXPAND_ARRAY
+     csp->num_local_variables += f_expand;
+ #endif /* EXPAND_ARRAY */
      previous_ob = current_object;
  
***************
*** 12746,12749 ****
--- 12932,12938 ----
          csp->prev_ob = previous_ob;
          csp->num_local_variables = num_arg;
+ #ifdef EXPAND_ARRAY
+    	    csp->num_local_variables += f_expand;
+ #endif /* EXPAND_ARRAY */
          previous_ob = current_object;
          current_object = l->function.alien.ob;
Index: lex.c
===================================================================
RCS file: /usr/src/cvs/ldmud/lex.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** lex.c	1998/12/30 20:17:25	3.2.5.1
--- lex.c	1998/12/31 11:39:43	3.2.5.2
***************
*** 643,646 ****
--- 643,656 ----
          add_permanent_define("__EUIDS__", -1, string_copy(""), MY_FALSE);
  #endif
+ #ifdef EXPAND_ARRAY
+ 	      add_permanent_define("EXPAND_ARRAY", -1, string_copy(""), 0);
+ #endif
+ #if defined(RESET_IF_SWAPPED) && RESET_IF_SWAPPED
+ 	      sprintf(mtext, "%d", RESET_IF_SWAPPED);
+ 	      add_permanent_define("RESET_IF_SWAPPED", -1, string_copy(mtext), 0);
+ #endif
+ #ifdef XTENDED_DEBUG_INFO
+ 	      add_permanent_define("XTENDED_DEBUG_INFO", -1, string_copy(""), 0);
+ #endif
      mtext[0] = '"';
      mtext[1] = '/';
Index: main.c
===================================================================
RCS file: /usr/src/cvs/ldmud/main.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** main.c	1998/12/30 20:17:25	3.2.5.1
--- main.c	1998/12/31 11:39:44	3.2.5.2
***************
*** 172,175 ****
--- 172,185 ----
      char *p;
  
+ #ifdef WRITE_PID
+   /* Just to write out the PID for further use in scripts */
+     FILE * driver_pid;
+     if ((driver_pid = fopen (BINDIR"/driver_pid", "w")) != NULL)
+       {
+ 	    fprintf (driver_pid, "%d\n", (int)getpid ());
+ 	    fclose (driver_pid);
+       }
+ #endif
+ 
      /* Initialisations */
  
Index: object.c
===================================================================
RCS file: /usr/src/cvs/ldmud/object.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** object.c	1998/12/30 20:17:25	3.2.5.1
--- object.c	1998/12/31 11:39:44	3.2.5.2
***************
*** 1789,1790 ****
--- 1789,1851 ----
  }
  #endif /* 0 */
+ 
+ #ifdef F_RELOAD_OBJECT
+ void
+ reload_object(struct object *ob)
+ {
+     int i;
+   
+     if (!ob->prog || (ob->flags & O_DESTRUCTED))
+       return;
+     for (i = 0; i < (int) ob->prog->num_variables; i++)
+     {
+       free_svalue(&ob->variables[i]);
+       ob->variables[i] = const0;
+     }
+     if (ob->flags & O_SWAPPED)
+       if (load_ob_from_swap(ob) < 0)
+         error("Out of memory\n");
+ 
+     if (O_GET_SHADOW(ob)->shadowed_by && !O_GET_SHADOW(ob)->shadowing)
+     {
+       struct svalue svp;
+       struct object * ob2;
+ 
+       svp.type = T_OBJECT;
+       for (ob2 = O_GET_SHADOW(ob)->shadowed_by; ob2;)
+ 	    {
+ 	      svp.u.ob = ob2;
+ 	      ob2 = O_GET_SHADOW(ob2)->shadowed_by;
+ 	      O_GET_SHADOW(svp.u.ob)->shadowed_by = 0;
+ 	      O_GET_SHADOW(svp.u.ob)->shadowing = 0;
+ 	      destruct_object(&svp);
+ 	    }
+     }
+     if (O_GET_SHADOW(ob)->shadowing)
+     {
+       O_GET_SHADOW(O_GET_SHADOW(ob)->shadowing)->shadowed_by =
+ 	              O_GET_SHADOW(ob)->shadowed_by;
+       O_GET_SHADOW(ob)->shadowing = 0;
+ 	    ob->flags &= ~O_SHADOW;
+     }
+     if (O_GET_SHADOW(ob)->shadowed_by)
+     {
+       O_GET_SHADOW(O_GET_SHADOW(ob)->shadowed_by)->shadowing =
+ 	              O_GET_SHADOW(ob)->shadowing;
+       O_GET_SHADOW(ob)->shadowed_by = 0;
+     }
+     ob->flags &= ~O_ENABLE_COMMANDS;
+     set_heart_beat(ob, 0);
+     ob->flags |= O_DESTRUCTED;
+     remove_stale_call_outs();
+     ob->flags &= ~O_DESTRUCTED;
+     add_light (ob, -(ob->total_light));
+ #ifdef EUIDS
+     ob->eff_user = NULL;
+ #endif
+     if (ob->flags & O_CLONE)
+       reset_object (ob, H_CREATE_CLONE);
+     else
+       reset_object (ob, H_CREATE_OB);
+ }
+ #endif /* F_RELOAD_OBJECT */
Index: object.h
===================================================================
RCS file: /usr/src/cvs/ldmud/object.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** object.h	1998/12/30 20:17:25	3.2.5.1
--- object.h	1998/12/31 11:39:44	3.2.5.2
***************
*** 37,40 ****
--- 37,44 ----
  #define O_LAMBDA_REFERENCED        0x400 /* be careful with replace_program() */
  #define O_SHADOW                0x800
+ #define O_WILL_RESET            0x2000
+ #if RESET_IF_SWAPPED == -1
+ #define O_RESET_IF_SWAPPED      0x4000    /* Object will reset during swap out */
+ #endif /* RESET_IF_SWAPPED == -1 */
  
  #define O_PROG_SWAPPED(ob) ((p_int)(ob)->prog & 1)
***************
*** 129,132 ****
--- 133,140 ----
  
  #define check_object(o) ((o)&&(o)->flags&O_DESTRUCTED?0:(o))
+ 
+ #ifdef F_RELOAD_OBJECT
+ extern void reload_object PROT((struct object *));
+ #endif /* F_RELOAD_OBJECT */
  
  #endif /* __OBJECT_H__ */
Index: prolang.y
===================================================================
RCS file: /usr/src/cvs/ldmud/prolang.y,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** prolang.y	1998/12/30 20:17:25	3.2.5.1
--- prolang.y	1998/12/31 11:39:44	3.2.5.2
***************
*** 192,195 ****
--- 192,199 ----
  static struct efun_shadow *all_efun_shadows = 0;
  
+ %ifdef EXPAND_ARRAY
+ static char f_expand;
+ %endif
+ 
  #ifdef __STDC__
  void yyerrorf(char *format, ...)
***************
*** 684,687 ****
--- 688,694 ----
      variables_initialized = 0;
  %endif
+ %ifdef EXPAND_ARRAY
+     f_expand = 0;
+ %endif
  }
  
***************
*** 1400,1403 ****
--- 1407,1413 ----
  %right '~' F_NOT
  %nonassoc F_INC F_DEC
+ %ifdef EXPAND_ARRAY
+ %left F_EXPAND
+ %endif /* EXPAND_ARRAY */
  %left F_ARROW '['
  %%
***************
*** 3940,3944 ****
  expr_list3: /* empty */                { $$ = 0; }
           | expr0                { $$ = 1; add_arg_type($1.type); }
!          | expr_list2 ',' expr0        { $$ = $1 + 1; add_arg_type($3.type); } ;
  
  %ifdef MAPPINGS
--- 3950,3971 ----
  expr_list3: /* empty */                { $$ = 0; }
           | expr0                { $$ = 1; add_arg_type($1.type); }
!          | expr_list2 ',' expr0        { $$ = $1 + 1; add_arg_type($3.type); }
! %ifdef EXPAND_ARRAY
!          | expr0 F_EXPAND
! 	{
! 	    $$ = 1;
! 	    add_arg_type($1.type);
!  	    ins_f_byte (F_EXPAND);
! 	    f_expand = 1;
!   	}
!        	 | expr_list2 ',' expr0 F_EXPAND
!         {
! 	    $$ = $1 + 1;
! 	    add_arg_type($3.type);
! 	    ins_f_byte (F_EXPAND);
! 	    f_expand = 1;
!         }
! %endif /* EXPAND_ARRAY */
! ;
  
  %ifdef MAPPINGS
***************
*** 4976,4980 ****
               * Check the argument types.
               */
!             if (exact_types && first_arg != INDEX_START_NONE)
              {
                  int i;
--- 5003,5011 ----
               * Check the argument types.
               */
!             if (exact_types && first_arg != INDEX_START_NONE
! %ifdef EXPAND_ARRAY
!         	       && !f_expand
! %endif
!             )
              {
                  int i;
Index: simulate.c
===================================================================
RCS file: /usr/src/cvs/ldmud/simulate.c,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** simulate.c	1998/12/30 20:17:25	3.2.5.1
--- simulate.c	1998/12/31 11:39:44	3.2.5.2
***************
*** 33,39 ****
  #endif /* NDIR */
  #endif /* not (DIRENT or _POSIX_VERSION) */
- #if defined(__CYGWIN32__)
- extern int lstat PROT((char *, struct stat *));
- #endif
  
  #include "simulate.h"
--- 33,36 ----
***************
*** 94,98 ****
  static void remove_environment_sent PROT((struct object *));
  static int special_parse PROT((char *buff));
! 
  
  char *last_verb = 0;
--- 91,95 ----
  static void remove_environment_sent PROT((struct object *));
  static int special_parse PROT((char *buff));
! static void signal_handler PROT((int sig));
  
  char *last_verb = 0;
***************
*** 315,318 ****
--- 312,355 ----
  } /* make_name_sane() */
  
+ #if RESET_IF_SWAPPED == -1
+ static INLINE void
+ reset_if_swapped(struct object *ob) {
+     if (closure_hook[H_RESET_IF_SWAPPED].type == T_CLOSURE)
+     {
+         extern struct svalue *inter_sp;
+         struct lambda * l;
+       
+         l = closure_hook[H_RESET_IF_SWAPPED].u.lambda;
+       /* we do not expect any arguments */
+       /* bind to target */
+         l->ob = ob;
+         call_lambda (&closure_hook[H_RESET_IF_SWAPPED], 0);
+         if (inter_sp->type == T_NUMBER && !inter_sp->u.number)
+ 	      ; /* do nothing ... */
+         else
+ 	          ob->flags |= O_RESET_IF_SWAPPED;
+             pop_stack ();
+     }
+     else if (closure_hook[H_RESET_IF_SWAPPED].type == T_STRING ||
+              closure_hook[H_RESET_IF_SWAPPED].type == T_NUMBER)
+     {
+         struct svalue * res;
+       
+         if (closure_hook[H_RESET_IF_SWAPPED].type == T_NUMBER)
+ 	          res = sapply ("reset_if_swapped", ob, 0);
+         else
+ 	          res = sapply (closure_hook[H_RESET_IF_SWAPPED].u.string, ob, 0);
+       
+         if (res)
+ 	      {
+ 	          if (res->type == T_NUMBER && !res->u.number)
+ 	          ; /* do nothing ... */
+ 	      else
+ 	          ob->flags |= O_RESET_IF_SWAPPED;
+ 	      }
+     }
+ }
+ #endif /* RESET_IF_SWAPPED == -1 */
+ 
  /*
   * Load an object definition from file. If the object wants to inherit
***************
*** 569,580 ****
--- 606,629 ----
              /* If the master inherits anything -Ugh- we have to have
                 some object to attribute initialized variables to again */
+ #if RESET_IF_SWAPPED == -1
+       	    reset_if_swapped (ob);
+ #endif /* RESET_IF_SWAPPED == -1 */
              current_object = save_current;
          } else {
              current_object = save_current;
              reset_object(ob, H_CREATE_OB - dont_reset);
+ #if RESET_IF_SWAPPED == -1
+       	    reset_if_swapped (ob);
+ #endif /* RESET_IF_SWAPPED == -1 */
          }
      }
      if ( !(ob->flags & O_DESTRUCTED) && function_exists("clean_up",ob) )
+         {
          ob->flags |= O_WILL_CLEAN_UP;
+        	if ( (closure_hook[H_RESET].type == T_STRING &&
+ 	          function_exists(closure_hook[H_RESET].u.string, ob)) ||
+ 	          (closure_hook[H_RESET].type == T_CLOSURE) )
+     	          ob->flags |= O_WILL_RESET;
+         }
      command_giver = check_object(save_command_giver);
      if (d_flag > 1 && ob)
***************
*** 686,690 ****
          error("Out of memory\n");
      new_ob->name = make_new_name(ob->name);
!     new_ob->flags |= O_CLONE | (ob->flags & ( O_APPROVED | O_WILL_CLEAN_UP )) ;
      new_ob->prog = ob->prog;
      reference_prog (ob->prog, "clone_object");
--- 735,739 ----
          error("Out of memory\n");
      new_ob->name = make_new_name(ob->name);
!     new_ob->flags |= O_CLONE | (ob->flags & ( O_APPROVED | O_WILL_CLEAN_UP | O_WILL_RESET )) ;
      new_ob->prog = ob->prog;
      reference_prog (ob->prog, "clone_object");
***************
*** 1140,1144 ****
--- 1189,1230 ----
          ob->sent = 0;
      }
+ #ifdef LAZY_SWAP
+ /* to clear the swap-buffer, if the object to be removed is in 
+  * that buffer, so we can avoid errors about non-existent objects
+  */
+     {
+       extern struct _swap_cache * swap_cache;
  
+       if (!swap_cache->next)
+ 	    {
+ 	      if (swap_cache->ob && (swap_cache->ob == ob))
+ 	        swap_cache->ob = NULL;
+ 	    }
+       else
+ 	    {
+ 	      struct _swap_cache * x = swap_cache;
+ 	      struct _swap_cache * y = NULL;
+ 
+ 	      for (; x->next; y = x, x = x->next)
+ 	      {
+ 	        if (x->ob == ob)
+ 		      {
+ 		        if (y)
+ 		        {
+ 		          y->next = x->next;
+ 		          x->ob = NULL;
+ 		          xfree (x);
+ 		        }
+ 		        else
+ 		        {
+ 		          swap_cache = x->next;
+ 		          x->ob = NULL;
+ 		          xfree (x);
+ 		        }
+ 		      }
+ 	      } /* for */
+ 	    }
+     }
+ #endif LAZY_SWAP
      free_object(ob, "destruct_object");
  }
***************
*** 2829,2833 ****
      debug_parse_buff[sizeof debug_parse_buff - 1] = '\0';
  #endif
!     if (strcmp(buff, "malloc") == 0) {
  #if defined(MALLOC_malloc) || defined(MALLOC_smalloc)
          dump_malloc_data();
--- 2915,2920 ----
      debug_parse_buff[sizeof debug_parse_buff - 1] = '\0';
  #endif
!     if (!is_wizard_used || command_giver->flags & O_IS_WIZARD) {
!        if (strcmp(buff, "malloc") == 0) {
  #if defined(MALLOC_malloc) || defined(MALLOC_smalloc)
          dump_malloc_data();
***************
*** 2841,2845 ****
          return 1;
      }
-     if (!is_wizard_used || command_giver->flags & O_IS_WIZARD) {
          if (strcmp(buff, "dumpallobj") == 0) {
              dumpstat();
--- 2928,2931 ----
***************
*** 3076,3079 ****
--- 3162,3166 ----
  }
  
+ 
  #ifdef __STDC__
  void fatal(char *fmt, ...)
***************
*** 3084,3087 ****
--- 3171,3175 ----
      int a, b, c, d, e, f, g, h;
  #endif
+ #ifndef NEW_SIGNAL_HANDLING   // old code
  {
  #ifdef __STDC__
***************
*** 3129,3135 ****
      *((char*)0) = 0/0;
  #endif
!     abort();
  }
  
  int num_error = 0;
  char *current_error, *current_error_file, *current_error_object_name;
--- 3217,3334 ----
      *((char*)0) = 0/0;
  #endif
! #else /* NEW_SIGNAL_HANDLING */
! {
!   extern char *current_file;
!   extern int current_line;
!   extern struct object *current_object;
!   extern struct object *command_giver;
! 
!   static int in_fatal = 0;
!   char msg_buf[2049];
!   char succ;
! #ifdef __STDC__
!   va_list args;
! #endif
!   /*  char *fmt;*/
! 
!   if (in_fatal)
!     {
!       debug_message ("Fatal error while shutting down.  Aborting.\n");
!     }
!   else
!     {
!       in_fatal = 1;
! #ifdef __STDC__
!       va_start(args, fmt);
!       (void)vsprintf (msg_buf, fmt, args);
!       va_end(args);
! #else
!       (void)sprintf (msg_buf, fmt, a, b, c, d, e, f, g, h);
! #endif
!       debug_message ("!!!!!!!!!! Fatal ERROR: %s\nDriver attempting to "
! 		     "exit gracefully.\n", msg_buf);
!       if (current_file)
! 	debug_message ("(occured during compilation if %s at line %d)\n",
! 		       current_file, current_line);
!       if (current_object)
! 	debug_message ("(current object was /%s)\n",
! 		       (current_object->name));
!       
!       debug_message("Dump of variables:\n");
!       (void)dump_trace (1);
! 
!       succ = 0;
!       if (closure_hook[H_CRASH].type == T_CLOSURE)
! 	{
! 	  struct lambda * l;
! 	 unsigned short args;
! 
! 	  l = closure_hook[H_CRASH].u.lambda;
! 	  l->ob = current_object;
! 	  if (args = l->function.code[1])
! 	    {
! 	      push_string_malloced (string_copy (msg_buf));
! 	      if (args > 1)
! 		if (command_giver)
! 		  push_object (command_giver);
! 		else
! 		  push_number (0);
! 	      if (args > 2)
! 		if (current_object)
! 		  push_object (current_object);
! 		else
! 		  push_number (0);
! 	      if (args > 3)
! 		args = 3;
! 	      call_lambda (&closure_hook[H_CRASH], args);
! 	    }
! 	  else
! 	    call_lambda (&closure_hook[H_CRASH], 0);
! 	  pop_stack ();
! 	  succ = 1;
! 	}
!       else if (closure_hook[H_CRASH].type == T_STRING ||
! 	       closure_hook[H_CRASH].type == T_NUMBER)
! 	{
! 	  struct svalue * res;
! 
! 	  push_string_malloced (string_copy (msg_buf));
! 	  if (command_giver)
! 	    push_object (command_giver);
! 	  else
! 	    push_number (0);
! 	  if (current_object)
! 	    push_object (current_object);
! 	  else
! 	    push_number (0);
! 	  
! 	  if (closure_hook[H_CRASH].type == T_NUMBER)
! 	    res = apply_master_ob ("crash", 3);
! 	  else
! 	    res = apply_master_ob (closure_hook[H_CRASH].u.string, 3);
! 
! 	  succ = !(!res);
! 	}
!       if (succ)
! 	debug_message ("crash function in master object called successfully.  Aborting.\n");
!       else
! 	debug_message ("crash function in master object not found.  Aborting.\n");
!     }
!   flush_all_player_mess ();
! #ifdef SIGABRT
!   (void)signal (SIGABRT, SIG_DFL);
! #endif
! #ifdef SIGILL
!   (void)signal (SIGILL, SIG_DFL);
! #endif
! #ifdef SIGIOT
!   (void)signal (SIGIOT, SIG_DFL);
! #endif
!  in_fatal = 0;
! #endif /* NEW_SIGNAL_HANLDING */
!   abort();
  }
  
+ 
  int num_error = 0;
  char *current_error, *current_error_file, *current_error_object_name;
***************
*** 3567,3570 ****
--- 3766,3770 ----
  int master_will_be_updated = 0;
  
+ 
  struct svalue *f_shutdown(sp)
      struct svalue *sp;
***************
*** 3575,3578 ****
--- 3775,3780 ----
  }
  
+ #ifndef NEW_SIGNAL_HANLDING
+ 
  /* this will be activated by SIGUSR1 */
  void startmasterupdate() {
***************
*** 3583,3586 ****
--- 3785,3921 ----
  }
  
+ #endif /* NEW_SIGNAL_HANDLING */
+ 
+ #ifdef NEW_SIGNAL_HANDLING
+ 
+ void
+ init_signal_handler() {
+ #ifdef SIGHUP
+   (void)signal (SIGHUP, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGINT
+   (void)signal (SIGINT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGQUIT
+   (void)signal (SIGQUIT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGILL
+   (void)signal (SIGILL, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGTRAP
+   (void)signal (SIGTRAP, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGIOT
+   (void)signal (SIGIOT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGEMT
+   (void)signal (SIGEMT, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGFPE
+   (void)signal (SIGFPE, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGBUS
+   (void)signal (SIGBUS, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGSEGV
+   (void)signal (SIGSEGV, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGSYS
+   (void)signal (SIGSYS, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGTERM
+   (void)signal (SIGTERM, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGUSR1
+   (void)signal (SIGUSR1, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGUSR2
+   (void)signal (SIGUSR2, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGCLD
+   (void)signal (SIGCLD, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGPWR
+   (void)signal (SIGPWR, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGIO
+   (void)signal (SIGIO, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ }
+ 
+ 
+ static void
+ signal_handler(int sig) {
+     switch (sig)
+     {
+ #ifdef SIGHUP
+     case SIGHUP : fatal ("Hangup"); break;
+ #endif
+ #ifdef SIGINT
+     case SIGINT : fatal ("Interrupt"); break;
+ #endif
+ #ifdef SIGQUIT
+     case SIGQUIT : fatal ("Quit"); break;
+ #endif
+ #ifdef SIGILL
+     case SIGILL : fatal  ("Illegal instruction"); break;
+ #endif
+ #ifdef SIGTRAP
+     case SIGTRAP : fatal ("Trace trap"); break;
+ #endif
+ #ifdef SIGIOT
+     case SIGIOT :
+ #endif
+ #ifdef SIGEMT
+     case SIGEMT :
+ #endif
+ #if defined(SIGIOT) || defined(SIGEMT)
+       fatal ("Software generated abort"); break;
+ #endif
+ #ifdef SIGFPE
+     case SIGFPE : (void)signal (SIGFPE, (RETSIGTYPE(*)PROT((int)))signal_handler); break;
+ #endif
+ #ifdef SIGBUS
+     case SIGBUS : fatal ("Bus error"); break;
+ #endif
+ #ifdef SIGSEGV
+     case SIGSEGV : fatal ("Segmentation violation"); break;
+ #endif
+ #ifdef SIGSYS
+     case SIGSYS : fatal ("Bad argument to system call"); break;
+ #endif
+ #ifdef SIGUSR1
+     case SIGUSR1 :
+       {
+     	extra_jobs_to_do = MY_TRUE;
+ 	    master_will_be_updated = 1;
+ 	    add_eval_cost (-initial_eval_cost >> 3 );  // to update the master could be very expensive
+ 	    (void)signal (SIGUSR1, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ 	  	break;
+       }
+ #endif
+ #ifdef SIGUSR2
+     case SIGUSR2 : (void) signal (SIGUSR2, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGCLD
+     case SIGCLD :
+       {
+ 	    int status;
+ 	    wait (&status);
+ 	    (void)signal (SIGCLD, (RETSIGTYPE(*)PROT((int)))signal_handler);
+     	break;
+       }
+ #endif
+ #ifdef SIGPWR
+     case SIGPWR : (void)signal (SIGPWR, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+ #ifdef SIGIO
+     case SIGIO : (void)signal (SIGIO, (RETSIGTYPE(*)PROT((int)))signal_handler);
+ #endif
+     }
+ }
+ 
+ #endif /* NEW_SIGNAL_HANDLING */
+ 
  /*
   * This one is called from the command "shutdown".
***************
*** 3611,3614 ****
--- 3946,3950 ----
      exit(0);
  }
+ 
  
  /*
Index: simulate.h
===================================================================
RCS file: /usr/src/cvs/ldmud/simulate.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** simulate.h	1998/12/30 20:17:25	3.2.5.1
--- simulate.h	1998/12/31 11:39:44	3.2.5.2
***************
*** 92,96 ****
--- 92,100 ----
  extern char *check_valid_path PROT((char *path, struct object *caller, char *call_fun, int writeflg));
  extern struct svalue *f_shutdown PROT((struct svalue *sp));
+ #ifndef NEW_SIGNAL_HANDLING
  extern void startmasterupdate PROT((void));
+ #else
+ extern void init_signal_handler();
+ #endif
  extern void shutdowngame PROT((void));
  
Index: hosts/defines.txt
===================================================================
RCS file: /usr/src/cvs/ldmud/hosts/defines.txt,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** hosts/defines.txt	1998/12/30 20:17:27	3.2.5.1
--- hosts/defines.txt	1998/12/31 12:06:45	3.2.5.2
***************
*** 32,35 ****
  ---------
  gcc:			__GNUC__
! Cygnus gcc for Win32    __CYGWIN32__
  Metrowerks (Be)         __MWERKS__
--- 32,35 ----
  ---------
  gcc:			__GNUC__
! Cygnus gcc for Win32    __CYGWIN__
  Metrowerks (Be)         __MWERKS__
Index: hosts/unix.h
===================================================================
RCS file: /usr/src/cvs/ldmud/hosts/unix.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** hosts/unix.h	1998/12/30 20:17:27	3.2.5.1
--- hosts/unix.h	1998/12/31 11:42:01	3.2.5.2
***************
*** 21,25 ****
  #endif
  
! #if defined(SunOS4) || defined(ultrix) || defined(__CYGWIN32__)
  extern int gethostname(char *, int);
  extern char *getdomainname(char *, int);
--- 21,25 ----
  #endif
  
! #if defined(SunOS4) || defined(ultrix)
  extern int gethostname(char *, int);
  extern char *getdomainname(char *, int);
***************
*** 32,41 ****
  #endif
  
! #if defined(__CYGWIN32__) || defined(sun)
  extern time_t time(time_t *tloc);
- #endif
- 
- #if 0 && defined(__CYGWIN32__)
- extern char * ctime(time_t *tloc);
  #endif
  
--- 32,37 ----
  #endif
  
! #ifdef sun
  extern time_t time(time_t *tloc);
  #endif
  
Index: mudlib/sys/driver_hook.h
===================================================================
RCS file: /usr/src/cvs/ldmud/mudlib/sys/driver_hook.h,v
retrieving revision 3.2.5.1
retrieving revision 3.2.5.2
diff -c -2 -r3.2.5.1 -r3.2.5.2
*** mudlib/sys/driver_hook.h	1998/12/30 20:17:30	3.2.5.1
--- mudlib/sys/driver_hook.h	1998/12/31 11:41:22	3.2.5.2
***************
*** 16,17 ****
--- 16,19 ----
  #define H_ERQ_STOP	15
  #define H_MODIFY_COMMAND_FNAME 16
+ #define H_SIGNALS 17
+ #define H_RESET_IF_SWAPPED 18
