*** func_spec.old	Thu Mar  7 22:46:47 1996
--- func_spec	Thu Mar  7 22:47:16 1996
***************
*** 219,225 ****
--- 219,227 ----
  void say(string|mixed *, void|object|object *);
  string set_bit(string, int);
  int set_heart_beat(int);
+ #if 0
  int set_light(int);
+ #endif
  void set_this_object(object);
  int sizeof(mixed *|mapping);
  mixed *slice_array F_RANGE (mixed *,int,int);
***************
*** 254,260 ****
--- 256,264 ----
   * List of functions not used in compat mode.
   */
  #ifdef EUIDS
+ #if 0
  void export_uid(object);
+ #endif
  string geteuid(object default: F_THIS_OBJECT);
  int seteuid(string|int);
  #endif
diff -c func_spec.old func_spec
*** func_spec.std	Sun Jan 29 01:52:40 1995
--- func_spec	Mon Jan 30 19:58:04 1995
***************
*** 193,199 ****
  int mkdir(string);
  void move_object(object|string, object|string);
  mixed negate(int|float);
! void notify_fail(string|closure);
  int objectp(mixed);
  mixed *order_alist(mixed *, void|mixed *, ...);
  int pointerp(mixed);
--- 193,199 ----
  int mkdir(string);
  void move_object(object|string, object|string);
  mixed negate(int|float);
! int notify_fail(string|closure);
  int objectp(mixed);
  mixed *order_alist(mixed *, void|mixed *, ...);
  int pointerp(mixed);
diff -c interpret.old interpret.c
*** interpret.c.std	Sat Jan 28 15:13:22 1995
--- interpret.c	Mon Jan 30 19:57:23 1995
***************
*** 4480,4486 ****
  	if (sp->type != T_STRING && sp->type != T_CLOSURE)
  	    goto bad_arg_1;
  	set_notify_fail_message(sp);
! 	sp--;
  	break;
      CASE(F_INTERACTIVE);
      {
--- 4487,4493 ----
  	if (sp->type != T_STRING && sp->type != T_CLOSURE)
  	    goto bad_arg_1;
  	set_notify_fail_message(sp);
! 	put_number(0);
  	break;
      CASE(F_INTERACTIVE);
      {


diff -c src.old/array.c src/array.c
*** src.old/array.c	Wed Jan  3 16:42:28 1996
--- src/array.c	Wed Jan  3 16:47:24 1996
***************
*** 1553,1561 ****
      return vtmpp3;
  }
  
! struct vector *match_regexp(v, pattern)
      struct vector *v;
      char *pattern;
  {
      struct regexp *reg;
      char *res;
--- 1553,1564 ----
      return vtmpp3;
  }
  
! #define REGEXP_FILTER      1
! #define REGEXP_NOTMATCH    2
! struct vector *match_regexp(v, pattern, filt)
      struct vector *v;
      char *pattern;
+     int filt;
  {
      struct regexp *reg;
      char *res;
***************
*** 1577,1593 ****
  	    continue;
  	eval_cost++;
  	line = v->item[i].u.string;
! 	if (regexec(reg, line, line) == 0)
  	    continue;
  	res[i] = 1;
  	num_match++;
      }
!     ret = allocate_array(num_match);
!     for (num_match=i=0; i < v_size; i++) {
  	if (res[i] == 0)
  	    continue;
  	assign_svalue_no_free(&ret->item[num_match], &v->item[i]);
  	num_match++;
      }
      xfree((char *)reg);
      return ret;
--- 1580,1605 ----
  	    continue;
  	eval_cost++;
  	line = v->item[i].u.string;
!         if((regexec(reg, line, line) == 0) ^ ((filt&REGEXP_NOTMATCH) != 0))
  	    continue;
  	res[i] = 1;
  	num_match++;
      }
!     if(filt & REGEXP_FILTER) {
!       ret = allocate_array(v_size);
!       for(i=0; i < v_size; i++) {
! 	    (ret->item)[i].type = T_NUMBER;
! 	    (ret->item)[i].u.number = res[i];
!       }
!     }
!     else {
!       ret = allocate_array(num_match);
!       for (num_match=i=0; i < v_size; i++) {
  	if (res[i] == 0)
  	    continue;
  	assign_svalue_no_free(&ret->item[num_match], &v->item[i]);
  	num_match++;
+       }
      }
      xfree((char *)reg);
      return ret;
diff -c src.old/func_spec src/func_spec
*** src.old/func_spec	Wed Jan  3 16:42:29 1996
--- src/func_spec	Wed Jan  3 16:44:30 1996
***************
*** 151,157 ****
  
  %efuns
  
! string *regexp(string *, string);
  void add_action(string, void|string, void|int);
  object *all_inventory(object default: F_THIS_OBJECT);
  mixed *allocate(int);
--- 151,157 ----
  
  %efuns
  
! mixed *regexp(string *, string, int default: F_CONST0);
  void add_action(string, void|string, void|int);
  object *all_inventory(object default: F_THIS_OBJECT);
  mixed *allocate(int);
diff -c src.old/interpret.c src/interpret.c
*** src.old/interpret.c	Wed Jan  3 16:42:31 1996
--- src/interpret.c	Wed Jan  3 16:44:31 1996
***************
*** 3329,3337 ****
      CASE(F_REGEXP);
      {
  	struct vector *v;
! 	TYPE_TEST1(sp-1, T_POINTER)
! 	TYPE_TEST2(sp,   T_STRING)
! 	v = match_regexp((sp-1)->u.vec, sp->u.string);
  	pop_stack();
  	free_svalue(sp);
  	if (v == 0)
--- 3329,3340 ----
      CASE(F_REGEXP);
      {
  	struct vector *v;
! 
! 	TYPE_TEST1(sp-2, T_POINTER)
! 	TYPE_TEST2(sp-1, T_STRING)
! 	TYPE_TEST3(sp,   T_NUMBER)
! 	v = match_regexp((sp-2)->u.vec, (sp-1)->u.string, sp->u.number);
! 	sp--;
  	pop_stack();
  	free_svalue(sp);
  	if (v == 0)
diff -c src.old/lint.h src/lint.h
*** src.old/lint.h	Wed Jan  3 16:42:31 1996
--- src/lint.h	Wed Jan  3 16:44:31 1996
***************
*** 500,506 ****
  struct object *get_simul_efun_object PROT((void));
  struct function *find_simul_efun PROT((char *));
  char *query_simul_efun_file_name PROT((void));
! struct vector *match_regexp PROT((struct vector *v, char *pattern));
  void setup_print_block_dispatcher();
  char *query_host_name();
  void init_telopts();
--- 500,506 ----
  struct object *get_simul_efun_object PROT((void));
=== More: (93%) Page 7, 121..140 [CR,u,f,l,q,/<regexp>,<page>,?] 
  struct function *find_simul_efun PROT((char *));
  char *query_simul_efun_file_name PROT((void));
! struct vector *match_regexp PROT((struct vector *v, char *pattern, int filt));
  void setup_print_block_dispatcher();
  char *query_host_name();
  void init_telopts();


diff -c src.old/array.c src/array.c
*** src.old/array.c	Wed Jan  3 16:57:36 1996
--- src/array.c	Wed Jan  3 16:47:24 1996
***************
*** 1621,1635 ****
      struct regexplode_match *matches, **matchp, *match;
      char *text, *str;
      struct svalue *svp;
!     int num_match;
      struct vector *ret;
  
!     if (sp[-1].type != T_STRING)
  	bad_xefun_arg(1, sp);
!     if (sp->type != T_STRING)
  	bad_xefun_arg(2, sp);
!     text = sp[-1].u.string;
!     pattern = sp->u.string;
      reg = regcomp(pattern, 0);
      if (reg == 0) {
  	inter_sp = sp;
--- 1621,1638 ----
      struct regexplode_match *matches, **matchp, *match;
      char *text, *str;
      struct svalue *svp;
!     int num_match, ret_len, filt;
      struct vector *ret;
  
!     if(sp[-2].type != T_STRING)
  	bad_xefun_arg(1, sp);
!     if (sp[-1].type != T_STRING)
  	bad_xefun_arg(2, sp);
!     if (sp->type != T_NUMBER)
! 	bad_xefun_arg(3, sp);
!     text = sp[-2].u.string;
!     pattern = sp[-1].u.string;
!     filt = sp->u.number;
      reg = regcomp(pattern, 0);
      if (reg == 0) {
  	inter_sp = sp;
***************
*** 1650,1661 ****
  	    break;
      }
      *matchp = 0;
!     if (num_match > (MAX_ARRAY_SIZE-1 >> 1) ) {
  	xfree((char *)reg);
  	inter_sp = sp;
  	error("Illegal array size");
      }
!     ret = allocate_array((num_match << 1) + 1);
      svp = ret->item;
      match = matches;
      while (match) {
--- 1653,1665 ----
  	    break;
      }
      *matchp = 0;
!     ret_len = (filt?(num_match+1):((num_match<<1)+1));
!     if(ret_len > MAX_ARRAY_SIZE) {
  	xfree((char *)reg);
  	inter_sp = sp;
  	error("Illegal array size");
      }
!     ret = allocate_array(ret_len);
      svp = ret->item;
      match = matches;
      while (match) {
***************
*** 1671,1690 ****
  	svp->u.string = str;
  	svp++;
  	len = match->end - text;
! 	str = xalloc(len + 1);
! 	strncpy(str, text, len);
! 	str[len] = 0;
  	text += len;
- 	svp->type = T_STRING;
- 	svp->x.string_type = STRING_MALLOC;
- 	svp->u.string = str;
- 	svp++;
  	match = match->next;
      }
      xfree((char *)reg);
      svp->type = T_STRING;
      svp->x.string_type = STRING_MALLOC;
      svp->u.string = string_copy(text);
      free_string_svalue(sp);
      sp--;
      free_string_svalue(sp);
--- 1675,1697 ----
  	svp->u.string = str;
  	svp++;
  	len = match->end - text;
! 	if(!filt) {
! 	    str = xalloc(len + 1);
! 	    strncpy(str, text, len);
! 	    str[len] = 0;
! 	    svp->type = T_STRING;
! 	    svp->x.string_type = STRING_MALLOC;
! 	    svp->u.string = str;
! 	    svp++;
! 	}
  	text += len;
  	match = match->next;
      }
      xfree((char *)reg);
      svp->type = T_STRING;
      svp->x.string_type = STRING_MALLOC;
      svp->u.string = string_copy(text);
+     sp--;
      free_string_svalue(sp);
      sp--;
      free_string_svalue(sp);
diff -c src.old/func_spec src/func_spec
*** src.old/func_spec	Wed Jan  3 17:01:18 1996
--- src/func_spec	Wed Jan  3 16:44:30 1996
***************
*** 410,416 ****
  mixed query_editing(object);
  int query_idle(object);
  object query_snoop(object);
! string *regexplode(string, string);
  int remove_action(string, object default: F_THIS_PLAYER);
  void remove_interactive(object);
  void rename_object(object, string);
--- 410,416 ----
  mixed query_editing(object);
  int query_idle(object);
  object query_snoop(object);
! string *regexplode(string, string, int default: F_CONST0);
  int remove_action(string, object default: F_THIS_PLAYER);
  void remove_interactive(object);
  void rename_object(object, string);

*** func_spec.bak	Mon Mar 11 13:47:37 1996
--- func_spec	Sun Mar 10 14:52:30 1996
***************
*** 420,425 ****
--- 420,426 ----
  int remove_action(string, object default: F_THIS_PLAYER);
  void remove_interactive(object);
  void rename_object(object, string);
+ string subst(string, string|string*|mapping, string|string* default:F_CONST0);
  void set_auto_include_string(string);
  int set_buffer_size(int);
  void set_connection_charset(int *, int default: F_CONST1);
*** interpret.bak	Thu Mar 14 19:25:40 1996
--- interpret.c	Thu Mar 14 19:20:01 1996
***************
*** 12794,12796 ****
--- 12794,12944 ----
  	put_number(0);
      return sp;
  }
+ 
+ #define MAP_LENGTH(m) (m->condensed->string_size/sizeof(char *) + \
+                     m->condensed->misc_size/sizeof(struct svalue) + \
+                     (m->hash ? m->hash->used - m->hash->condensed_deleted : 0))
+ 
+ struct table_entry {
+     char *search;
+     char *replace;
+     int slen;
+     int rlen;
+     int partial;
+ };
+ 
+ int bad_subst_mapping;
+ 
+ void map_table_part(key, value, extra)
+     struct svalue *key, *value;
+     char *extra;
+ {
+     struct table_entry **entry = (struct table_entry **)extra;
+     if((key->type != T_STRING ) || (value->type != T_STRING)) {
+ 	bad_subst_mapping = 1;
+ 	return;
+     }
+     (*entry)->search = key->u.string;
+     (*entry)->partial = 0;
+     if((*entry)->slen = strlen(key->u.string)) {
+ 	(*entry)->rlen = strlen(value->u.string);
+ 	(*entry)->replace = value->u.string;
+     }
+     (*entry)++;
+ }
+ 
+ struct svalue *f_subst(sp)
+     struct svalue *sp;
+ {
+     struct table_entry *table, **build_table;
+ 
+     struct r_match {
+ 	char *addr;
+ 	char *replace;
+ 	int slen;
+ 	int rlen;
+ 	struct r_match *next;
+     };
+     struct r_match *first, *current;
+ 
+     int outlen, num_sr, i;
+     char *str, *match, *outp;
+     struct mapping *m;
+ 
+     if(sp[-2].type != T_STRING) bad_xefun_arg(1, sp);
+     str = sp[-2].u.string;
+     switch(sp[-1].type) {
+     case T_STRING:
+ 	if(sp->type != T_STRING) bad_xefun_arg(3, sp);
+ 	num_sr = 1;
+ 	table = (struct table_entry *)alloca(sizeof *table);
+ 	table->partial = 0;
+ 	table->search = sp[-1].u.string;
+ 	if(table->slen = strlen(table->search)) {
+ 	    table->replace = sp->u.string;
+ 	    table->rlen = strlen(table->replace);
+ 	}
+ 	break;
+     case T_POINTER:
+ 	if(sp->type != T_POINTER) bad_xefun_arg(3, sp);
+ 	if((num_sr = VEC_SIZE(sp->u.vec)) != VEC_SIZE(sp[-1].u.vec))
+ 	    error("Mismatched array sizes in subst()\n");
+ 	table = (struct table_entry *)alloca(num_sr * (sizeof *table));
+ 	for(i=0;i<num_sr;i++) {
+ 	    if(sp[-1].u.vec->item[i].type != T_STRING) bad_xefun_arg(2, sp);
+ 	    if(sp->u.vec->item[i].type != T_STRING) bad_xefun_arg(3, sp);
+ 	    table[i].partial = 0;
+ 	    table[i].search = sp[-1].u.vec->item[i].u.string;
+ 	    if(table[i].slen = strlen(table[i].search)) {
+ 		table[i].replace = sp->u.vec->item[i].u.string;
+ 		table[i].rlen = strlen(table[i].replace);
+ 	    }
+ 	}
+ 	break;
+     case T_MAPPING:
+ 	bad_subst_mapping = 0;
+ 	m = sp[-1].u.map;
+ 	if(m->num_values != 1)
+ 	    bad_xefun_arg(2, sp);
+ 	if(sp->u.number) bad_xefun_arg(3, sp);
+ 	check_map_for_destr(m);
+ 	table = (struct table_entry *)alloca((num_sr = MAP_LENGTH(m)) *
+ 					     (sizeof *table));
+ 	build_table = (struct table_entry **)alloca(sizeof *build_table);
+ 	*build_table = table;
+ 	walk_mapping(sp[-1].u.map, map_table_part, (char *)build_table);
+ 	if(bad_subst_mapping) bad_xefun_arg(2, sp);
+ 	break;
+     default:
+ 	bad_xefun_arg(2, sp);
+     }
+ 
+     match = str;
+     outlen = 0;
+     first = current = 0;
+     while(*match) {
+ 	outlen++;
+ 	for(i=0;i<num_sr;i++) {
+ 	    if(!table[i].slen) continue;
+ 	    if(*match == table[i].search[table[i].partial]) {
+ 		if(++(table[i].partial) == table[i].slen) {
+ 		    if(first == 0)
+ 			first = current =
+ 			  (struct r_match *)alloca(sizeof *first);
+ 		    else {
+ 			current->next =
+ 			  (struct r_match *)alloca(sizeof *current);
+ 			current = current->next;
+ 		    }
+ 		    current->next = 0;
+ 		    current->addr = match + 1 - table[i].slen;
+ 		    current->replace = table[i].replace;
+ 		    current->slen = table[i].slen;
+ 		    current->rlen = table[i].rlen;
+ 		    outlen += (table[i].rlen - table[i].slen);
+ 		    for(i=0;i<num_sr;i++) table[i].partial = 0;
+ 		    break;
+ 		}
+ 	    }
+ 	    else table[i].partial = 0;
+ 	}
+ 	match++;
+     }
+     match = outp = xalloc(outlen + 1);
+     current = first;
+     while(current != 0) {
+ 	while(str != current->addr) { *match++ = *str++; }
+ 	strcpy(match, current->replace);
+ 	match += current->rlen;
+ 	str += current->slen;
+         current = current->next;
+     }
+     strcpy(match, str);
+     free_svalue(sp--);
+     free_svalue(sp--);
+     free_svalue(sp);
+     sp->type = T_STRING;
+     sp->x.string_type = STRING_MALLOC;
+     sp->u.string = outp;
+     return sp;
+ }


