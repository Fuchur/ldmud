---- Obsolete and/or omitted diffs: -----

diff -u -r -N --ignore-space-change driver-3.2.1@141/func_spec driver-321@141-mod/func_spec
--- driver-3.2.1@141/func_spec	Sat Oct 26 15:37:54 1996
+++ driver-321@141-mod/func_spec	Sat Oct 10 20:33:04 1998
@@ -204,22 +213,30 @@
 object present(object|string, void|object);
 mixed *query_actions(object|string, int|object|string default: F_CONST1);
 string query_load_average();
+int query_su_level(object); /* Kickaha */
+string query_su_name(object); /* Kickaha */
+int query_valid_file(string,string);           /* Kickaha */
 string query_verb();
 int random(int);
 string read_bytes(string, void|int, void|int);
 string read_file(string, void|int, void|int);
 int remove_call_out(string|closure);
 int rename(string, string);
 void replace_program(string);
-int restore_object(string);
+int restore_object(string, void|object);
 int rm(string);
 int rmdir(string);
 mixed *rusage();
-void save_object(string);
+void save_object(string, void|object);
 void say(string|mixed *, void|object|object *);
 string set_bit(string, int);
 int set_heart_beat(int);
 int set_light(int);
+int set_uid_file(string, int);
+int set_uid_me(object, int, void|string);
 void set_this_object(object);
 int sizeof(mixed *|mapping);
 mixed *slice_array F_RANGE (mixed *,int,int);
diff -u -r -N --ignore-space-change driver-3.2.1@141/interpret.c driver-321@141-mod/interpret.c
--- driver-3.2.1@141/interpret.c	Mon Feb 16 17:30:10 1998
+++ driver-321@141-mod/interpret.c	Sat Oct 10 20:33:08 1998
@@ -4060,13 +4109,27 @@
 	break;
     }
     CASE(F_SAVE_OBJECT);
+    {
+	struct svalue *arg;
 	assign_eval_cost();
-	TYPE_TEST1(sp, T_STRING)
+	GET_NUM_ARG
+	arg = sp - num_arg + 1;
+
+	TYPE_TEST1(arg, T_STRING)
 	inter_sp = sp;
 	inter_pc = pc;
-	save_object(current_object, sp->u.string);
+
+	if (num_arg==2)
+	{
+  	  TYPE_TEST2(arg+1, T_OBJECT)
+	  save_object((arg+1)->u.ob, arg->u.string);
+	  pop_stack();
+        }
+	else 
+	  save_object(current_object, arg->u.string);
 	pop_stack();
 	break;
+    }
     CASE(F_FIND_OBJECT);
     {
 	struct object *ob;
@@ -4213,13 +4276,32 @@
     CASE(F_RESTORE_OBJECT);
     {
 	int i;
+	char tmp1[30], tmp2[30];
+	struct svalue *arg;
 
 	assign_eval_cost();
-	TYPE_TEST1(sp, T_STRING)
+
+        GET_NUM_ARG
+        arg = sp - num_arg + 1;
+
+        TYPE_TEST1(arg,   T_STRING)
 	inter_sp = sp;
 	inter_pc = pc;
-	i = restore_object(current_object, sp->u.string);
-	free_svalue(sp);
+        if (num_arg==2) TYPE_TEST2(arg+1, T_OBJECT)
+
+	if (num_arg==2)
+	{
+	  if (!O_GET_INTERACTIVE(arg[1].u.ob) &&
+	     sscanf(arg[0].u.string, "%ssecure%s", tmp1, tmp2)==2)
+            error("Restore_object(\"%s\") - not allowed to restore living!\n",
+	      arg[0].u.string);
+	}
+
+	if (num_arg==2)
+	  i = restore_object((arg+1)->u.ob, arg->u.string);
+        else i = restore_object(current_object, arg->u.string);
+	free_svalue(arg);
+        pop_n_elems(num_arg-1);
 	put_number(i);
 	break;
     }
@@ -8336,6 +8725,73 @@
 	pop_stack();
 	break;
     }
+    CASE(F_SET_UID_FILE);
+    {
+      struct svalue *arg = sp-1;
+      int ret;
+//      ret = set_file_su(arg[0].u.string, arg[1].u.number);
+      pop_n_elems(2);
+      push_number(ret);
+      break;
+    }
+    CASE(F_SET_UID_ME);
+    {
+            int ret;
+            struct svalue *arg;
+
+	    GET_NUM_ARG
+	    arg = sp - num_arg + 1;
+
+//            if (num_arg == 3)
+//                ret = setuid_me(current_object, arg[0].u.ob,
+//                                            arg[1].u.number, arg[2].u.string);
+//            else
+//                ret = setuid_me(current_object, arg[0].u.ob,
+//                                            arg[1].u.number, 0);
+            pop_n_elems(num_arg);
+            push_number(ret);
+            break;
+    }
+    CASE(F_QUERY_SU_LEVEL);
+    {
+      int ret;
+      ret = sp->u.ob->level;
+      pop_stack();
+      push_number(ret);
+      break;
+    }
+    CASE(F_QUERY_SU_NAME);
+    {
+      char *ret;
+      ret = string_copy(sp->u.ob->su_name);
+      pop_stack();
+      push_string_malloced(ret);
+      break;
+    }
 #ifdef MAPPINGS
     CASE(F_MAP_INDEX);
     {
@@ -6476,6 +6820,12 @@
 	    if (sp[-1].type != T_STRING && sp[-1].type != T_POINTER)
 		goto bad_arg_1;
 	    if ( sp->type == T_POINTER ) {
+		if (sp->u.vec->ref > 1) {
+		    struct vector *vtmpp =
+		      slice_array(sp->u.vec, 0, VEC_SIZE(sp->u.vec)-1);
+		    say(sp-1, vtmpp);
+		    free_vector(vtmpp);
+		} else
 		say(sp-1, sp->u.vec);
 	    } else if (sp->type == T_OBJECT) {
 		vtmp.v.item[0].type = T_NUMBER;
diff -u -r -N --ignore-space-change driver-3.2.1@141/lex.c driver-321@141-mod/lex.c
--- driver-3.2.1@141/lex.c	Mon Feb 16 17:30:24 1998
+++ driver-321@141-mod/lex.c	Sat Oct 10 20:33:08 1998
@@ -42,7 +42,7 @@
 struct lpc_predef_s *lpc_predefs=NULL;
 static INLINE int number PROT((int));
 static INLINE int string PROT((char *));
-static void handle_define PROT((char *, int));
+static void handle_define PROT((char *));
 static void add_define PROT((char *, int, char *));
 #ifdef __GNUC__ /* old gcc versions, like on a NeXT, want it like this... */
 static void add_permanent_define PROT((char *, int, char *, int));
@@ -1445,7 +1448,7 @@
 	    if (strcmp("include", yytext) == 0) {
                 handle_include(sp);
 	    } else {myfilbuf();if (strcmp("define", yytext) == 0) {
-		handle_define(sp, quote);
+		handle_define(sp);
 	    } else if (strcmp("if", yytext) == 0) {
 		int cond;
 		struct svalue sv;
@@ -2020,13 +2024,12 @@
     }
 }
 
-static int
-refill(quote)
-int quote;
+static void
+refill()
 {
     char *p;
     int c;
-    int last = 0;
+    int last = 0, quote = 0;
 
     p = yytext;
         do {
@@ -2061,13 +2064,11 @@
     nexpands=0;
     current_line++;
     store_line_number_info();
-    return quote;
 }
 
 static void
-handle_define(yyt, quote)
+handle_define(yyt)
 char *yyt;
-int quote;
 {
     char namebuf[NSIZE];
     char args[NARGS][NSIZE];
@@ -2140,11 +2141,11 @@
 	    if (!*p) {
 	      if (p[-2] == '\\') {
 		q -= 2;
-		quote = refill(quote);
+		refill();
 		p = yytext;
 	      } else if (p[-2] == '\r' && p[-3] == '\\' ) {
 		q -= 3;
-		quote = refill(quote);
+		refill();
 		p = yytext;
 	      }
 	    }
@@ -2163,11 +2164,11 @@
 	    if (!*p) {
 	      if (p[-2] == '\\') {
 		q -= 2;
-		quote = refill(quote);
+		refill();
 		p = yytext;
 	      } else if (p[-2] == '\r' && p[-3] == '\\' ) {
 		q -= 3;
-		quote = refill(quote);
+		refill();
 		p = yytext;
 	      }
 	    }
diff -u -r -N --ignore-space-change driver-3.2.1@141/simulate.c driver-321@141-mod/simulate.c
--- driver-3.2.1@141/simulate.c	Mon Feb 16 17:30:06 1998
+++ driver-321@141-mod/simulate.c	Sat Oct 10 20:33:10 1998
@@ -460,6 +460,7 @@
     ob->name = string_copy(name);	/* Shared string is no good here */
     ob->prog = prog;
     ob->next_all = obj_list;
+//    init_object_su(ob, ob->name, ob->file_was_suid);  /* Kickaha */
     obj_list = ob;
     enter_object_hash(ob);	/* add name to fast object lookup table */
 
@@ -609,6 +610,7 @@
     new_ob->flags |= O_CLONE | ob->flags & ( O_APPROVED | O_WILL_CLEAN_UP ) ;
     new_ob->prog = ob->prog;
     reference_prog (ob->prog, "clone_object");
+//    init_object_su(new_ob, ob->name, ob->file_was_suid);  /* Kickaha */
 #ifdef DEBUG
     if (!current_object)
 	fatal("clone_object() from no current_object !\n");
diff -u -r -N --ignore-space-change driver-3.2.1@141/object.c driver-321@141-mod/object.c
--- driver-3.2.1@141/object.c	Mon Feb 16 17:30:04 1998
+++ driver-321@141-mod/object.c	Fri Oct 23 09:27:56 1998
@@ -1359,6 +1412,10 @@
      */
     *ob = NULL_object;
     ob->ref = 1;
+    ob->level = 0;       /* Kickaha */
+    ob->su_name = 0;     /* Kickaha */
+    ob->file_was_suid = 0; /* Kickaha */
+    ob->sent = NULL;   /* Kickaha */
 #ifdef DEBUG
     ob->extra_num_variables = num_var;
 #endif
diff -u -r -N --ignore-space-change driver-3.2.1@141/object.h driver-321@141-mod/object.h
--- driver-3.2.1@141/object.h	Mon Feb 16 17:30:04 1998
+++ driver-321@141-mod/object.h	Sat Oct 10 20:33:10 1998
@@ -33,6 +32,7 @@
 
 struct object {
     unsigned short flags;	/* Bits or'ed together from above */
+    char file_was_suid;         /* Kickaha */
     short total_light;
     int next_reset;		/* Time of next reset of this object */
     int time_of_ref;		/* Time when last referenced. Used by swap */
@@ -40,7 +40,9 @@
 #ifdef DEBUG
     p_int extra_ref;		/* Used to check ref count. */
 #endif
+    int level;                  /* capability based security - Kickaha */
     struct program *prog;
+    char *su_name;              /* playername for owner - Kickaha */
     char *name;
     struct object *next_all, *next_inv, *next_hash;
     struct object *contains;
diff -u -r -N --ignore-space-change driver-3.2.1@141/object.c driver-321@141-mod/object.c
--- driver-3.2.1@141/object.c	Mon Feb 16 17:30:04 1998
+++ driver-321@141-mod/object.c	Fri Oct 23 09:27:56 1998
@@ -692,6 +723,10 @@
 
     if (ob->flags & O_DESTRUCTED)
 	return;
+    if (ob->flags & O_SWAPPED)   /* Kickaha */
+      if (load_ob_from_swap(ob) < 0)
+	error("Out of memory\n");
+
This is in save_object() for the save_object(f,ob) variant.
     /* COMPAT_MODE stuff moved to master.c by amylaar
      * master.c will access current_object->prog->name instead of
      * current_prog->name , but then, this is probably better in COMPAT_MODE
@@ -1108,10 +1152,14 @@
 	struct discarded *next;
     } * dp = 0;
 
-    if (current_object != ob)
-	fatal("Bad argument to restore_object()\n");
+/*    if (current_object != ob)
+	fatal("Bad argument to restore_object()\n");   Kickaha */
+
     if (ob->flags & O_DESTRUCTED)
 	return 0;
+    if (ob->flags & O_SWAPPED)    /* Kickaha */
+      if (load_ob_from_swap(ob) < 0)
+	error("Out of memory\n");
This is in restore_object() for the restore_object(f,ob) variant.
 
     file = check_valid_path(file, ob, "restore_object", 0);
     if (file == 0)
@@ -875,6 +918,7 @@
 	*svp = const0;
 	return 0;
     }
+    *str = end;      /* Kickaha, 15/5/1994 */
     v = allocate_array(siz);

This is restore_array(). 
     /* We need to do this now, so that the value can be used inside. */
------
